<?php
	/** 
		MICROCORE REVISION: 19629
		BRANCH: 2.8.5.1_2012-04-26__13-33-00
		GENERATED: 26-04-2012 13:34
	*/

	if(!defined("CURRENT_VERSION_LINE")) define("CURRENT_VERSION_LINE", "");
	if(!defined("CURRENT_WORKING_DIR")) define("CURRENT_WORKING_DIR", dirname(dirname(dirname(__FILE__))));
	
	$interface_langs = array('ru');



	/*if (!defined("UMI_SYSTEM_START_TIME"))		{ define("UMI_SYSTEM_START_TIME",microtime(true)); }
	if (!defined("UMI_TIME_PROFILER_LEVEL"))	{ define("UMI_TIME_PROFILER_LEVEL",0); }
	if (!defined("UMI_TIME_PROFILER_MINDELTA"))	{ define("UMI_TIME_PROFILER_MINDELTA",0); }
	if (!defined("UMI_TIME_PROFILER_PID"))		{ define("UMI_TIME_PROFILER_PID",uniqid()); }
	if (!defined("UMI_TIME_PROFILER_LOG"))		{ define("UMI_TIME_PROFILER_LOG",rtrim($_SERVER['DOCUMENT_ROOT'],'/').'/time-profile.log'); }
	//if (!defined("UMI_XSLT_PROFILER_LOG"))		{ define("UMI_XSLT_PROFILER_LOG",rtrim($_SERVER['DOCUMENT_ROOT'],'/').'/xslt-profile.log'); }

	file_put_contents(	UMI_TIME_PROFILER_LOG,
				"Id             Action                                                  Run time           Action time                     Memory    Rusage\n",
				FILE_APPEND);

	$umi_time_profiler_mark=UMI_SYSTEM_START_TIME;*/

	/**
	* Профилирование выполнения.
    * Выводит метку, время от начала работы скрипта, и дельту времени от предыдущей метки в миллисекундах.
    * Не забывайте коментировать содержимое этой функции после отладки, чтобы не затрачивать ресурсы на production-сайтах.
	* 
	* @param string $m - метка, по которой можно однозначно определить место её установки
	* @param int $level - уровень уведомления (задается произвольно по желанию разработчика в каждом вызове функции showWorkTime)
	*/
	function showWorkTime($m, $level=0) {
		/*global $umi_time_profiler_mark;
		if ($level<=UMI_TIME_PROFILER_LEVEL) {
			$mt=microtime(true);
			$delta=$mt-$umi_time_profiler_mark;
			if ($delta>=UMI_TIME_PROFILER_MINDELTA) {
				$ru=getrusage();
				file_put_contents(UMI_TIME_PROFILER_LOG,sprintf("%-70s",substr("#".UMI_TIME_PROFILER_PID." ".$m,0,70))." ".sprintf("%-18s",substr($mt-UMI_SYSTEM_START_TIME,0,18))." [".(sprintf("%-17s",1000*($delta)))." msec]"." ".sprintf("%10s",intval(0.001*memory_get_usage()))." Kb    ".($ru['ru_utime.tv_sec']+$ru['ru_utime.tv_usec']/1000000).":".($ru['ru_stime.tv_sec']+$ru['ru_stime.tv_usec']/1000000)."\n",FILE_APPEND);
			}
		$umi_time_profiler_mark=$mt;
		}*/
	}	
	


	interface iSingleton {
		public static function getInstance($c = NULL);
	};

	interface iUmiEntinty {
		public function getId();
		public function commit();
		public function update();

		public static function filterInputString($string);
	};


/**
	* Базовый класс синглетон
*/
	abstract class singleton {
		private static $instances = Array();

		/**
			* Конструктор, который необходимо перегрузить в дочернем классе
		*/
		abstract protected function __construct();

		/**
			* Получить экземпляр класса, необходимо перегрузить в дочернем классе:
			* parent::getInstance(__CLASS__)
			* @param String имя класса
			* @return singleton экземпляр класса
		*/
		public static function getInstance($c = NULL) {
			if (!isset(singleton::$instances[$c])) {
				singleton::$instances[$c] = new $c;
			}
			return singleton::$instances[$c];
		}

		/**
			* Запрещаем копирование
		*/
		public function __clone() {
			throw new coreException('Singletone clonning is not permitted. Just becase it\'s non-sense.');
		}
		
		/**
			* Отключить кеширование повторных sql-запросов
		*/
		protected function disableCache() {
			if(!defined('MYSQL_DISABLE_CACHE')) {
				define('MYSQL_DISABLE_CACHE', '1');
			}
		}

		/**
			* Получить языкозависимую строку по ее ключу
			* @param String $label ключ строки
			* @return String значение строки в текущей языковой версии
		*/
		protected function translateLabel($label) {
			$prefix = "i18n::";
			if(substr($label, 0, strlen($prefix)) == $prefix) {
				$str = getLabel(substr($label, strlen($prefix)));
			} else {
				$str = getLabel($label);
			}
			return (is_null($str)) ? $label : $str;
		}

	};


/**
	* Базовый класс для классов, которые реализуют ключевые сущности ядра системы.
	* Реализует основные интерфейсы, которые должна поддерживать любая сущность.
*/
	abstract class umiEntinty {
		protected $id, $is_updated = false;

		protected $bNeedUpdateCache = false;

		/**
			* Конструктор сущности, должен вызываться из коллекций
			* @param Integer $id id сущности
			* @param Array $row=false массив значений, который теоретически может быть передан в конструктор для оптимизации
		*/
		public function __construct($id, $row = false) {
			$this->setId($id);
			$this->is_updated = false;
			if($this->loadInfo($row) === false) {
				throw new privateException("Failed to load info for {$this->store_type} with id {$id}");
			}
		}

		/**
			* Запрещаем копирование
		*/
		public function __clone() {
				throw new coreException('umiEntinty must not be cloned');
    	}

		/**
			* Деструктор сущности проверят, были ли внесены изменения. Если да, то они сохраняются
		*/
		public function __destruct() {
			if ($this->is_updated) {
				$this->save();
				$this->setIsUpdated(false);
				$this->updateCache();
			} elseif ($this->bNeedUpdateCache) {
				// В memcached кидаем только при деструкте и только если были какие-то изменения
				$this->updateCache();
			}
		}

		/**
			* Вернуть id сущности
			* @return Integer $id
		*/
		public function getId() {
			return $this->id;
		}

		/**
			* Изменить id сущности
			* @param Integer $id новый id сущности
		*/
		protected function setId($id) {
			$this->id = (int) $id;
		}

		/**
			* Узнать, есть ли несохраненные модификации
			* @return Boolean true если есть несохраненные изменения
		*/
		public function getIsUpdated() {
			return $this->is_updated;
		}

		/**
			* Установить флаг "изменен"
			* @param Boolean $is_updated=true значение флага "изменен"
		*/
		public function setIsUpdated($is_updated = true) {
			$this->is_updated 	    = (bool) $is_updated;
			$this->bNeedUpdateCache = $this->is_updated;
		}
		
		public function beforeSerialize() {}
		public function afterSerialize() {}
		
		public function afterUnSerialize() {}

		/**
			* Загрузить необходимую информацию о сущности из БД. Требует реализации в дочернем классе.
		*/
		abstract protected function loadInfo();

		/**
			* Сохранить в БД информацию о сущности. Требует реализации в дочернем классе.
		*/
		abstract protected function save();

		/**
			* Применить совершенные изменения, если они есть. Если нет, вернет false
			* @return Boolean true если изменения примененые и при этом не возникло ошибок
		*/
		public function commit() {
			if ($this->is_updated) {
				$this->disableCache();
				$res = $this->save();

				if (cacheFrontend::getInstance()->getIsConnected()) {
					// обновляем инфу об объекте из базы для корректного сохранения не применившихся свойств в memcached
					$this->update();
				} else {
					$this->setIsUpdated(false);
				}

				return $res;
			} else {
				return false;
			}
		}

		/**
			* Заново прочитать все данные сущности из БД. Внесенные изменения скорее всего будут утеряны
			* @return Boolean результат операции зависит от реализации loadInfo() в дочернем классе
		*/
		public function update() {
			$res = $this->loadInfo();
			$this->setIsUpdated(false);
			$this->updateCache();
			return $res;
		}

		/**
			* Отфильтровать значения, попадающие в БД
			* @param String $string значение
			* @return String отфильтрованное значение
		*/
		public static function filterInputString($string) {
			$string = l_mysql_real_escape_string($string);
			return $string;

		}
		
		/**
			* Magic method
			* @return id объекта
		*/
		public function __toString() {
			return (string) $this->getId();
		}
		
		/**
			* Обновить версию сущности, которая находится в кеше
		*/
		protected function updateCache() {
			cacheFrontend::getInstance()->save($this, $this->store_type);
		}
		
		/**
			* Отключить каширование повторных sql-запросов
		*/
		protected function disableCache() {
			if(!defined('MYSQL_DISABLE_CACHE')) {
				if(get_class($this) === "umiObjectProperty") {
					return;
				}
				define('MYSQL_DISABLE_CACHE', '1');
			}
		}

		/**
			* Перевести строковую константу по ее ключу
			* @param String $label ключ строковой константы
			* @return String значение константы в текущей локали
		*/
		protected function translateLabel($label) {
			$prefix = "i18n::";
			if(substr($label, 0, strlen($prefix)) == $prefix) {
				$str = getLabel(substr($label, strlen($prefix)));
			} else {
				$str = getLabel($label);
			}
			return (is_null($str)) ? $label : $str;
		}

		/**
			* Получить ключ строковой константы, если она определена, либо вернуть саму строку
			* @param String $str строка, для которых нужно определить ключ
			* @param String $pattern="" префикс ключа, используется внутри системы
			* @return String ключ константы, либо параметр $str, если такого значение нет в списке констант
		*/
		protected function translateI18n($str, $pattern = "") {
			$label = getI18n($str, $pattern);
			return (is_null($label)) ? $str : $label;
		}
	};



	class cacheFrontend extends singleton implements iSingleton {
		public static $cacheMode = false;
		public static $currentlangId = false;
		public static $currentDomainId = false;
		public static $adminMode = false;
		
		public static function getInstance($c = NULL) {
			return parent::getInstance(__CLASS__);
		}
		
		public function getIsConnected() {
			return false;
		}
		
		protected function __construct() {
		}
		
		public function load() {
			return false;
		}
		
		public function save() {
			return false;
		}
		
		public function loadSql() {
			return false;
		}
		
		public function saveSql() {
			return false;
		}
		
		public function flush() {
			return false;
		}
		
		public function del() {
			return false;
		}
		
		public function loadData() {
			return false;
		}
		
		public function saveData($key, $data, $expire = 5) {
			
		}
	};


/**
	* Классы, реализующие интерфейс iConnectionPool предназначены для управления соединениями с различными базами данных.
	* Задачей этого класса является возможность при необходимости распределить нагрузку по различным базам данных,
	* которые в теории можно лучше оптимизировать под отведенные им задачи.
	* В минимальной версии предполагается поддержка только MySQL. В дальнейшем, при протировании системы на
	* PostgreSQL, MSSQL, либо Oracle для этой версии должен быть реализован соответствующий класс с этим интерфейсом.
	* Предполагается, что у нас есть несколько классов соединений для различных подсистем. Например:
	* 1. core
	* 2. backup
	* 3. stat
	* 4. counters
	* Если заданы параметры соединения только для первого класса ("core"), то все остальные классы соединения используют его.
	*
	* Пример инициализации (в файле mysql.php):
	* <?php
	* 		$connectionPool = ConnectionPool::getInstance();
	*		$connectionPool->addConnection("core", "localhost", "root", "", "umi");
	*		$connectionPool->addConnection("stat", "192.168.0.39", "asd", "ddd", "ggg", false, true);
	*		$connectionPool->init();
	* ?>
	*
	* Пример использования:
	* $connectionPool = ConnectionPool::getInstance();
	* $connection     = $connectionPool->getConnenction('stat');
	* $connection->query("SHOW TABLES");
*/
class ConnectionPool {
	private static $instance = null;
	private $pool = array('core' => null);
	private $connectionClassName = 'mysqlConnection';
	/**
	 * Private constructor for preventing outer instantiation
	 */
	private function __construct() {
		return;
	}
	/**
		* Статический метод, который позволяет получить экземпляр класса
		* @return ConnectionPool экземпляр класса
	*/
	static public function getInstance($c = NULL) {
		if(!self::$instance) {
			self::$instance = new ConnectionPool();
		}
		return self::$instance;
	}

	/**
		* Инициализировать основные соединения (например, только "core").
		* Выбор того, какие соединения являются основными определеяется внутренней логикой класса.
	*/
	public function init() {
		foreach($this->pool as $connection) {
			if($connection instanceof Connection) {
				$connection->open();
			}
		}
	}
	/**
	 * Устанавливает класс для объекта-соединения
	 * @param String $className
	 */
	public function setConnectionObjectClass($className = 'mysqlConnection') {
		if(class_exists($className) && in_array('IConnection', class_implements($className)) ) {
			$this->connectionClassName = $className;
		}
	}

	/**
		* Получить список всех доступных классов соединения
		* @return Array список всех соединений
	*/
	public function getConnectionClasses() {
		return array_keys($this->pool);
	}

	/**
		* Добавить новый класс соединения
		* @param String $className id класса соединения
		* @return Boolean true, если добавление нового класса прошло успешно
	*/
	public function addConnectionClass($className) {
		if(!array_key_exists($className, $this->pool)) {
			$this->pool[$className] = null;
		}
		return true;
	}
	/**
		* Удалить класс соединения
		* @param String $className id класса соединения
		* @return Boolean true, если удаление класса прошло успешно
	*/
	public function delConnectionClass($className){
		if($className == 'core') return false;
		if(isset($this->pool[$className])){
			$connection = $this->pool[$className];
			if($connection instanceof Connection) {
						$connection->close();
			}
			unset($this->pool[$className]);
			return true;
		}
		return false;
	}
	/**
		* Добавить новое соединение с базой данных
		* @param String $className id класса соединения
		* @param String $host хост базы данных
		* @param String $login логин к базе данных
		* @param String $password пароль к базе данных
		* @param String $dbname название базы данных
		* @param Integer|Boolean $port = false порт базы данных
		* @param Boolean $persistent = false постоянное соединение, если true
		* @return Boolean
	*/
	public function addConnection($className, $host, $login, $password, $dbname, $port = false, $persistent = false) {
		$connClassName = $this->connectionClassName;
		$connection    = new $connClassName($host, $login, $password, $dbname, $port, $persistent);		
		if(isset($this->pool[$className])) {
			if($this->pool[$className] instanceof Connection) {
				$this->pool[$className]->close();
			}
		}
		$this->pool[$className] = $connection;
		return true;
	}

	/**
		* Удалить соединение. При открытом соединении, метод вызывает процедуру закрытия соединения.
		* @param String $className id класса соединения
		* @param Boolean результат операции
	*/
	public function delConnection($className) {
		if(isset($this->pool[$className])){
			$connection = $this->pool[$className];
			if($connection instanceof Connection) {
				$connection->close();
			}
			$this->pool[$className] = null;
			return true;
		}
		return false;
	}

	/**
		* Получить ресурс соединения. Может выбрасывать исключение "databaseException" в случае неудачи.
		* Если соединение еще не активировано, метод запускает процедуру его подключения.
		* @param String $className = "core" id класса соединения
		* @return IConnection ресурс подключения к базе данных, либо false в случае неудачи
	*/
	public function getConnection($className = 'core') {
		if(!isset($this->pool[$className])) {
			$className = 'core';
		}
		$connection = $this->pool[$className];
		if(!($connection instanceof IConnection)) {
			throw new Exception("No suitable connection found");
		}
		return $connection;
	}

	/**
		* Закрыть соединение
		* @param String $className id класса соединения
		* @return Boolean результат операции
	*/
	public function closeConnection($className) {
		if(isset($this->pool[$className])){
			$connection = $this->pool[$className];
			if($connection instanceof Connection) {
				$connection->close();
			}
			return true;
		}
		return false;
	}
};


/**
 * Интерфейс соединения с базой данных
 * Пример использования:
 *		$connection = new Connection('localhost', 'root', '', 'umi');
 *		$connetcion->open();
 *		$connection->query('SHOW TABLES');
 *		$connection->close();
 */
interface IConnection {
	/**
	 * Конструктор соединения
	 * @param String  $host хост СУБД
	 * @param String  $login имя пользователя БД
	 * @param String  $password пароль к БД
	 * @param String  $dbname имя БД
	 * @param Integer $port порт
	 * @param Boolean $persistent true - для сохранения подключения открытым
	 * @param Boolean $critical true - если функционирование подключения критично для системы
	 */
	public function __construct($host, $login, $password, $dbname, $port = false, $persistent = false, $critical = true);
	/**
	 * Открывает соединение
	 * @return Boolean
	 */
	public function open();
	/**
	 * Закрывает текущее соединение
	 */
	public function close();
	/**
	 * Выполняет запрос к БД
	 * @param String  $queryString строка запроса
	 * @param Boolean $noCache true - кэшировать результат, false - не кэшировать
	 * @return Resource результат выполнения запроса
	 */
	public function query($queryString, $noCache = false);
	/**
	 * Выполняет запрос к БД
	 * @param String  $queryString строка запроса
	 * @param Boolean $noCache true - кэшировать результат, false - не кэшировать
	 * @return IQueryResult результат выполнения запроса
	 */
	public function queryResult($queryString, $noCache = false);
	/**
	 * Проверяет, успешно ли завершен последний запрос
	 * @return Boolean true в случае возникновения ошибки, иначе false
	 */
	public function errorOccured();
	/**
	 * Возвращает описание последней возникшей ошибки
	 * @return String
	 */
	public function errorDescription();
	/**
	 * Возвращает признак открыто соединение или нет
	 * @return Boolean
	 */
	public function isOpen();
	/**
	* Экранирует входящую строку
	* @param String $input строка для экранирования
	* @return экранированная строка
	*/
	public function escape($input);

	/**
	* Возвращает массив с описанием соединения:
	*@return Array
	*
	*/
	public function getConnectionInfo();
};


/**
 * Класс, содержащий результат
 */
interface IQueryResult extends IteratorAggregate {
	// Константы, определяющие тип выборки результата
	const FETCH_ARRAY  = 0;
	const FETCH_ROW    = 1;
	const FETCH_ASSOC  = 2;
	const FETCH_OBJECT = 3;
	/**
	 * Конструктор
	 * @param Resource $_ResultResource Ресурс результата mysql запроса
	 * @param Int      $_fetchType		Тип выборки (см. константы)
	 */
	public function __construct($_ResultResource, $_fetchType = self::FETCH_ARRAY);
	/**
	 * Устанавливает тип выборки из результата (см. константы)
	 * @param Int $newType
	 */
	public function setFetchType($newType);
	/**
	 * Возвращает тип выборки
	 * @return Int
	 */
	public function getFetchType();
	/**
	 * Выбирает строку значений из результата
	 * и возвращает ее в соответствии с заданым типом выборки
	 */
	public function fetch();
	/**
	* Возвращает количество выбранных строк
	* @return Int
	*/
	public function length();
};
/**
 *
 */
interface IQueryResultIterator extends Iterator {	
};


/**
 * Класс соединения с базой данных
 * Пример использования:
 *		$connection = new Connection('localhost', 'root', '', 'umi');
 *		$connetcion->open();
 *		$connection->query('SHOW TABLES');
 *		$connection->close();
 */
class mysqlConnection implements IConnection {
	private $host		= null;
	private $username	= null;
	private $password	= null;
	private $dbname		= null;
	private $port		= false;
	private $persistent = false;
	private $critical   = true;
	private $conn		= null;
	private $queryCache = array();
	private $isOpen     = false;
	/**
	 * Конструктор соединения
	 * @param String  $host хост СУБД
	 * @param String  $login имя пользователя БД
	 * @param String  $password пароль к БД
	 * @param String  $dbname имя БД
	 * @param Integer $port порт
	 * @param Boolean $persistent true - для сохранения подключения открытым
	 * @param Boolean $critical true - если функционирование подключения критично для системы
	 */
	public function __construct($host, $login, $password, $dbname, $port = false, $persistent = false, $critical = true) {
		$this->host       = $host;
		$this->username   = $login;
		$this->password   = $password;
		$this->dbname     = $dbname;
		$this->port       = $port;
		$this->persistent = $persistent;
		$this->critical   = $critical;
	}

	/**
	 * Открывает соединение
	 * @return Boolean
	 */
	public function open() {
		if($this->isOpen) return true;

		try {
			$server = $this->host . ($this->port ? ':' . $this->port : '');
			if($this->persistent) {
				$this->conn = mysql_pconnect($server, $this->username, $this->password);
			} else {
				$this->conn = mysql_connect($server, $this->username, $this->password, true);
			}
			if($this->errorOccured()) throw new Exception();
			if(!mysql_select_db($this->dbname, $this->conn)) throw new Exception();


			mysql_query("SET NAMES utf8", $this->conn);
			mysql_query("SET CHARSET utf8", $this->conn);
			mysql_query("SET CHARACTER SET utf8", $this->conn);
			mysql_query("SET character_set_client = 'utf8'", $this->conn);
			mysql_query("SET SESSION collation_connection = 'utf8_general_ci'", $this->conn);
			mysql_query("SET SQL_BIG_SELECTS=1", $this->conn);
		} catch(Exception $e) {
			if($this->critical)
				mysql_fatal();
			else
				return false;
		}
		$this->isOpen = true;
		return true;
	}
	/**
	 * Закрывает текущее соединение
	 */
	public function close() {
		if($this->isOpen) {
			mysql_close($this->conn);
			$this->isOpen = false;
		}
	}
	/**
	 * Выполняет запрос к БД
	 * @param String  $queryString строка запроса
	 * @param Boolean $noCache true - кэшировать результат, false - не кэшировать
	 * @return Resource результат выполнения запроса
	 */
	public function query($queryString, $noCache = false) {
		if(!$this->open()) return false;

		$queryString = trim($queryString, " \t\n");

		if(defined('SQL_QUERY_DEBUG') && SQL_QUERY_DEBUG) {
			echo $queryString, "\r\n";
		}

		if(strtoupper(substr($queryString, 0, 6)) != "SELECT" || defined('MYSQL_DISABLE_CACHE')) {
			$result = mysql_query($queryString, $this->conn);

			if($this->errorOccured()) {
				throw new databaseException($this->errorDescription($queryString));
			}

			return $result;
		}
		$hash = md5($queryString);
		if(isset($this->queryCache[$hash]) && $noCache == false) {
			$result = $this->queryCache[$hash][0];
			if($this->queryCache[$hash][1]) {
				mysql_data_seek($result, 0);
			}
		} else {
			$result = mysql_query($queryString, $this->conn);
			if( $this->errorOccured() ) {
				$this->queryCache[$hash] = false;
				throw new databaseException( $this->errorDescription($queryString) );
			} else {
				if(SQL_QUERY_CACHE) {
					$this->queryCache[$hash] = array($result, mysql_num_rows($result));
				}
			}
		}
		return $result;
	}
	/**
	 * Выполняет запрос к БД
	 * @param String  $queryString строка запроса
	 * @param Boolean $noCache true - кэшировать результат, false - не кэшировать
	 * @return IQueryResult результат выполнения запроса
	 */
	public function queryResult($queryString, $noCache = false) {
		$result = $this->query($queryString, $noCache);
		return $result ? new mysqlQueryResult($result) : null;
	}
	/**
	 * Проверяет, успешно ли завершен последний запрос
	 * @return Boolean true в случае возникновения ошибки, иначе false
	 */
	public function errorOccured() {
		return (strlen(mysql_error($this->conn)) != 0);
	}
	/**
	 * Возвращает описание последней возникшей ошибки
	 * @return String
	 */
	public function errorDescription($sqlQuery = null) {
		$descr = mysql_error($this->conn);
		if($sqlQuery) $descr .= " in query: " . $sqlQuery;
		return $descr;
	}
	/**
	 * Возвращает признак открыто соединение или нет
	 * @return Boolean
	 */
	public function isOpen() {
		return $this->isOpen;
	}
	/**
	* Экранирует входящую строку
	* @param String $input строка для экранирования
	* @return экранированная строка
	*/
	public function escape($input) {
		if($this->isOpen) {
			return mysql_real_escape_string($input);
		} else {
			return addslashes($input);
		}
	}

	public function getConnectionInfo() {

		return array (
			'host' => $this->host,
			'user' => $this->username,
			'password' => $this->password,
			'dbname' => $this->dbname,
			'link' => $this->conn
		);
	}
};


/**
 * Класс, содержащий результат
 */
class mysqlQueryResult implements IQueryResult {	
	// Закрытые данные
	private $resource  = null;
	private $fetchType = IQueryResult::FETCH_ARRAY;
	/**
	 * Конструктор
	 * @param Resource $_mysqlResultResource Ресурс результата mysql запроса
	 * @param Int      $_fetchType			 Тип выборки (см. константы)
	 */
	public function __construct($_mysqlResultResource, $_fetchType = IQueryResult::FETCH_ARRAY) {
		$this->resource  = $_mysqlResultResource;
		$this->fetchType = $_fetchType;
	}
	/**
	 * Часть интерфейса IteratorAggregate, возвращает итератор для обхода результата
	 * return Iterator
	 */
	public function getIterator() {
		return new mysqlQueryResultIterator($this->resource, $this->fetchType);
	}
	/**
	 * Устанавливает тип выборки из результата (см. константы)
	 * @param Int $newType
	 */
	public function setFetchType($newType) {
		if($newType > 3) $this->fetchType = IQueryResult::FETCH_ARRAY;
		else $this->fetchType = $newType;
	}
	/**
	 * Возвращает тип выборки
	 * @return Int
	 */
	public function getFetchType() {
		return $this->fetchType;
	}
	/**
	 * Выбирает строку значений из результата
	 * и возвращает ее в соответствии с заданым типом выборки
	 */
	public function fetch() {
		$result = null;
		switch($this->fetchType) {
			case IQueryResult::FETCH_ARRAY  : $result = mysql_fetch_array($this->resource);  break;
			case IQueryResult::FETCH_ROW    : $result = mysql_fetch_row($this->resource);    break;
			case IQueryResult::FETCH_ASSOC  : $result = mysql_fetch_assoc($this->resource);  break;
			case IQueryResult::FETCH_OBJECT : $result = mysql_fetch_object($this->resource); break;
		}
		return $result;
	}
	/**
	* Возвращает количество выбранных строк
	* @return Int
	*/
	public function length() {
		return mysql_num_rows($this->resource);
	}
};
/**
 *
 */
class mysqlQueryResultIterator implements IQueryResultIterator {
	private $resource = null;
	private $number   = 0;
	private $rowcount = 0;
	private $fetchType = IQueryResult::FETCH_ARRAY;
	function __construct($_mysqlResultResource, $_fetchType = IQueryResult::FETCH_ARRAY) {
        $this->resource = $_mysqlResultResource;
        $this->fetchType = $_fetchType;
		$this->rowcount = $this->resource ? mysql_num_rows($this->resource) : 0;		
    }
    function rewind() {
		if($this->resource && (mysql_num_rows($this->resource) > 0)) {
			mysql_data_seek($this->resource, 0);
		}
		$this->number  = 0;
	}
    function valid() {
        return $this->number < $this->rowcount;
    }
    function key() {
        return $this->number;
    }
    function current() {
        switch($this->fetchType) {
			case IQueryResult::FETCH_ARRAY  : return mysql_fetch_array($this->resource);
			case IQueryResult::FETCH_ROW    : return mysql_fetch_row($this->resource);
			case IQueryResult::FETCH_ASSOC  : return mysql_fetch_assoc($this->resource);
			case IQueryResult::FETCH_OBJECT : return mysql_fetch_object($this->resource);
		}
    }
    function next() {
        $this->number++;
    }
};


	interface iDbSchemeConverter {

		/**
		* создает экземпляр класса dbSchemeConverter
		*
		* @param iConnection $connection - соединение с бд
		* @param mixed $path - путь к файлу, в котором будет хранится структура эталонной базы данных
		*/
		public function __construct (iConnection $connection, $path);

		/**
		* сохраняет структуру эталонной базы данных в файл
		*
		*/
		public function saveXmlToFile();

		/**
		* сравнивает эталонную базу данных с текущей базой данных и восттанавливает в случае необходимости
		*
		*/
		public function restoreDataBase();

		/**
		* возвращает запрос create table $tableName со всеми параметрами
		*
		* @param mixed $tableName - имя таблицы
		*/
		public function restoreShowCreateTable($tableName);

		/**
		* возвращает DomDocument со структурой базу данных. Использовать только, если доступна таблица INFORMATION_SCHEMA
		*
		*/
		public function getTablesInfo();
	}



class dbSchemeConverter {

	private $connection;
	private $dbname;
	private $dom;

	private $destinationFile = false;
	private $sourceFile = false;
	private $mode = false;
	private $completed = false;
	private $state = array();
	private $inParts = false;
	private $limit = 1000;

	private	$converterLog = array();

	public function __construct (iConnection $connection) {
		$this->connection = $connection;
		$connectionInfo = $connection->getConnectionInfo();
		$this->dbname = $connectionInfo['dbname'];
	}

	public function setDestinationFile($path) {
		$this->destinationFile = $path;
	}

	public function setSourceFile($path) {
		$this->sourceFile = $path;
	}

	public function setMode($mode = false, $inParts = false, $limit = 1000) {
		$this->mode = $mode;
		$this->inParts = $inParts;
		if ((int) $limit > 0) $this->limit = (int) $limit;
	}

	public function run() {
		$this->converterLog = array();
		switch ($this->mode) {
			case 'save': {
				if (!$this->destinationFile) throw new coreException("Please set destination file name");
				$this->saveXmlToFile();
				return true;
			}
			case 'restore': {
				$this->getState();
				$this->restoreDataBase();
				$this->saveState();
				return $this->completed;
			}
			default: {
				throw new coreException("Don't know what to do. Please set any appropriate mode.");
			}
		}
	}

	public function getConverterLog() {
		return $this->converterLog;
	}

	protected function writeLog($message) {
		if (defined('UMICMS_CLI_MODE') && UMICMS_CLI_MODE) echo $message . "\n\r";
		else $this->converterLog[] = $message;
	}

	protected function reportError($error) {
		if (defined('UMICMS_CLI_MODE') && UMICMS_CLI_MODE) echo $error . "\n\r";
		else $this->converterLog[] = $error;
	}

	protected function getState() {
		if (!$this->inParts) return;

		if (!$this->sourceFile || !$this->destinationFile) {
			throw new coreException("Please set destination and source file name");
		}

		if (file_exists(CURRENT_WORKING_DIR . "/sys-temp/updates/" . md5($this->destinationFile))) {
			$this->state = unserialize(file_get_contents(CURRENT_WORKING_DIR . "/sys-temp/updates/" . md5($this->destinationFile)));
		} else {
			$docNew = new DOMDocument();
			if (!$docNew->load($this->sourceFile)) {
				throw new coreException("Can't load xml: " . $this->sourceFile);
			}

			$this->state = array();
			$tablesNew = $docNew->getElementsByTagName('table');
			foreach ($tablesNew as $tableNew) {
				$this->state[$tableNew->getAttribute('name')] = array();
			}
		}
	}

	protected function saveState() {
		if (!$this->inParts) return;

		if ($this->completed && file_exists(CURRENT_WORKING_DIR . "/sys-temp/updates/" . md5($this->destinationFile))) {
			unlink(CURRENT_WORKING_DIR . "/sys-temp/updates/" . md5($this->destinationFile));
		} else {
			file_put_contents(CURRENT_WORKING_DIR . "/sys-temp/updates/" . md5($this->destinationFile), serialize($this->state));
		}
	}

	private function dumpToXml() {

		$dom = new DOMDocument('1.0', 'utf-8');
		$dom->formatOutput = XML_FORMAT_OUTPUT;

		$tablesElement = $dom->createElement('tables', '');
		$dom->appendChild($tablesElement);

		$tables = $this->connection->queryResult("SHOW TABLES");
		foreach ($tables as $table)	{
			$result = $this->connection->queryResult("SHOW CREATE TABLE `{$table[0]}`");
			foreach ($result as $row) {

				$tableElement = $dom->createElement('table', '');
				$tablesElement->appendChild($tableElement);

				$nameAttribute = $dom->createAttribute('name');
				$tableElement->appendChild($nameAttribute);
				$nameText = $dom->createTextNode("{$table[0]}");
				$nameAttribute->appendChild($nameText);

				preg_match("/DEFAULT\s+CHARSET=(.*)/is", $row[1], $charset); // находит charset
				if(isset($charset[1])){
					$charsetAttribute = $dom->createAttribute('charset');
					$tableElement->appendChild($charsetAttribute);
					$charsetText = $dom->createTextNode("{$charset[1]}");
					$charsetAttribute->appendChild($charsetText);
					$row[1] = preg_replace("/DEFAULT\s+CHARSET=.*/is", "", $row[1]); // обрезает charset
				}

				preg_match("/ENGINE=(.*)\s+/s", $row[1], $engine); // находит engine
				$engine[1] = preg_replace("/\s+(.*)/", "", $engine[1]);

				$engineAttribute = $dom->createAttribute('engine');
				$tableElement->appendChild($engineAttribute);
				$engineText = $dom->createTextNode("{$engine[1]}");
				$engineAttribute->appendChild($engineText);

				$row[1] = preg_replace("/\)\s+ENGINE=(.*)/is", "", $row[1]);
				$row[1] = preg_replace("/CREATE\s+TABLE\s+`(.*)`\s+\(/i", "", $row[1]); // оставляем только внутренности таблицы

				preg_match("/(CONSTRAINT\s.*)/is", $row[1], $constraints); // находит constraints

				if (isset($constraints[1]))	{

					$constraintsElement = $dom->createElement('constraints', '');
					$tableElement->appendChild($constraintsElement);

					$constraints = explode(',',$constraints[1]);
					foreach ($constraints as $constraint) {

						$constraintElement = $dom->createElement('constraint', '');
						$constraintsElement->appendChild($constraintElement);

						preg_match("/`([a-zA-Z0-9_\s+])+`/", $constraint, $matches);
						preg_match("/`(.*)`/", $matches[0], $name);
						preg_match("/FOREIGN\s+KEY\s+\(`([a-zA-Z0-9_])+`\)/i", $constraint, $matches);
						preg_match("/`(.*)`/", $matches[0], $foreignKey);
						preg_match("/REFERENCES\s+`(.*)`\s+\(/i", $constraint, $refTable);
						preg_match("/REFERENCES\s+`.*`\s+\(`(.*)`/i", $constraint, $refField);

						$nameAttribute = $dom->createAttribute('name');
						$constraintElement->appendChild($nameAttribute);
						$nameText = $dom->createTextNode("{$name[1]}");
						$nameAttribute->appendChild($nameText);

						$fieldAttribute = $dom->createAttribute('field');
						$constraintElement->appendChild($fieldAttribute);
						$fieldText = $dom->createTextNode("{$foreignKey[1]}");
						$fieldAttribute->appendChild($fieldText);

						$refTableAttribute = $dom->createAttribute('ref-table');
						$constraintElement->appendChild($refTableAttribute);
						$refTableText = $dom->createTextNode("{$refTable[1]}");
						$refTableAttribute->appendChild($refTableText);

						$refFieldAttribute = $dom->createAttribute('ref-field');
						$constraintElement->appendChild($refFieldAttribute);
						$refFieldText = $dom->createTextNode("{$refField[1]}");
						$refFieldAttribute->appendChild($refFieldText);

						preg_match("/ON\s+DELETE\s+(CASCADE|SET\s+NULL)/i", $constraint, $onDelete);
						if (isset($onDelete[1])) {
							$deleteAttribute = $dom->createAttribute('on-delete');
							$constraintElement->appendChild($deleteAttribute);
							$deleteText = $dom->createTextNode("{$onDelete[1]}");
							$deleteAttribute->appendChild($deleteText);
						}

						preg_match("/ON\s+UPDATE\s+(CASCADE|SET\s+NULL)/i", $constraint, $onUpdate);
						if (isset($onUpdate[1])) {
							$updateAttribute = $dom->createAttribute('on-update');
							$constraintElement->appendChild($updateAttribute);
							$updateText = $dom->createTextNode("{$onUpdate[1]}");
							$updateAttribute->appendChild($updateText);
						}
					}
					$row[1] = preg_replace("/(CONSTRAINT\s.*)/is", '', $row[1]); // отсекает constraints
				}

				preg_match("/PRIMARY\s+KEY\s+\(`(.*)`\)/i", $row[1], $primaryKey); // находит primary key
				if (isset($primaryKey[1])) {
					$row[1] = preg_replace("/PRIMARY\s+KEY\s+\(`.*`\)/i", '', $row[1]); // отсекает primary key
				}

				preg_match("/UNIQUE\s+KEY\s+(.*)\)/i", $row[1], $uniqueKey); // находит unique key
				if (isset($uniqueKey[1])) {
					$row[1] = preg_replace("/UNIQUE\s+KEY\s+.*\)/i", '', $row[1]); // отсекает unique key
				}

				preg_match("/(KEY\s.*)/is", $row[1], $keys); // находит key

				if(isset($primaryKey[1]) || isset($keys[1]) || isset($uniqueKey[1])) {
					$indexesElement = $dom->createElement('indexes', '');
					$tableElement->appendChild($indexesElement);
				}

				if (isset($primaryKey[1])) {

					$indexElement = $dom->createElement('index', '');
					$indexesElement->appendChild($indexElement);

					$typeAttribute = $dom->createAttribute('type');
					$indexElement->appendChild($typeAttribute);
					$typeText = $dom->createTextNode("PRIMARY");
					$typeAttribute->appendChild($typeText);

					$fieldElement = $dom->createElement('field', "{$primaryKey[1]}");
					$indexElement->appendChild($fieldElement);

				}

				if (isset($uniqueKey[1])) {

					$indexElement = $dom->createElement('index', '');
					$indexesElement->appendChild($indexElement);

					$typeAttribute = $dom->createAttribute('type');
					$indexElement->appendChild($typeAttribute);
					$typeText = $dom->createTextNode("UNIQUE");
					$typeAttribute->appendChild($typeText);

					preg_match("/`(.*)`\s+\(/", $uniqueKey[1], $name);

					$nameAttribute = $dom->createAttribute('name');
					$indexElement->appendChild($nameAttribute);
					$nameText = $dom->createTextNode("{$name[1]}");
					$nameAttribute->appendChild($nameText);

					preg_match("/\((.*)/", $uniqueKey[1], $matches);
					$fields = explode(',', $matches[1]);
					foreach ($fields as $field) {
						preg_match("/\((\d+)\)/", $field, $length);
						preg_match("/`(.*)`/", $field, $fieldName);
						$fieldElement = $dom->createElement('field', "{$fieldName[1]}");
						$indexElement->appendChild($fieldElement);
						if(isset($length[1])) {
							$lengthAttribute = $dom->createAttribute('length');
							$fieldElement->appendChild($lengthAttribute);
							$lengthText = $dom->createTextNode("{$length[1]}");
							$lengthAttribute->appendChild($lengthText);
						}
					}
				}

				if (isset($keys[1])) {

					$keys[1] = preg_replace("/`\),/", "` ),", $keys[1]);
					$keys[1] = preg_replace("/\)\),/", ") ),", $keys[1]);
					$keys = preg_split("/\s+\),/",$keys[1]);
					foreach ($keys as $key) {
						$key = trim($key);
						if (strlen($key)) {
							preg_match("/`(.*)`\s+\(/", $key, $name);

							$indexElement = $dom->createElement('index', '');
							$indexesElement->appendChild($indexElement);

							$nameAttribute = $dom->createAttribute('name');
							$indexElement->appendChild($nameAttribute);
							$nameText = $dom->createTextNode("{$name[1]}");
							$nameAttribute->appendChild($nameText);

							preg_match("/\((.*)/", $key, $matches);
							$fields = explode(',', $matches[1]);
							foreach ($fields as $field) {
								preg_match("/\((\d+)\)/", $field, $length);
								preg_match("/`(.*)`/", $field, $fieldName);
								$fieldElement = $dom->createElement('field', "{$fieldName[1]}");
								$indexElement->appendChild($fieldElement);

								if(isset($length[1])) {
									$lengthAttribute = $dom->createAttribute('length');
									$fieldElement->appendChild($lengthAttribute);
									$lengthText = $dom->createTextNode("{$length[1]}");
									$lengthAttribute->appendChild($lengthText);
								}
							}
						}
					}
					$row[1] = preg_replace("/(KEY\s.*)/is", '', $row[1]); // отсекает key
				}


				$tableFields = preg_split('/\n/',$row[1]);

				$fieldsElement = $dom->createElement('fields', '');
				$tableElement->appendChild($fieldsElement);

				foreach ($tableFields as $field) {
					$field = preg_replace("/,$/s", "", $field);
					$field = trim($field);
					if (strlen($field)>1) {
						$fieldElement = $dom->createElement('field');
						$fieldsElement->appendChild($fieldElement);

						preg_match("/COMMENT\s+'(.*)'/i", $field, $comment);
						if (isset($comment[1])) {
							$commentAttribute = $dom->createAttribute('comment');
							$fieldElement->appendChild($commentAttribute);
							$commentText = $dom->createTextNode("{$comment[1]}");
							$commentAttribute->appendChild($commentText);
							$field = preg_replace("/COMMENT\s+'.*'/i", "", $field);
						}

						preg_match("/\s+(BINARY|UNSIGNED\s+ZEROFILL|UNSIGNED|on\s+update\s+CURRENT_TIMESTAMP)/i", $field, $attribute);
						if(isset($attribute[1])) {
							$attributeAttribute = $dom->createAttribute('attributes');
							$fieldElement->appendChild($attributeAttribute);
							$attributeText = $dom->createTextNode("{$attribute[1]}");
							$attributeAttribute->appendChild($attributeText);
							$field = preg_replace("/\s+BINARY|\s+UNSIGNED\s+ZEROFILL|\s+UNSIGNED|\s+on\s+update\s+CURRENT_TIMESTAMP/i", "", $field);
						}

						preg_match("/\s+(NOT\s+NULL)/i", $field, $notNull);
						if(isset($notNull[1])) {
							$nullAttribute = $dom->createAttribute('not-null');
							$fieldElement->appendChild($nullAttribute);
							$nullText = $dom->createTextNode("1");
							$nullAttribute->appendChild($nullText);
							$field = preg_replace("/\s+NOT\s+NULL/i", "", $field);
						}

						preg_match("/\s+(AUTO_INCREMENT)/i", $field, $increment);
						if(isset($increment[1])) {
							$incAttribute = $dom->createAttribute('increment');
							$fieldElement->appendChild($incAttribute);
							$incText = $dom->createTextNode("1");
							$incAttribute->appendChild($incText);
							$field = preg_replace("/\s+AUTO_INCREMENT/i", "", $field);
						}

						preg_match("/\s+DEFAULT\s+(.*)/i", $field, $default);
						if(isset($default[1])) {
							preg_match("/'(.*)'/", $default[1], $match);
							if (isset($match[1])) $default[1] = $match[1];
							$defaultAttribute = $dom->createAttribute('default');
							$fieldElement->appendChild($defaultAttribute);
							$defaultText = $dom->createTextNode("{$default[1]}");
							$defaultAttribute->appendChild($defaultText);
							$field = preg_replace("/\s+DEFAULT\s+.*/i", "", $field);
						}

						preg_match("/`(.*)`/", $field, $name);
						if (isset($name[1])) {
							$nameAttribute = $dom->createAttribute('name');
							$fieldElement->appendChild($nameAttribute);
							$nameText = $dom->createTextNode("{$name[1]}");
							$nameAttribute->appendChild($nameText);
							$field = preg_replace("/`.*`/", "", $field);
						}

						preg_match("/\((\d+|\d+,\d+)\)/", $field, $size);
						if (isset($size[1])) {
							$sizeAttribute = $dom->createAttribute('size');
								$fieldElement->appendChild($sizeAttribute);
								$sizeText = $dom->createTextNode("{$size[1]}");
								$sizeAttribute->appendChild($sizeText);
								$field = preg_replace("/\({$size[1]}\)/", "", $field);
						}

						preg_match("/\((.*)\)/", $field, $size);
						if (isset($size[1])) {

							$options = preg_replace("/'/", '', $size[1]);
							$options = explode(',', $options);
							foreach ($options as $option) {
								$optionElement = $dom->createElement('option', $option);
								$fieldElement->appendChild($optionElement);
							}
							$field = preg_replace("/\((.*)\)/", "", $field);
						}

						$field = preg_replace("/,/", "", $field);
						$field = trim($field);

						if ($field) {
							$typeAttribute = $dom->createAttribute('type');
							$fieldElement->appendChild($typeAttribute);
							$typeText = $dom->createTextNode("{$field}");
							$typeAttribute->appendChild($typeText);
						}
					}
				}
			}
		}
		return $dom->saveXML($dom->documentElement, DOM_LOAD_OPTIONS);
	}

	public function saveXmlToFile() {

		if (!file_put_contents($this->destinationFile, $this->dumpToXml())) {
			throw new coreException("Cannot create new xml file " . $this->destinationFile);
		}
	}

	public function restoreShowCreateTable($tableName) {

		$doc = new DOMDocument();

		if (!$doc->load($this->sourceFile)) {
			throw new coreException("Can't load xml: " . $this->sourceFile);
		}

		$xpath = new DOMXPath($doc);
		$table = $xpath->query("//table[@name='{$tableName}']")->item(0);

		$createTable = "CREATE TABLE `{$tableName}` (\n";
		$fieldsRoot = $table->getElementsByTagName('fields');
		if(is_object($fieldsRoot->item(0))) {
			$fields = $fieldsRoot->item(0)->getElementsByTagName('field');
			foreach ($fields as $field) {
				$createTable .="\t";
				if($fieldName = $field->getAttribute('name')) $createTable .= "`{$fieldName}`";
				if($fieldType = $field->getAttribute('type')) $createTable .=" {$fieldType}";
				if ($fieldSize = $field->getAttribute('size')) $createTable .="({$fieldSize})";
				if($field->getElementsByTagName('option')->length) {
					$options = $field->getElementsByTagName('option');
					$optionsValue = '';
					$i = 1;
					foreach ($options as $option) {
						if($i == $options->length) $optionsValue .= "'{$option->nodeValue}'";
						else $optionsValue .= "'{$option->nodeValue}',";
						$i++;
					}
					$createTable .="({$optionsValue})";
				}
				if ($fieldAttributes = $field->getAttribute('attributes')) $createTable .=" {$fieldAttributes}";
				if ($fieldNull = $field->getAttribute('not-null')) $createTable .=" NOT NULL";
				if($field->hasAttribute('default')){
					$fieldDefault=$field->getAttribute('default');
					if($fieldDefault !='NULL') $fieldDefault = "'{$fieldDefault}'";
					$createTable .=" DEFAULT {$fieldDefault}";
				}
				if ($fieldIncrement = $field->getAttribute('increment')) $createTable .=" AUTO_INCREMENT";
				if ($fieldComment = $field->getAttribute('comment')) $createTable .=" COMMENT '{$fieldComment}'";
				$createTable .= ",\n";
			}
		}

		$indexesRoot = $table->getElementsByTagName('indexes');
		if(is_object($indexesRoot->item(0))) {
			$indexes = $indexesRoot->item(0)->getElementsByTagName('index');
			foreach ($indexes as $index) {
				$createTable .="\t";
				if($indexType = $index->getAttribute('type')) $createTable .= "{$indexType} ";
				$createTable .= "KEY";
				if($indexName = $index->getAttribute('name')) $createTable .= " `{$indexName}`";
				if($index->getElementsByTagName('field')->length) {
					$fields = $index->getElementsByTagName('field');
					$fieldsValue = '';
					$i = 1;
					foreach ($fields as $field) {
						$fieldValue = "`{$field->nodeValue}`";
						if($fieldLength = $field->getAttribute('length')) $fieldValue .= "({$fieldLength})";
						if($i == $fields->length) $fieldsValue .= $fieldValue;
						else $fieldsValue .= "{$fieldValue},";
						$i++;
					}
					$createTable .=" ({$fieldsValue})";
				}
				$createTable .= ",\n";
			}
		}

		$constraintsRoot = $table->getElementsByTagName('constraints');
		if(is_object($constraintsRoot->item(0))) {
			$constraints = $constraintsRoot->item(0)->getElementsByTagName('constraint');
			foreach ($constraints as $constraint) {
				$createTable .= "\tCONSTRAINT";
				if($constraintName = $constraint->getAttribute('name')) $createTable .= " `{$constraintName}`";
				if ($constraintField = $constraint->getAttribute('field')) $createTable .= " FOREIGN KEY (`{$constraintField}`)";
				if ($constraintRefTable = $constraint->getAttribute('ref-table')) $createTable .= " REFERENCES `{$constraintRefTable}`";
				if($constraintRefField = $constraint->getAttribute('ref-field')) $createTable .= " (`{$constraintRefField}`)";
				if($constraintOnDelete = $constraint->getAttribute('on-delete')) $createTable .= " ON DELETE {$constraintOnDelete}";
				if($constraintOnUpdate = $constraint->getAttribute('on-update')) $createTable .= " ON UPDATE {$constraintOnUpdate}";
				$createTable .= ",\n";
			}
		}
		$createTable = preg_replace("/,$/s", "", $createTable);
		if($tableEngine = $table->getAttribute('engine')) $createTable .= ") ENGINE={$tableEngine}";
		if($tableCharset = $table->getAttribute('charset')) $createTable .= " DEFAULT CHARSET={$tableCharset}";
		$createTable .= "\n";
		return $createTable;
	}

	private function createDataBaseTable($tableName) {
		$createTable = $this->restoreShowCreateTable($tableName);
		$success = true;
		try {
			$this->connection->queryResult($createTable);
		} catch (Exception $e) {
			$this->reportError($e->getMessage());
			$success = false;
		}

		if ($success) $this->writeLog("Data base table {$tableName} has been created");
	}

	private function changeTableEngine($tableName, $tableEngine){

		$success = true;
		try {
			$this->connection->queryResult("ALTER TABLE `{$tableName}` ENGINE={$tableEngine}");
		} catch (Exception $e) {
			$this->reportError($e->getMessage());
			$success = false;
		}

		if ($success) $this->writeLog("Data base table ({$tableName}) engine has been changed");

	}

	private function changeTableCharset($tableName, $tableCharset){

		$success = true;
		try {
			$this->connection->queryResult("ALTER TABLE `{$tableName}` DEFAULT CHARACTER SET {$tableCharset}");
		} catch (Exception $e) {
			$this->reportError($e->getMessage());
			$success = false;
		}

		if ($success) $this->writeLog("Data base table ({$tableName}) character set has been changed");

		$doc = new DOMDocument();
		if (!$doc->load($this->sourceFile)) {
			throw new coreException("Can't load xml: " . $this->sourceFile);
		}
		$xpath = new DOMXPath($doc);

		$table = $xpath->query("//table[@name='{$tableName}']")->item(0);
		$fieldsRoot = $table->getElementsByTagName('fields');
		if(is_object($fieldsRoot->item(0))) {
			$fields = $fieldsRoot->item(0)->getElementsByTagName('field');
			foreach ($fields as $field) {
				if($fieldName = $field->getAttribute('name')) $this->createTableField($tableName, $fieldName, 'modify');
			}
		}
	}

	private function createTableField($tableName, $fieldName, $param) {

		$doc = new DOMDocument();
		if (!$doc->load($this->sourceFile)) {
			throw new coreException("Can't load xml: " . $this->sourceFile);
		}

		$xpath = new DOMXPath($doc);
		if (!$field = $xpath->query("//table[@name='{$tableName}']/fields/field[@name='{$fieldName}']")->item(0)) {
			throw new coreException("Cannot change {$tableName}.{$fieldName}");
		}

		if ($param =='add') $createField = "ALTER TABLE `{$tableName}` ADD ";
		else $createField = "ALTER TABLE `{$tableName}` MODIFY ";

		$createField .= "`{$fieldName}`";
		if ($fieldType = $field->getAttribute('type')) $createField .=" {$fieldType}";
		if ($fieldSize = $field->getAttribute('size')) $createField .="({$fieldSize})";
		if ($field->getElementsByTagName('option')->length) {
			$options = $field->getElementsByTagName('option');
			$optionsValue = '';
			$i = 1;
			foreach ($options as $option) {
				if($i == $options->length) $optionsValue .= "'{$option->nodeValue}'";
				else $optionsValue .= "'{$option->nodeValue}',";
				$i++;
			}
			$createField .="({$optionsValue})";
		}
		if ($fieldAttributes = $field->getAttribute('attributes')) $createField .=" {$fieldAttributes}";
		if ($fieldNull = $field->getAttribute('not-null')) $createField .=" NOT NULL";
		if ($field->hasAttribute('default')){
			$fieldDefault=$field->getAttribute('default');
			if ($fieldDefault !='NULL') $fieldDefault = "'{$fieldDefault}'";
			$createField .=" DEFAULT {$fieldDefault}";
		}
		if ($fieldIncrement = $field->getAttribute('increment')) $createField .=" AUTO_INCREMENT";
		if ($fieldComment = $field->getAttribute('comment')) $createField .=" COMMENT '{$fieldComment}'";



		$success = true;
		try {
			$this->connection->queryResult($createField);
		} catch (Exception $e) {
			$this->reportError($e->getMessage());
			$success = false;
		}

		if ($success) {
			if ($param == 'add') $this->writeLog("Data base table ({$tableName}) field ({$fieldName}) has been created");
			else $this->writeLog("Data base table ({$tableName}) field ({$fieldName}) has been changed");
		}
	}

	private function createTableIndex($tableName, $indexName, $param) {

		$doc = new DOMDocument();
		if (!$doc->load($this->sourceFile)) {
			throw new coreException("Can't load xml: " . $this->sourceFile);
		}
		$xpath = new DOMXPath($doc);

		if(!$index = $xpath->query("//table[@name='{$tableName}']/indexes/index[@name='{$indexName}']")->item(0)) throw new coreException("Cannot change index {$indexName} in table {$tableName}");

		$createIndex = "ALTER TABLE `{$tableName}` ADD ";
		if ($indexType = $index->getAttribute('type')) {
			if ($indexType == "UNIQUE") $createIndex .= "UNIQUE";
		}

		else $createIndex .="INDEX";
		if ($indexName) $createIndex .=" `{$indexName}`";
		if ($index->getElementsByTagName('field')->length) {
			$fields = $index->getElementsByTagName('field');
			$fieldsValue = '';
			$i = 1;
			foreach ($fields as $field) {
				$fieldValue = "`{$field->nodeValue}`";
				if($fieldLength = $field->getAttribute('length')) $fieldValue .="({$fieldLength})";
				if($i == $fields->length) $fieldsValue .= $fieldValue;
				else $fieldsValue .= "{$fieldValue},";
				$i++;
			}
			$createIndex .=" ({$fieldsValue})";
		}
		if ($param =='modify') {
			if ($index->getElementsByTagName('field')->length) {
				$fields = $index->getElementsByTagName('field');
				foreach ($fields as $field) {
					$fieldValue = $field->nodeValue;
					if($constraint = $xpath->query("//table[@name='{$tableName}']/constraints/constraint[@field='{$fieldValue}']")->item(0)) {
						if($constraintName = $constraint->getAttribute('name')) $this->connection->queryResult("ALTER TABLE `{$tableName}` DROP FOREIGN KEY `{$constraintName}`");
					}
				}
			}
			$this->connection->queryResult("ALTER TABLE `{$tableName}` DROP INDEX `{$indexName}`");
			$success = true;
			try {
				$this->connection->queryResult($createIndex);
			} catch (Exception $e) {
				$this->reportError($e->getMessage());
				$success = false;
			}

			if ($success) $this->writeLog("Data base table ({$tableName}) index ({$indexName}) has been changed");
			if ($index->getElementsByTagName('field')->length) {
				$fields = $index->getElementsByTagName('field');
				foreach ($fields as $field) {
					$fieldValue = $field->nodeValue;
					if($constraint = $xpath->query("//table[@name='{$tableName}']/constraints/constraint[@field='{$fieldValue}']")->item(0)) {
						if($constraintName = $constraint->getAttribute('name')) $this->createTableConstraint($tableName, $constraintName, 'add');
					}
				}
			}
		} else {
			$success = true;
			try {
				$this->connection->queryResult($createIndex);
			} catch (Exception $e) {
				$this->reportError($e->getMessage());
				$success = false;
			}

			if ($success) $this->writeLog("Data base table ({$tableName}) index ({$indexName}) has been created");
		}
	}

	private function createTableConstraint($tableName, $constraintName, $param) {

		$doc = new DOMDocument();
		if (!$doc->load($this->sourceFile)) {
			throw new coreException("Can't load xml: " . $this->sourceFile);
		}

		$xpath = new DOMXPath($doc);
		if (!$constraint = $xpath->query("//table[@name='{$tableName}']/constraints/constraint[@name='{$constraintName}']")->item(0)) throw new coreException("Cannot change constraint {$constraintName} in table {$tableName}");

		if ($param =='modify') $this->connection->queryResult("ALTER TABLE `{$tableName}` DROP FOREIGN KEY `{$constraintName}`");

		$createConstraint = "ALTER TABLE `{$tableName}` ADD CONSTRAINT";

		$createConstraint .=" `{$constraintName}`";
		if ($constraintField = $constraint->getAttribute('field')) $createConstraint .=" FOREIGN KEY (`{$constraintField}`)";
		if ($constraintRefTable = $constraint->getAttribute('ref-table')) $createConstraint .=" REFERENCES `{$constraintRefTable}`";
		if($constraintRefField = $constraint->getAttribute('ref-field')) $createConstraint .=" (`{$constraintRefField}`)";
		if($constraintOnDelete = $constraint->getAttribute('on-delete')) $createConstraint .=" ON DELETE {$constraintOnDelete}";
		if($constraintOnUpdate = $constraint->getAttribute('on-update')) $createConstraint .=" ON UPDATE {$constraintOnUpdate}";

		$success = true;
		try {
			$this->connection->queryResult($createConstraint);
		} catch (Exception $e) {
			$this->reportError($e->getMessage());
			$success = false;
		}

		if ($success) {
			if ($param == 'add') $this->writeLog("Data base table ({$tableName}) constraint ({$constraintName}) has been created");
			else $this->writeLog("Data base table ({$tableName}) constraint ({$constraintName}) has been changed");
		}

		if($constraintOnDelete) {
			if ($constraintOnDelete == "SET NULL") {
				$sql = <<<END
					UPDATE `{$tableName}`
					SET {$constraintField} = null
					WHERE {$constraintField} NOT IN (
						SELECT {$constraintRefField}
						FROM {$constraintRefTable}
					)
END;
			}
			if ($constraintOnDelete == "CASCADE") {
				$sql = <<<END
					DELETE FROM `{$tableName}`
					WHERE {$constraintField} NOT IN (
						SELECT {$constraintRefField}
						FROM {$constraintRefTable}
					)
END;
			}
			$this->connection->queryResult($sql);
		}
	}

	public function restoreDataBase() {

		//структура, которая должна быть
		$docNew = new DOMDocument();
		if (!$docNew->load($this->sourceFile)) {
			throw new coreException("Can't load xml: " . $this->sourceFile);
		}

		//имеющаяся структура
		$docOld = new DOMDocument();
		if (!$docOld->load($this->destinationFile)) {
			throw new coreException("Can't load xml: " . $this->destinationFile);
		}

		$xpath = new DOMXPath($docOld);

		$tablesNew = $docNew->getElementsByTagName('table');
		foreach ($tablesNew as $table) {

			$tableName = $table->getAttribute('name');
			if ($this->inParts && isset($this->state[$tableName]['complete']) && $this->state[$tableName]['complete'] == true) continue;

			$this->connection->queryResult("SET foreign_key_checks = 0");
			$this->writeLog("Start checking table {$tableName}");

			if (!$xpath->query("//table[@name='{$tableName}']")->length) $this->createDataBaseTable($tableName);
			else {

				$countResult = l_mysql_query("SELECT count(*) FROM `{$tableName}`");
				list($countRows) = mysql_fetch_row($countResult);

				if ($countRows > 10000) {

					$tableRestored = $this->checkTableRestore($tableName);

					if($this->inParts) {
						end($this->state);
						$this->completed = ((key($this->state) == $tableName) && $tableRestored);
						return $this->completed;
					}

					continue;
				}

				$tableEngine = $table->getAttribute('engine');
				if(!$xpath->query("//table[@name='{$tableName}' and @engine='{$tableEngine}']")->item(0)) $this->changeTableEngine($tableName, $tableEngine);

				$tableCharset = $table->getAttribute('charset');
				if(!$xpath->query("//table[@name='{$tableName}' and @charset='{$tableCharset}']")->item(0)) $this->changeTableCharset($tableName, $tableCharset);

				$fieldsRoot = $table->getElementsByTagName('fields');
				if (is_object($fieldsRoot->item(0))) {
					$fields = $fieldsRoot->item(0)->getElementsByTagName('field');

					$indexesRoot = $table->getElementsByTagName('indexes');
					if(is_object($indexesRoot->item(0))) {
						$indexes = $indexesRoot->item(0)->getElementsByTagName('index');
						foreach ($indexes as $index){
							if($index->getAttribute('type') == 'PRIMARY') {
								if($fieldNameNew = $index->getElementsByTagName('field')->item(0)->nodeValue) {
									if ($xpath->query("//table[@name='{$tableName}']/indexes/index[@type='PRIMARY']/field")->item(0)) {
										$fieldNameOld = $xpath->query("//table[@name='{$tableName}']/indexes/index[@type='PRIMARY']/field")->item(0)->nodeValue;
										if ($fieldNameNew != $fieldNameOld) {
											if($fieldOld = $xpath->query("//table[@name='{$tableName}']/fields/field[@name = '{$fieldNameOld}' and @increment='1']")->item(0)) $this->createTableField($tableName, $fieldNameOld, 'modify');
											if($constraints = $xpath->query("//table/constraints/constraint[@ref-table='{$tableName}' and @ref-field='{$fieldNameOld}']")) {
											foreach($constraints as $constraint) {
												$constraintName = $constraint->getAttribute('name');
												$tableNameC = $constraint->parentNode->parentNode->getAttribute('name');
												$this->connection->queryResult("ALTER TABLE `{$tableNameC}` DROP FOREIGN KEY `{$constraintName}`");
												}
											}
											$this->connection->queryResult("ALTER TABLE `{$tableName}` DROP PRIMARY KEY");
											$this->connection->queryResult("ALTER TABLE `{$tableName}` ADD PRIMARY KEY ({$fieldNameNew})");
										}
									}
									else $this->connection->queryResult("ALTER TABLE `{$tableName}` ADD PRIMARY KEY ({$fieldNameNew})");
								}
							}
						}
					}

					foreach ($fields as $field) {
						if ($fieldName = $field->getAttribute('name')) {
							if (!$xpath->query("//table[@name='{$tableName}']/fields/field[@name='{$fieldName}']")->length) $this->createTableField($tableName, $fieldName, 'add');
							else {
								if ($fieldType = $field->getAttribute('type')) {
									if (!$xpath->query("//table[@name='{$tableName}']/fields/field[@name='{$fieldName}' and @type='{$fieldType}']")->length) $this->createTableField($tableName, $fieldName, 'modify');
								}
								if ($fieldSize = $field->getAttribute('size')) {
									if (!$xpath->query("//table[@name='{$tableName}']/fields/field[@name='{$fieldName}' and @size='{$fieldSize}']")->length) $this->createTableField($tableName, $fieldName, 'modify');
								}
								if ($field->getElementsByTagName('option')->length) {
									$options = $field->getElementsByTagName('option');
									foreach ($options as $option) {
										if (!$xpath->query("//table[@name='{$tableName}']/fields/field[@name='{$fieldName}'][option ='{$option->nodeValue}']")->length) $this->createTableField($tableName, $fieldName, 'modify');
									}
								}
								if ($fieldAttributes = $field->getAttribute('attributes')) {
									if (!$xpath->query("//table[@name='{$tableName}']/fields/field[@name='{$fieldName}' and @attributes='{$fieldAttributes}']")->length) $this->createTableField($tableName, $fieldName, 'modify');
								}
								if ($fieldNull = $field->getAttribute('not-null')) {
									if (!$xpath->query("//table[@name='{$tableName}']/fields/field[@name='{$fieldName}' and @not-null='{$fieldNull}']")->length) $this->createTableField($tableName, $fieldName, 'modify');
								}
								if ($field->hasAttribute('default')){
									$fieldDefault=$field->getAttribute('default');
									if (!$xpath->query("//table[@name='{$tableName}']/fields/field[@name='{$fieldName}' and @default='{$fieldDefault}']")->length) $this->createTableField($tableName, $fieldName, 'modify');
								}
								if ($fieldIncrement = $field->getAttribute('increment')) {
									if (!$xpath->query("//table[@name='{$tableName}']/fields/field[@name='{$fieldName}' and @increment='{$fieldIncrement}']")->length) $this->createTableField($tableName, $fieldName, 'modify');
								}
								if ($fieldComment = $field->getAttribute('comment')) {
									if (!$xpath->query("//table[@name='{$tableName}']/fields/field[@name='{$fieldName}' and @comment='{$fieldComment}']")->length) $this->createTableField($tableName, $fieldName, 'modify');
								}
							}
						}
					}
				}
				$indexesRoot = $table->getElementsByTagName('indexes');
				if(is_object($indexesRoot->item(0))) {
					$indexes = $indexesRoot->item(0)->getElementsByTagName('index');
					foreach ($indexes as $index) {
						if($indexName = $index->getAttribute('name')) {
							if (!$xpath->query("//table[@name='{$tableName}']/indexes/index[@name='{$indexName}']")->length) $this->createTableIndex($tableName, $indexName, 'add');
							else {
								if($indexType = $index->getAttribute('type')) {
									if (!$xpath->query("//table[@name='{$tableName}']/indexes/index[@name='{$indexName}' and @type='{$indexType}']")->length) $this->createTableIndex($tableName, $indexName, 'modify');
								}
								if($index->getElementsByTagName('field')->length) {
									$fields = $index->getElementsByTagName('field');
									foreach ($fields as $field) {
										if (!$xpath->query("//table[@name='{$tableName}']/indexes/index[@name='{$indexName}'][field = '{$field->nodeValue}']")->length) $this->createTableIndex($tableName, $indexName, 'modify');
										else {
											if($fieldLength = $field->getAttribute('length')) {
												if (!$xpath->query("//table[@name='{$tableName}']/indexes/index[@name='{$indexName}'][field[@length='{$fieldLength}'] ='{$field->nodeValue}']")->length) $this->createTableIndex($tableName, $indexName, 'modify');
											}
										}
									}
								}
							}
						}
					}
				}

				$constraintsRoot = $table->getElementsByTagName('constraints');
				if(is_object($constraintsRoot->item(0))) {
					$constraints = $constraintsRoot->item(0)->getElementsByTagName('constraint');
					foreach ($constraints as $constraint) {
						if ($constraintName = $constraint->getAttribute('name')) {
							if (!$xpath->query("//table[@name='{$tableName}']/constraints/constraint[@name='{$constraintName}']")->item(0)) $this->createTableConstraint($tableName, $constraintName, 'add');
							else {
								if ($constraintField = $constraint->getAttribute('field')) {
									if (!$xpath->query("//table[@name='{$tableName}']/constraints/constraint[@name='{$constraintName}' and @field='{$constraintField}']")->item(0)) $this->createTableConstraint($tableName, $constraintName, 'modify');
								}
								if ($constraintRefTable = $constraint->getAttribute('ref-table')) {
									if (!$xpath->query("//table[@name='{$tableName}']/constraints/constraint[@name='{$constraintName}' and @ref-table='{$constraintRefTable}']")->item(0)) $this->createTableConstraint($tableName, $constraintName, 'modify');
								}
								if ($constraintRefField = $constraint->getAttribute('ref-field')) {
									if (!$xpath->query("//table[@name='{$tableName}']/constraints/constraint[@name='{$constraintName}' and @ref-field='{$constraintRefField}']")->item(0)) $this->createTableConstraint($tableName, $constraintName, 'modify');
								}
								if ($constraintOnDelete = $constraint->getAttribute('on-delete')) {
									if (!$xpath->query("//table[@name='{$tableName}']/constraints/constraint[@name='{$constraintName}' and @on-delete='{$constraintOnDelete}']")->item(0)) $this->createTableConstraint($tableName, $constraintName, 'modify');
								}
								if ($constraintOnUpdate = $constraint->getAttribute('on-update')) {
									if (!$xpath->query("//table[@name='{$tableName}']/constraints/constraint[@name='{$constraintName}' and @on-update='{$constraintOnUpdate}']")->item(0)) $this->createTableConstraint($tableName, $constraintName, 'modify');
								}
							}
						}
					}
				}
			}

			$this->connection->queryResult("SET foreign_key_checks = 1");

			if($this->inParts) {
				$this->state[$tableName]['complete'] = true;
				end($this->state);
				$this->completed = (key($this->state) == $tableName);
				return $this->completed;
			}
		}

	}

	protected function prepareTable($tableName) {

		if ($this->inParts) {
			if (isset($this->state[$tableName]['info'])) {
				return $this->state[$tableName]['info'];
			}
		}

		$doc = new DOMDocument();
		$doc->load($this->sourceFile);

		$xpath = new DOMXPath($doc);

		$createSql = $this->restoreShowCreateTable($tableName);
		$tableNameNew = $tableName . '_temp';

		while(true) {
			$success = false;
			try {
				$this->connection->queryResult("SHOW CREATE TABLE `{$tableNameNew}`");
			} catch (Exception $e) {
				$success = true;
			}

			if (!$success) {
				$result = $this->connection->queryResult("SHOW CREATE TABLE `{$tableNameNew}`");
				foreach ($result as $row) {
					$newSql = str_replace($tableNameNew, $tableName, $row[1]);
					$newSql = preg_replace("/\s/", '', $newSql);
					$oldSql = preg_replace("/\s/", "", $createSql);
					if (stripos($oldSql, $newSql) !== false) {
						l_mysql_query("DROP TABLE `{$tableNameNew}`");
						$success = true;
					}
				}
			}

			if ($success) {
				break;
			} else {
				$tableNameNew .= '1';
			}
		}

		if ($xpath->query("//table[@name='{$tableName}']/constraints/constraint")->length) {
			$constraints = $xpath->query("//table[@name='{$tableName}']/constraints/constraint");

			foreach ($constraints as $constraint){
				$constraintName = $constraint->getAttribute('name');

				try {
					l_mysql_query("ALTER TABLE `{$tableName}` DROP FOREIGN KEY `{$constraintName}`");
				} catch (Exception $e){

				}

				$constraintOnDelete = $constraint->getAttribute('on-delete');

				if($constraintOnDelete) {

					$constraintField = $constraint->getAttribute('field');
					$constraintRefTable = $constraint->getAttribute('ref-table');
					$constraintRefField = $constraint->getAttribute('ref-field');

					if ($constraintOnDelete == "SET NULL") {
						$sql = <<<END
							UPDATE `{$tableName}`
							SET {$constraintField} = null
							WHERE {$constraintField} NOT IN (
								SELECT {$constraintRefField}
								FROM {$constraintRefTable}
							)
END;
					}
					if ($constraintOnDelete == "CASCADE") {
						$sql = <<<END
							DELETE FROM `{$tableName}`
							WHERE {$constraintField} NOT IN (
								SELECT {$constraintRefField}
								FROM {$constraintRefTable}
							)
END;
					}

					try {
						l_mysql_query($sql);
					} catch (Exception $e){

					}
				}
			}
		}

		$createSql = str_replace("CREATE TABLE `{$tableName}`", "CREATE TABLE `{$tableNameNew}`", $createSql);
		l_mysql_query($createSql);

		$countResult = l_mysql_query("SELECT count(*) FROM `{$tableName}`", true);
		list($countRows) = mysql_fetch_row($countResult);

		$info = array(
			'temp_table' => $tableNameNew,
			'count_rows' => $countRows
		);

		if ($this->inParts) {
			$this->state[$tableName]['info'] = $info;
		}

		return $info;

	}


	protected function restoreTableInParts($tableName) {



		$info = $this->prepareTable($tableName);
		$tableNameNew = $info['temp_table'];
		$countRows = $info['count_rows'];


		$fields = $this->getNecessaryFields($tableName);
		$fields = implode(', ', $fields);

		if ($this->inParts) {
			$offset = isset($this->state[$tableName]['info']['offset']) ? $this->state[$tableName]['info']['offset'] : 0;
			l_mysql_query("INSERT INTO `{$tableNameNew}` ({$fields}) (SELECT {$fields} FROM {$tableName} LIMIT {$this->limit} OFFSET {$offset})");
		} else {
			$step = ceil($countRows / $this->limit);
			for($i = 0; $i < $step; $i++) {
				$offset = $i * $this->limit;
				l_mysql_query("INSERT INTO `{$tableNameNew}` ({$fields}) (SELECT {$fields} FROM {$tableName} LIMIT {$this->limit} OFFSET {$offset})");
			}
		}

		$countResultNew = l_mysql_query("SELECT count(*) FROM `{$tableNameNew}`", true);
		list($countRowsNew) = mysql_fetch_row($countResultNew);

		if ($countRows == $countRowsNew) {
			l_mysql_query("DROP TABLE `{$tableName}`");
			l_mysql_query("RENAME TABLE `{$tableNameNew}` TO `{$tableName}`");
			$this->writeLog("Data base table ({$tableName}) structure has been updated");
			if ($this->inParts) {
				$this->state[$tableName]['complete'] = true;
			}
			return true;

		} else {
			if ($this->inParts) {
				$this->state[$tableName]['info']['offset'] = $offset + $this->limit;
				$this->writeLog("{$countRowsNew}({$countRows}) rows have been updated in table `({$tableName})`");
			} else {
				$this->reportError(getLabel("label-errors-13059") . $tableName . "/");
			}

			return false;
		}
	}



	protected function checkTableRestore($tableName) {


		if($this->inParts && isset($this->state[$tableName]['info'])) {
			return $this->restoreTableInParts($tableName);
		}


		//структура, которая должна быть
		$docNew = new DOMDocument();
		if (!$docNew->load($this->sourceFile)) {
			throw new coreException("Can't load xml: " . $this->sourceFile);
		}

		//имеющаяся структура
		$docOld = new DOMDocument();
		if (!$docOld->load($this->destinationFile)) {
			throw new coreException("Can't load xml: " . $this->destinationFile);
		}

		$xpath = new DOMXPath($docOld);

		$tablesNew = $docNew->getElementsByTagName('table');
		foreach ($tablesNew as $tableNew) {
			if ($tableNew->getAttribute('name') == $tableName){
				$table = $tableNew;
				break;
			}
		}

		$fieldsRoot = $table->getElementsByTagName('fields');
		if (is_object($fieldsRoot->item(0))) {
			$fields = $fieldsRoot->item(0)->getElementsByTagName('field');

			foreach ($fields as $field) {
				if ($fieldName = $field->getAttribute('name')) {
					if (!$xpath->query("//table[@name='{$tableName}']/fields/field[@name='{$fieldName}']")->length) $this->createTableField($tableName, $fieldName, 'add');
					else {
						if ($fieldType = $field->getAttribute('type')) {
							if (!$xpath->query("//table[@name='{$tableName}']/fields/field[@name='{$fieldName}' and @type='{$fieldType}']")->length) {
								return $this->restoreTableInParts($tableName);
							}
						}
						if ($fieldSize = $field->getAttribute('size')) {
							if (!$xpath->query("//table[@name='{$tableName}']/fields/field[@name='{$fieldName}' and @size='{$fieldSize}']")->length) {
								return $this->restoreTableInParts($tableName);
							}
						}
						if ($field->getElementsByTagName('option')->length) {
							$options = $field->getElementsByTagName('option');
							foreach ($options as $option) {
								if (!$xpath->query("//table[@name='{$tableName}']/fields/field[@name='{$fieldName}'][option ='{$option->nodeValue}']")->length) {
									return $this->restoreTableInParts($tableName);
								}
							}
						}
						if ($fieldAttributes = $field->getAttribute('attributes')) {
							if (!$xpath->query("//table[@name='{$tableName}']/fields/field[@name='{$fieldName}' and @attributes='{$fieldAttributes}']")->length) {
								return $this->restoreTableInParts($tableName);
							}
						}
						if ($fieldNull = $field->getAttribute('not-null')) {
							if (!$xpath->query("//table[@name='{$tableName}']/fields/field[@name='{$fieldName}' and @not-null='{$fieldNull}']")->length) {
								return $this->restoreTableInParts($tableName);
							}
						}
						if ($field->hasAttribute('default')){
							$fieldDefault=$field->getAttribute('default');
							if (!$xpath->query("//table[@name='{$tableName}']/fields/field[@name='{$fieldName}' and @default='{$fieldDefault}']")->length) {
								return $this->restoreTableInParts($tableName);
							}
						}
						if ($fieldIncrement = $field->getAttribute('increment')) {
							if (!$xpath->query("//table[@name='{$tableName}']/fields/field[@name='{$fieldName}' and @increment='{$fieldIncrement}']")->length) {
								return $this->restoreTableInParts($tableName);
							}
						}
						if ($fieldComment = $field->getAttribute('comment')) {
							if (!$xpath->query("//table[@name='{$tableName}']/fields/field[@name='{$fieldName}' and @comment='{$fieldComment}']")->length) {
								return $this->restoreTableInParts($tableName);
							}
						}
					}
				}
			}
		}

		$indexesRoot = $table->getElementsByTagName('indexes');
		if(is_object($indexesRoot->item(0))) {
			$indexes = $indexesRoot->item(0)->getElementsByTagName('index');
			foreach ($indexes as $index) {
				if($indexName = $index->getAttribute('name')) {
					if (!$xpath->query("//table[@name='{$tableName}']/indexes/index[@name='{$indexName}']")->length) {
						return $this->restoreTableInParts($tableName);
					} else {
						if($indexType = $index->getAttribute('type')) {
							if (!$xpath->query("//table[@name='{$tableName}']/indexes/index[@name='{$indexName}' and @type='{$indexType}']")->length) {
								return $this->restoreTableInParts($tableName);
							}
						}
						if($index->getElementsByTagName('field')->length) {
							$fields = $index->getElementsByTagName('field');
							foreach ($fields as $field) {
								if (!$xpath->query("//table[@name='{$tableName}']/indexes/index[@name='{$indexName}'][field = '{$field->nodeValue}']")->length) {
									return $this->restoreTableInParts($tableName);
								} else {
									if($fieldLength = $field->getAttribute('length')) {
										if (!$xpath->query("//table[@name='{$tableName}']/indexes/index[@name='{$indexName}'][field[@length='{$fieldLength}'] ='{$field->nodeValue}']")->length) {
											return $this->restoreTableInParts($tableName);
										}
									}
								}
							}
						}
					}
				}
				if($index->getAttribute('type') == 'PRIMARY') {
					if($fieldNameNew = $index->getElementsByTagName('field')->item(0)->nodeValue) {
						if ($xpath->query("//table[@name='{$tableName}']/indexes/index[@type='PRIMARY']/field")->item(0)) {
							$fieldNameOld = $xpath->query("//table[@name='{$tableName}']/indexes/index[@type='PRIMARY']/field")->item(0)->nodeValue;
							if ($fieldNameNew != $fieldNameOld) {
								return $this->restoreTableInParts($tableName);
							}
						}
						else {
							return $this->restoreTableInParts($tableName);
						}
					}
				}
			}
		}

		$constraintsRoot = $table->getElementsByTagName('constraints');
		if(is_object($constraintsRoot->item(0))) {
			$constraints = $constraintsRoot->item(0)->getElementsByTagName('constraint');
			foreach ($constraints as $constraint) {
				if ($constraintName = $constraint->getAttribute('name')) {
					if (!$xpath->query("//table[@name='{$tableName}']/constraints/constraint[@name='{$constraintName}']")->item(0)) {
						return $this->restoreTableInParts($tableName);
					} else {
						if ($constraintField = $constraint->getAttribute('field')) {
							if (!$xpath->query("//table[@name='{$tableName}']/constraints/constraint[@name='{$constraintName}' and @field='{$constraintField}']")->item(0)) {
								return $this->restoreTableInParts($tableName);
							}
						}
						if ($constraintRefTable = $constraint->getAttribute('ref-table')) {
							if (!$xpath->query("//table[@name='{$tableName}']/constraints/constraint[@name='{$constraintName}' and @ref-table='{$constraintRefTable}']")->item(0)) {
								return $this->restoreTableInParts($tableName);
							}
						}
						if ($constraintRefField = $constraint->getAttribute('ref-field')) {
							if (!$xpath->query("//table[@name='{$tableName}']/constraints/constraint[@name='{$constraintName}' and @ref-field='{$constraintRefField}']")->item(0)) {
								return $this->restoreTableInParts($tableName);
							}
						}
						if ($constraintOnDelete = $constraint->getAttribute('on-delete')) {
							if (!$xpath->query("//table[@name='{$tableName}']/constraints/constraint[@name='{$constraintName}' and @on-delete='{$constraintOnDelete}']")->item(0)) {
								return $this->restoreTableInParts($tableName);
							}
						}
						if ($constraintOnUpdate = $constraint->getAttribute('on-update')) {
							if (!$xpath->query("//table[@name='{$tableName}']/constraints/constraint[@name='{$constraintName}' and @on-update='{$constraintOnUpdate}']")->item(0)) {
								return $this->restoreTableInParts($tableName);
							}
						}
					}
				}
			}
		}

		$tableEngine = $table->getAttribute('engine');
		if(!$xpath->query("//table[@name='{$tableName}' and @engine='{$tableEngine}']")->item(0)) $this->changeTableEngine($tableName, $tableEngine);

		$tableCharset = $table->getAttribute('charset');
		if(!$xpath->query("//table[@name='{$tableName}' and @charset='{$tableCharset}']")->item(0)) $this->changeTableCharset($tableName, $tableCharset);

		if ($this->inParts) {
			$this->state[$tableName]['complete'] = true;
		}
		return true;

	}

	protected function getNecessaryFields($tableName) {

		$fields = array();

		$doc = new DOMDocument();
		if (!$doc->load($this->sourceFile)) {
			throw new coreException("Can't load xml: " . $this->sourceFile);
		}

		$xpath = new DOMXPath($doc);
		$tableFields = $xpath->query("//table[@name='{$tableName}']/fields/field");

		if($tableFields->length) {
			foreach($tableFields as $field) {
				$fields[] = $field->getAttribute('name');
			}
		}

		return $fields;

	}

}



	if(isset($_REQUEST['p'])) {
		$p = $_REQUEST['p'];
		if($p < 0 && $p != 'all') $p = 0;
		if($p != 'all') $p = (int) $p;
		$_REQUEST['p'] = $p;
		unset($p);
	}

	define('MB_ENCODING_SUPPORTED', function_exists('mb_internal_encoding'));
	if(MB_ENCODING_SUPPORTED) {
		define('MB_INTERNAL_ENCODING', mb_internal_encoding());
	} else {
		define('MB_INTERNAL_ENCODING', false);
	}

	function wa_strtolower($str) {
		if (MB_ENCODING_SUPPORTED) {
			mb_internal_encoding("UTF-8");
			return mb_strtolower($str);
	}
		else {
			return strtolower($str);
		}
	}

	function wa_substr($str, $pos, $offset) {
		if (MB_ENCODING_SUPPORTED) {
			mb_internal_encoding("UTF-8");
			return mb_substr($str, $pos, $offset);
	}
		else {
			return substr($str, $pos, $offset);
		}
	}

	function wa_strlen($str) {
		if (MB_ENCODING_SUPPORTED) {
			mb_internal_encoding("UTF-8");
			return mb_strlen($str);
		}
		elseif(is_string($str)&& !preg_match('/[^\x00-\x7F]/S', $str)) {
			return strlen($str);
		}
		return strlen(utf8_decode($str));
	}

	function wa_strpos($str, $seek) {
		if (MB_ENCODING_SUPPORTED) {
			mb_internal_encoding("UTF-8");
			return mb_strpos($str, $seek);
	}
		else {
			return strpos($str, $seek);
		}
	}


	function getArrayKey($array, $key) {
		if(!is_array($array)) {
			return false;
		}

		if($key === false) return NULL;

		if(array_key_exists($key, $array)) {
			return $array[$key];
		} else {
			return NULL;
		}
	}

	function getRequest($key) {
		if ($key == 'p') {
			$answer = prepareRequest($key);
			if ($answer !== false) return $answer;
		}
		return getArrayKey($_REQUEST, $key);
	}

	function getSession($key) {
		if(!isset($_SESSION)) return NULL;
		return getArrayKey($_SESSION, $key);
	}

	function getServer($key) {
		if($key == 'REMOTE_ADDR' && getArrayKey($_SERVER, 'HTTP_X_REAL_IP') !== null) return getArrayKey($_SERVER, 'HTTP_X_REAL_IP');
		return getArrayKey($_SERVER, $key);
	}

	function getCookie($key) {
		return getArrayKey($_COOKIE, $key);
	}

	function getLabel($key, $path = false) {
		$args = func_get_args();
		return ulangStream::getLabel($key, $path, $args);
	}

	function getI18n($key, $pattern = "") {
		return ulangStream::getI18n($key, $pattern);
	}

	function l_mysql_query($sql, $no_cache = false, $className = 'core') {
		static $pool, $i = 0;
		if(is_null($pool)) {
			$pool = ConnectionPool::getInstance();
		}

		$conn = $pool->getConnection($className);
		$result = $conn->query($sql, $no_cache);

		return $result;
	}

	function l_mysql_real_escape_string($inputString, $className = 'core') {
		static $pool = null;
		if(is_null($pool)) {
			$pool = ConnectionPool::getInstance();
		}

		$conn = $pool->getConnection($className);
		if($conn->isOpen()) {
			$info = $conn->getConnectionInfo();
			$link = $info['link'];
			$result = mysql_real_escape_string($inputString, $link);
		} else {
			$result = addslashes($inputString);
		}

		return $result;
	}

	function l_mysql_insert_id($className = 'core') {

		static $pool = null;
		if(is_null($pool)) {
			$pool = ConnectionPool::getInstance();
		}

		$connection = $pool->getConnection($className);
		$info = $connection->getConnectionInfo();
		$link = $info['link'];
		return mysql_insert_id($link);

	}

	function l_mysql_error($className = 'core') {

		static $pool = null;
		if(is_null($pool)) {
			$pool = ConnectionPool::getInstance();
		}

		$connection = $pool->getConnection($className);
		$info = $connection->getConnectionInfo();
		$link = $info['link'];
		return mysql_error($link);

	}

	function l_mysql_affected_rows($className = 'core') {

		static $pool = null;
		if(is_null($pool)) {
			$pool = ConnectionPool::getInstance();
		}

		$connection = $pool->getConnection($className);
		$info = $connection->getConnectionInfo();
		$link = $info['link'];
		return mysql_affected_rows($link);

	}

	function bytes_strlen($string) {
		if(MB_ENCODING_SUPPORTED) {
			mb_internal_encoding("latin1");
			$iResult = strlen($string);
			mb_internal_encoding(MB_INTERNAL_ENCODING);
		} else {
			return strlen($string);
		}
	}

	function bytes_substr($string, $start, $length = false) {
		if(MB_ENCODING_SUPPORTED) {
			mb_internal_encoding("latin1");
			$sResult = '';
			if($length !== false) {
				$sResult = substr($string, $start, $length);
			} else {
				$sResult = substr($string, $start);
			}
			mb_internal_encoding(MB_INTERNAL_ENCODING);
			return $sResult;
		} else {
			if($length !== false)
				return substr($string, $start, $length);
			else
				return substr($string, $start);
		}
	}

	/* Deprecated */
	function natsort2d(&$originalArray, $seekKey = 0) {
		if(is_array($originalArray) == false) {
			return;
		}

		$temp = $resultArray = Array();
		foreach ($originalArray as $key => $value) {
			$temp[$key] = $value[$seekKey];
		}
		natsort($temp);
		foreach ($temp as $key => $value) {
			$resultArray[] = $originalArray[$key];
		}
		$originalArray = $resultArray;
	}

	function removeDirectory($dir) {
		if(!$dh = @opendir($dir)) {
			return false;
		}
		while (($obj = readdir($dh)) !== false) {
			if($obj=='.' || $obj=='..') continue;
				if (!@unlink($dir.'/'.$obj)) {
					removeDirectory($dir.'/'.$obj);
				}
		}
		@rmdir($dir);
		return true;
	}

	function getInterfaceLangs() {
		global $interface_langs;
		return $interface_langs;
	}

	function checkInterfaceLang($prefix) {
		
		return $prefix; // bugfix: 0014317
		
		$config = mainConfiguration::getInstance();
		$langs = $config->get('system', 'interface-langs');

		return in_array($prefix, $langs) ? $prefix : "ru";
	}


	function check_session() {
		$ip = getServer('REMOTE_ADDR');
		if(is_null(getSession('session-owner-ip'))) {
			$_SESSION['session-owner-ip'] = $ip;
			return true;
		}

		if(!session_id()) {
			session_start();
		}

		if(getSession('session-owner-ip') == $ip) {
			return true;
		} else {
			session_destroy();
			session_start();
			return false;
		}
	}

	function enableOutputCompression() {
		if(extension_loaded('zlib') && !defined('DEBUG')) {
			$buffer = ob_get_contents();
			while(@ob_end_clean());
			ob_start('ob_gzhandler');
			ob_start('criticalErrorsBufferHandler');
			echo $buffer;
		}
	}

	function disableOutputCompression() {
		static $called = false;

		if($called) {
			return false;
		}

		while(@ob_end_clean());
		ob_start();

		header("Content-Encoding:");
		header("Content-Length:");
		header("Vary:");


		$called = true;
		return true;
	}

	function array_extract_values($array, &$result = NULL, $ignoreVoidValues = false) {
		if(is_array($array) == false) {
			return Array();
		}

		if(is_array($result) == false) {
			$result = Array();
		}

		foreach($array as $value) {
			if(is_array($value) == false) {
				if($value || $ignoreVoidValues == true) {
					$result[] = $value;
				}
			} else {
				array_extract_values($value, $result, $ignoreVoidValues);
			}
		}
		return $result;
	}

	function array_unique_arrays($array, $key) {
		$result = Array();
		$keys = Array();

		foreach($array as $arr) {
			$currKey = isset($arr[$key]) ? $arr[$key] : NULL;
			if(in_array($currKey, $keys)) {
				continue;
			} else {
				$keys[] = $currKey;
				$result[] = $arr;
			}
		}
		return $result;
	}

	function array_distinct($array) {
		$result = $hashes = array();

		foreach($array as $subArray) {
			$key = sha1(serialize($subArray));

			if(in_array($key, $hashes)) {
				continue;
			}
			$result[] = $subArray;
			$hashes[] = $key;
		}
		return $result;
	}

	function array_positive_values($arr, $recursion = true) {
		if(is_array($arr) == false) {
			return Array();
		}

		$result = Array();
		foreach($arr as $key => $value) {
			if($value) {
				if(is_array($value)) {
					if($recursion) {
						$value = array_positive_values($value, $recursion);
						if(sizeof($value) == 0) {
							continue;
						}
					}
				}
				$result[$key] = $value;
			}
		}
		return $result;
	}

	function set_timebreak($time_end = false) {
		global $time_start;

		if($time_end == false) {
			$time_end = microtime(true);
		}
		$time = $time_end - $time_start;
		return "\r\n<!-- This page generated in {$time} secs -->\r\n";
	}

	// Thanks, Anton Timoshenkov
	function makeThumbnailFullUnsharpMask($img, $amount, $radius, $threshold) {

		if (function_exists('UnsharpMask')){return UnsharpMask($img, $amount, $radius, $threshold);}
			else{

			// Attempt to calibrate the parameters to Photoshop:
			if ($amount > 500) $amount = 500;
			$amount = $amount * 0.016;
			if ($radius > 50) $radius = 50;
			$radius = $radius * 2;
			if ($threshold > 255) $threshold = 255;

			$radius = abs(round($radius)); 	// Only integers make sense.
			if ($radius == 0) {	return $img; imagedestroy($img); break;	}
			$w = imagesx($img); $h = imagesy($img);
			$imgCanvas = $img;
			$imgCanvas2 = $img;
			$imgBlur = imagecreatetruecolor($w, $h);

			// Gaussian blur matrix:
			//	1	2	1
			//	2	4	2
			//	1	2	1

			// Move copies of the image around one pixel at the time and merge them with weight
			// according to the matrix. The same matrix is simply repeated for higher radii.
			for ($i = 0; $i < $radius; $i++)
				{
				imagecopy	  ($imgBlur, $imgCanvas, 0, 0, 1, 1, $w - 1, $h - 1); // up left
				imagecopymerge ($imgBlur, $imgCanvas, 1, 1, 0, 0, $w, $h, 50); // down right
				imagecopymerge ($imgBlur, $imgCanvas, 0, 1, 1, 0, $w - 1, $h, 33.33333); // down left
				imagecopymerge ($imgBlur, $imgCanvas, 1, 0, 0, 1, $w, $h - 1, 25); // up right
				imagecopymerge ($imgBlur, $imgCanvas, 0, 0, 1, 0, $w - 1, $h, 33.33333); // left
				imagecopymerge ($imgBlur, $imgCanvas, 1, 0, 0, 0, $w, $h, 25); // right
				imagecopymerge ($imgBlur, $imgCanvas, 0, 0, 0, 1, $w, $h - 1, 20 ); // up
				imagecopymerge ($imgBlur, $imgCanvas, 0, 1, 0, 0, $w, $h, 16.666667); // down
				imagecopymerge ($imgBlur, $imgCanvas, 0, 0, 0, 0, $w, $h, 50); // center
				}
			$imgCanvas = $imgBlur;

			// Calculate the difference between the blurred pixels and the original
			// and set the pixels
			for ($x = 0; $x < $w; $x++)
				{ // each row
				for ($y = 0; $y < $h; $y++)
					{ // each pixel
					$rgbOrig = ImageColorAt($imgCanvas2, $x, $y);
					$rOrig = (($rgbOrig >> 16) & 0xFF);
					$gOrig = (($rgbOrig >> 8) & 0xFF);
					$bOrig = ($rgbOrig & 0xFF);
					$rgbBlur = ImageColorAt($imgCanvas, $x, $y);
					$rBlur = (($rgbBlur >> 16) & 0xFF);
					$gBlur = (($rgbBlur >> 8) & 0xFF);
					$bBlur = ($rgbBlur & 0xFF);

					// When the masked pixels differ less from the original
					// than the threshold specifies, they are set to their original value.
					$rNew = (abs($rOrig - $rBlur) >= $threshold) ? max(0, min(255, ($amount * ($rOrig - $rBlur)) + $rOrig)) : $rOrig;
					$gNew = (abs($gOrig - $gBlur) >= $threshold) ? max(0, min(255, ($amount * ($gOrig - $gBlur)) + $gOrig)) : $gOrig;
					$bNew = (abs($bOrig - $bBlur) >= $threshold) ? max(0, min(255, ($amount * ($bOrig - $bBlur)) + $bOrig)) : $bOrig;

					if (($rOrig != $rNew) || ($gOrig != $gNew) || ($bOrig != $bNew))
						{
						$pixCol = ImageColorAllocate($img, $rNew, $gNew, $bNew);
						ImageSetPixel($img, $x, $y, $pixCol);
						}
					}
				}
			return $img;
		}

	}

	/** Определение константы для pathinfo */
	if (!defined('PATHINFO_FILENAME')) {
		define('PATHINFO_FILENAME', 8);
	}
	/** Дополнение функции pathinfo,
	 * т.к. константа PATHINFO_FILENAME определена с 5.2
	 * @param (string) $filename - полный путь
	 * @param (string|int) default=null $req_param ('dirname'|'basename'|'extension'|'filename')
	 * @return assoc array or requested value
	 */
	function getPathInfo($filename, $req_param=NULL) {
		$info = pathinfo($filename);
		if (!isset($info['filename'])) {
			/** php_ver <= 5.1.6 */
			$info['filename'] = substr($info['basename'], 0, strpos($info['basename'],'.'));
		}
		if (is_null($req_param)) {
			return $info;
		}

		switch($req_param) {
			case 'dirname':
			case '1':
				return $info['dirname'];
				break;
			case 'basename':
			case '2':
				return $info['basename'];
				break;
			case 'extension':
			case '4':
				return $info['extension'];
				break;
			case 'filename':
			case '8':
				return $info['filename'];
				break;
			default:
				return $info;
		}
	}


	function makeThumbnailFull($path, $thumbs_path, $width, $height, $crop = true, $cropside = 5, $isLogo = false, $quality = 80) {

		$isSharpen=true;

		$image = new umiImageFile($path);
		$file_name = $image->getFileName();
		$file_ext = strtolower($image->getExt());
		$file_ext = ($file_ext=='bmp'?'jpg':$file_ext);

		$allowedExts = Array('gif', 'jpeg', 'jpg', 'png', 'bmp');
		if(!in_array($file_ext, $allowedExts)) return "";

		$file_name = substr($file_name, 0, (strlen($file_name) - (strlen($file_ext) + 1)) );

		$thumbPath = sha1($image->getDirName());

		if (!is_dir($thumbs_path . $thumbPath)) {
			mkdir($thumbs_path . $thumbPath, 0755, true);
		}

		$file_name_new = $file_name . '_' . $width . '_' . $height . '_' . $cropside . '_' . $quality . "." . $file_ext;
		$path_new = $thumbs_path . $thumbPath . '/' . $file_name_new;

		if(!file_exists($path_new) || filemtime($path_new) < filemtime($path)) {
			if(file_exists($path_new)) {
				unlink($path_new);
			}

			$width_src = $image->getWidth();
			$height_src = $image->getHeight();

			if($height == "auto") {
				$real_height = (int) round($height_src * ($width / $width_src));
				//change
				$height=$real_height;
				$real_width = (int) $width;
			} else {
				if($width == "auto") {
						$real_width = (int) round($width_src * ($height / $height_src));
						//change
						$width=$real_width;
				} else {
					$real_width = (int) $width;
				}

				$real_height = (int) $height;
			}

			$offset_h=0;
			$offset_w=0;

			// realloc: devision by zero fix
			if (!intval($width) || !intval($height)) {
				$crop = false;
			}

			if ($crop){
				$width_ratio = $width_src/$width;
				$height_ratio = $height_src/$height;

				if ($width_ratio > $height_ratio){
					$offset_w = round(($width_src-$width*$height_ratio)/2);
					$width_src = round($width*$height_ratio);
				} elseif ($width_ratio < $height_ratio){
					$offset_h = round(($height_src-$height*$width_ratio)/2);
					$height_src = round($height*$width_ratio);
					}


				if($cropside) {
					//defore all it was cropside work like as - 5
					//123
					//456
					//789
					switch ($cropside):
						case 1:
							$offset_w = 0;
							$offset_h = 0;
							break;
						case 2:
							$offset_h = 0;
							break;
						case 3:
							$offset_w += $offset_w;
							$offset_h = 0;
							break;
						case 4:
							$offset_w = 0;
							break;
						case 5:
							break;
						case 6:
							$offset_w += $offset_w;
							break;
						case 7:
							$offset_w = 0;
							$offset_h += $offset_h;
							break;
						case 8:
							$offset_h += $offset_h;
							break;
						case 9:
							$offset_w += $offset_w;
							$offset_h += $offset_h;
							break;
					endswitch;
				}
			}

			$thumb = imagecreatetruecolor($real_width, $real_height);

			$source_array = $image->createImage($path);
			$source = $source_array['im'];

			if ($width*4 < $width_src && $height*4 < $height_src) {
				$_TMP=array();
				$_TMP['width'] = round($width*4);
				$_TMP['height'] = round($height*4);

				$_TMP['image'] = imagecreatetruecolor($_TMP['width'], $_TMP['height']);

				if ($file_ext == 'gif') {
					$_TMP['image_white'] = imagecolorallocate($_TMP['image'], 255, 255, 255);
					imagefill($_TMP['image'], 0, 0, $_TMP['image_white']);
					imagecolortransparent($_TMP['image'], $_TMP['image_white']);
					imagealphablending($source, TRUE);
					imagealphablending($_TMP['image'], TRUE);
				} else {
				    imagealphablending($_TMP['image'], false);
				    imagesavealpha($_TMP['image'], true);
				}
				imagecopyresampled($_TMP['image'], $source, 0, 0, $offset_w, $offset_h, $_TMP['width'], $_TMP['height'], $width_src, $height_src);

				imageDestroy($source);

				$source = $_TMP['image'];
				$width_src = $_TMP['width'];
				$height_src = $_TMP['height'];

				$offset_w = 0;
				$offset_h = 0;
				unset($_TMP);
			}

			if ($file_ext == 'gif') {
				$thumb_white_color = imagecolorallocate($thumb, 255, 255, 255);
				imagefill($thumb, 0, 0, $thumb_white_color);
				imagecolortransparent($thumb, $thumb_white_color);
				imagealphablending($source, TRUE);
				imagealphablending($thumb, TRUE);
			} else {
				imagealphablending($thumb, false);
				imagesavealpha($thumb, true);
			}

			imagecopyresampled($thumb, $source, 0, 0, $offset_w, $offset_h, $width, $height, $width_src, $height_src);
			if($isSharpen) $thumb = makeThumbnailFullUnsharpMask($thumb,80,.5,3);

			switch($file_ext) {
					case 'gif':
						$res = imagegif($thumb, $path_new);
						break;
				case 'png':
						$res = imagepng($thumb, $path_new);
					break;
				default:
						$res = imagejpeg($thumb, $path_new, $quality);
			}
				if(!$res) {
					throw new coreException(getLabel('label-errors-16008'));
				}

			imageDestroy($source);
			imageDestroy($thumb);

			if($isLogo) {
				umiImageFile::addWatermark($path_new);
			}
		}

		$value = new umiImageFile($path_new);

		$arr = Array();
		$arr['size'] = $value->getSize();
		$arr['filename'] = $value->getFileName();
		$arr['filepath'] = $value->getFilePath();
		$arr['src'] = $value->getFilePath(true);
		$arr['ext'] = $value->getExt();

		$arr['width'] = $value->getWidth();
		$arr['height'] = $value->getHeight();

		if(cmsController::getInstance()->getCurrentMode() == "admin") {
			$arr['src'] = str_replace("&", "&amp;", $arr['src']);
		}

		return $arr;
	}

	function dateToString($timestamp) {
		$monthsList = array('января', 'февраля', 'марта', 'апреля', 'мая', 'июня', 'июля', 'августа', 'сентября', 'октября', 'ноября', 'декабря');
		$date = date('j.m.Y', $timestamp);
		list($day, $month, $year) = explode('.', $date);
		return $day . " " . $monthsList[(int)$month - 1] . " " . $year;
	}

	function sumToString($i_number, $i_gender = 1, $s_w1 = 'рубль', $s_w2to4 = 'рубля', $s_w5to10 = 'рублей') {
		if (!$i_number) {
			return rtrim("ноль " . $s_w5to10);
		}

		$s_answer = "";
		$v_number = $i_number;

		if (strpos($i_number, '.') !== 0) {
			$i_number = number_format($i_number, 2, '.', '');
			list($v_number, $copecks) = explode('.', $i_number);
			$arr_tmp = SummaStringThree($s_answer, $copecks , 2, "копейка", "копейки", "копеек");
			$s_answer = $arr_tmp['Summa'];
		}

		$arr_tmp = SummaStringThree($s_answer, $v_number, $i_gender, $s_w1, $s_w2to4, $s_w5to10);
		$v_number = $arr_tmp['TempValue'];
		$s_answer = $arr_tmp['Summa'];
		if (!$v_number) return $s_answer;

		$arr_tmp = SummaStringThree($s_answer, $v_number, 2, "тысяча", "тысячи", "тысяч");
		$v_number = $arr_tmp['TempValue'];
		$s_answer = $arr_tmp['Summa'];
		if (!$v_number) return $s_answer;

		$arr_tmp = SummaStringThree($s_answer, $v_number, 1, "миллион", "миллиона", "миллионов");
		$v_number = $arr_tmp['TempValue'];
		$s_answer = $arr_tmp['Summa'];
		if (!$v_number) return $s_answer;

		$arr_tmp = SummaStringThree($s_answer, $v_number, 1, "миллиард", "миллиарда", "миллиардов");
		$v_number = $arr_tmp['TempValue'];
		$s_answer = $arr_tmp['Summa'];
		if (!$v_number) return $s_answer;

		$arr_tmp = SummaStringThree($s_answer, $v_number, 1, "триллион", "триллиона", "триллионов");
		$v_number = $arr_tmp['TempValue'];
		$s_answer = $arr_tmp['Summa'];
		return $s_answer;
	}

	function SummaStringThree($Summa, $TempValue, $Rod, $w1, $w2to4, $w5to10) {
		$Rest = 0; $Rest1 = 0;
		$EndWord = "";
		$s1 = ""; $s10 = ""; $s100 = "";

		$Rest = strlen($TempValue) < 4 ? $TempValue : substr($TempValue, -3);
		$TempValue = floor($TempValue / 1000);
		if ($Rest === 0) {
			if ($Summa === "") $Summa = $w5to10 . " ";
			return array('TempValue' => $TempValue, 'Summa' => $Summa);
		}

		$EndWord = $w5to10;

		$i_i = floor($Rest / 100);
		switch ($i_i) {
			case 0: $s100 = ""; break;
			case 1: $s100 = "сто "; break;
			case 2: $s100 = "двести "; break;
			case 3: $s100 = "триста "; break;
			case 4: $s100 = "четыреста "; break;
			case 5: $s100 = "пятьсот "; break;
			case 6: $s100 = "шестьсот "; break;
			case 7: $s100 = "семьсот "; break;
			case 8: $s100 = "восемьсот "; break;
			case 9: $s100 = "девятьсот "; break;
		}
		$Rest = $Rest % 100;
		$Rest1 = intval(floor($Rest / 10));
		$s1 = "";
		switch ($Rest1) {
			case 0:
				$s10 = ""; break;
			case 1:
				switch ($Rest) {
					case 10: $s10 = "десять "; break;
					case 11: $s10 = "одиннадцать "; break;
					case 12: $s10 = "двенадцать "; break;
					case 13: $s10 = "тринадцать "; break;
					case 14: $s10 = "четырнадцать "; break;
					case 15: $s10 = "пятнадцать "; break;
					case 16: $s10 = "шестнадцать "; break;
					case 17: $s10 = "семнадцать "; break;
					case 18: $s10 = "восемнадцать "; break;
					case 19: $s10 = "девятнадцать "; break;
				}
				break;
			case 2: $s10 = "двадцать "; break;
			case 3: $s10 = "тридцать "; break;
			case 4: $s10 = "сорок "; break;
			case 5: $s10 = "пятьдесят "; break;
			case 6: $s10 = "шестьдесят "; break;
			case 7: $s10 = "семьдесят "; break;
			case 8: $s10 = "восемьдесят "; break;
			case 9: $s10 = "девяносто "; break;
		}

		if ($Rest1 !== 1) {
			$i_j = $Rest % 10;
			switch($i_j) {
				case 1:
					switch($Rod) {
						case 1: $s1 = "один "; break;
						case 2: $s1 = "одна "; break;
						case 3: $s1 = "одно "; break;
					}
					$EndWord = $w1;
					break;
				case 2:
					if ($Rod === 2) {$s1 = "две ";} else {$s1 = "два ";}
					$EndWord = $w2to4;
					break;
				case 3:
					$s1 = "три ";
					$EndWord = $w2to4;
					break;
				case 4:
					$s1 = "четыре ";
					$EndWord = $w2to4;
					break;
				case 5: $s1 = "пять "; break;
				case 6: $s1 = "шесть "; break;
				case 7: $s1 = "семь "; break;
				case 8: $s1 = "восемь "; break;
				case 9:$s1 = "девять "; break;
			}
		}

		$Summa = rtrim(rtrim($s100 . $s10 . $s1 . $EndWord) . " " . $Summa);

		return array('TempValue' => $TempValue, 'Summa' => $Summa);
	}


	function prepareRequest($key) {

		$cmsController = cmsController::getInstance();
		if ($cmsController->getCurrentMode() != 'admin') return false;
		$domains = getRequest('domain_id');
		$langs = getRequest('lang_id');
		$rels = getRequest('rel');
		if (!is_array($domains) || !is_array($langs)) return false;
		$module = $cmsController->getCurrentModule();
		$method = $cmsController->getCurrentMethod();
		if(!$module || !$method) return false;

		if (!isset($_SESSION['paging'])) $_SESSION['paging'] = array();
		$domainId = $domains[0];
		if (!isset($_SESSION['paging'][$domainId])) $_SESSION['paging'][$domainId] = array();
		$langId = $langs[0];
		if (!isset($_SESSION['paging'][$domainId][$langId])) $_SESSION['paging'][$domainId][$langId] = array();
		if (!isset($_SESSION['paging'][$domainId][$langId][$module])) $_SESSION['paging'][$domainId][$langId][$module] = array();
		if (!isset($_SESSION['paging'][$domainId][$langId][$module][$method])) $_SESSION['paging'][$domainId][$langId][$module][$method] = array();

		if (is_array($rels)) $relId = $rels[0];
		else $relId = 0;

		if (!isset($_SESSION['paging'][$domainId][$langId][$module][$method][$relId])) $_SESSION['paging'][$domainId][$langId][$module][$method][$relId] = NULL;

		$currentPage = getArrayKey($_REQUEST, $key);
		if (!is_null($currentPage)) {
			$_SESSION['paging'][$domainId][$langId][$module][$method][$relId] = $currentPage;
		}

		return $_SESSION['paging'][$domainId][$langId][$module][$method][$relId];
	}

	function umi_var_dump($value, $return = false){

		$remoteIp = getServer('HTTP_X_REAL_IP');

		if (!$remoteIp) {
			$remoteIp = getServer('REMOTE_ADDR');
		}
		$config = mainConfiguration::getInstance();
		$allowedIps = $config->get('debug', 'allowed-ip');

		$allowedIps = is_array($allowedIps) ? $allowedIps : array();

		if (in_array($remoteIp, $allowedIps)) {
			var_dump($value);
		} elseif ($return) {
			var_dump($value);
		}
	}

	function elfinder_get_hash($path) {
		$path = str_replace('\\', '/', realpath("./" . trim($path, "./\\")));

        $permissions = permissionsCollection::getInstance();
		$userId = $permissions->getUserId();
		$user = umiObjectsCollection::getInstance()->getObject($userId);

		$source = "";

		if ($filemanagerDirectory = $user->getValue('filemanager_directory')) {
			$i = 1;
			$directories = explode(",", $filemanagerDirectory);
			foreach ($directories as $directory) {
				$directory = trim($directory);
				if (!strlen($directory)) continue;
				$directory = trim($directory, "/");
				$directoryPath = realpath(CURRENT_WORKING_DIR . "/" . $directory);
				if (strpos($directoryPath, CURRENT_WORKING_DIR) === false || !is_dir($directoryPath)) continue;
				if (strpos($path, $directory) !== false) {
					$source = "files" . $i;
					$path = trim(str_replace(CURRENT_WORKING_DIR . "/" . $directory, "", $path), "/");
					break;
				}
				$i++;
			}
		} else {
			$images_path = str_replace('\\', '/', realpath(CURRENT_WORKING_DIR . "/images"));
	        $files_path = str_replace('\\', '/', realpath(CURRENT_WORKING_DIR . "/files"));
	        if (strpos($path, $images_path) === 0) {
        		$path = trim(str_replace($images_path, "", $path), "/");
        		$source = "images";
			} elseif (strpos($path, $images_path) === 0) {
				$path = trim(str_replace($images_path, "", $path), "/");
        		$source = "files";
			}
		}

		$path = str_replace("/", DIRECTORY_SEPARATOR, $path);
		$hash = strtr(base64_encode($path), '+/=', '-_.');
		$hash = rtrim($hash, '.');


		return strlen($hash) ? "umi" . $source . "_" . $hash : "";

	}






	class mainConfiguration {
		private static $instance = null;
		private $ini    = array();
		private $edited = false;
		/**
		 *
		 */
		private function __construct() {
			if(!is_readable(CONFIG_INI_PATH)) {
				throw new Exception("Can't find configuration file");
			}
			$this->ini = parse_ini_file(CONFIG_INI_PATH, true);

			if(isset($this->ini['system']) && isset($this->ini['system']['session-lifetime']) && $this->ini['system']['session-lifetime'] < 1) {
 			   $this->ini['system']['session-lifetime'] = 1440;
			}
		}
		/**
		 *
		 */
		public function __destruct() {
			if($this->edited) {
				$this->writeIni();
			}
		}
		/**
		 * Возвращает экземпляр конфигурации
		 * return mainConfiguration
		 */
		public static function getInstance($c = NULL) {
			if(!self::$instance) {
				self::$instance = new mainConfiguration();
			}
			return self::$instance;
		}
		/**
		 * Возвращает конфигурацию в виде массива
		 * return Array
		 */
		public function getParsedIni() {
			return $this->ini;
		}
		/**
		 * Возвращает значение переменной
		 * @param String $section
		 * @param String $variable
		 * @return String
		 */
		public function get($section, $variable) {
			if(isset($this->ini[$section]) &&
			   isset($this->ini[$section][$variable])) {
				$value = $this->ini[$section][$variable];
				$value = $this->unescapeValue($value);
				if ($section == 'system' && $variable == 'session-lifetime' && $value < 1) $value = 1440;
				return $value;
			} else return null;
		}
		/**
		 * Устанавливает или стирает значение переменной
		 * @param String $section
		 * @param String $variable
		 * @param Mixed $value
		 */
		public function set($section, $variable, $value) {
			if(!isset($this->ini[$section])) {
				$this->ini[$section] = array();
			}
			if($value === null && isset($this->ini[$section][$variable])) {
				unset($this->ini[$section][$variable]);
			} else {
				if ($section == 'system' && $variable == 'session-lifetime' && $value < 1) $value = 1440;
				$this->ini[$section][$variable] = $value;
			}
			$this->edited = true;
		}

		/**
			* Возвращает список переметров в секции
			* @param String $section
			* @return Array
		*/
		public function getList($section) {
			if(isset($this->ini[$section]) && is_array($this->ini[$section])) {
				return array_keys($this->ini[$section]);
			} return null;
		}

		public function includeParam($key, array $params =  null) {
			static $defaultParams = Array();

			$path = $this->get('includes', $key);
			if(strpos($path, "{") !== false) {
				if(class_exists('cmsController') && !sizeof($defaultParams)) {
					$cmsController = cmsController::getInstance();

					if($lang = $cmsController->getCurrentLang()) {
						$defaultParams['lang'] = $cmsController->getCurrentLang()->getPrefix();
					}
					if($lang = $cmsController->getCurrentLang()) {
						$defaultParams['domain'] = $cmsController->getCurrentDomain()->getHost();
					}
				}

				$params = (is_null($params)) ? $defaultParams : array_merge($params, $defaultParams);
				foreach($params as $i => $v) $path = str_replace('{' . $i . '}', $v,  $path);
			}


			if(substr($path, 0, 2) == "~/") {
				$path = CURRENT_WORKING_DIR . substr($path, 1);
			}

			return $path;
		}

		/**
		 *
		 */
		private function writeIni() {
			$iniString = "";
			foreach($this->ini as $sname => $section) {
				if(empty($section)) continue;
				$iniString .= "[{$sname}]\n";
				foreach($section as $name => $value) {
					if(is_array($value)) {
						foreach($value as $sval) {
							$sval = ($sval !== '') ? '"' . $sval . '"' : '';
							$iniString .= "{$name}[] = {$sval}\n";
						}
					} else {
						$value = ($value !== '') ? '"' . $value . '"' : '';
						$iniString .= "{$name} = {$value}\n";
					}
				}
				$iniString .= "\n";
			}
			file_put_contents(CONFIG_INI_PATH, $iniString);
		}

		private function unescapeValue($value) {
			if(is_array($value)) {
				foreach($value as $i => $v) {
					$value[$i] = $this->unescapeValue($v);
				}
				return $value;
			}

			if(strlen($value) >= 2 && substr($value, 0, 1) == "'" && substr($value, -1, 1) == "'") {
				$value = substr($value, 1, strlen($value) - 2);
			}
			return $value;
		}
	};



	if (!defined("CURRENT_WORKING_DIR")) {
		define("CURRENT_WORKING_DIR", str_replace("\\", "/", dirname(dirname(__FILE__))));
	}

	if(!defined('CONFIG_INI_PATH')) {
		define('CONFIG_INI_PATH', CURRENT_WORKING_DIR . '/config.ini');
	}

	if (!function_exists('showWorkTime')) {
		require_once CURRENT_WORKING_DIR . '/libs/root-src/profiler.php';
	}
	showWorkTime("config start");

	if(!class_exists('mainConfiguration')) {
		require CURRENT_WORKING_DIR . '/libs/configuration.php';
	}

	try {
		$config = mainConfiguration::getInstance();
	} catch (Exception $e) {
		echo 'Critical error: ', $e->getMessage();
		exit;
	}

	$ini = $config->getParsedIni();

	initConfigConstants($ini);

	define("SYS_KERNEL_PATH", $config->includeParam('system.kernel'));
	define("SYS_KERNEL_ASM", $config->includeParam('system.kernel.assebled'));
	define("SYS_LIBS_PATH", $config->includeParam('system.libs'));
	define("SYS_DEF_MODULE_PATH", $config->includeParam('system.default-module'));
	define("SYS_TPLS_PATH", $config->includeParam('templates.tpl'));
	define("SYS_XSLT_PATH", $config->includeParam('templates.xsl'));
	define("SYS_SKIN_PATH", $config->includeParam('templates.skins'));
	define("SYS_ERRORS_PATH", $config->includeParam('system.error'));
	define("SYS_MODULES_PATH", $config->includeParam('system.modules'));
	define("SYS_CACHE_RUNTIME", $config->includeParam('system.runtime-cache'));
	define("SYS_MANIFEST_PATH", $config->includeParam('system.manifest'));
	define("SYS_KERNEL_STREAMS", $config->includeParam('system.kernel.streams'));

	define("KEYWORD_GRAB_ALL", $config->get('kernel', 'grab-all-keyword'));

	$cacheSalt = $config->get('system', 'salt');
	if(!$cacheSalt) {
		$cacheSalt = sha1(rand());
		$config->set('system', 'salt', $cacheSalt);
	}
	define("SYS_CACHE_SALT", $cacheSalt);

	spl_autoload_register('umiAutoload');
                                      
	if(!defined('_C_REQUIRES')) {
        showWorkTime("config require requires start");
		require SYS_LIBS_PATH . 'requires.php';
        showWorkTime("config require requires end");
	}

	// [debug]
	$debug = false;
	if($config->get('debug', 'enabled')) {
		$ips = $config->get('debug', 'filter.ip');
		if(is_array($ips)) {
			if(in_array(getServer('REMOTE_ADDR'), $ips)) {
				$debug = true;
			}
		} else {
			$debug = true;
		}
	}
	if (!defined('DEBUG')) define('DEBUG', $debug);
	if (!defined('DEBUG_SHOW_BACKTRACE')) {

		$showBacktrace = false;
		$allowedIps = $config->get('debug', 'allowed-ip');
		$allowedIps = is_array($allowedIps) ? $allowedIps : array();
		if ($config->get('debug', 'show-backtrace') && (!count($allowedIps) || in_array(getServer('REMOTE_ADDR'), $allowedIps))) $showBacktrace = true;
		define('DEBUG_SHOW_BACKTRACE', $showBacktrace);
	}

	if(!defined('_C_ERRORS')) {
		require SYS_LIBS_PATH . 'errors.php';
	}

	if ($timezone = $config->get("system", "time-zone")) {
		@date_default_timezone_set($timezone);
	}

	initConfigConnections($ini);

	if(defined("LIBXML_VERSION")) {
		define("DOM_LOAD_OPTIONS", (LIBXML_VERSION < 20621) ? 0 : LIBXML_COMPACT);
	} else {
		define("DOM_LOAD_OPTIONS", LIBXML_COMPACT);
	}
	if (!defined("PHP_INT_MAX")) define("PHP_INT_MAX", 4294967296 / 2 - 1);


	if(!isset($_ENV['OS']) || strtolower(substr($_ENV['OS'], 0, 3)) != "win") {
		setlocale(LC_NUMERIC, 'en_US.utf8');
	}

	if(function_exists("mb_internal_encoding")) {
		mb_internal_encoding('UTF-8');
	}

	// system.session-lifetime
	ini_set("session.gc_maxlifetime", SESSION_LIFETIME * 60);
	if((int) $config->get('system', 'session-force-gc')) {
		ini_set("session.gc_probability", 1);
		ini_set("session.gc_divisor", 1);
	}
	ini_set("session.cookie_lifetime", "0");
	ini_set("session.use_cookies", "1");
	ini_set("session.use_only_cookies", "1");

	// kernel:cluster-cache-correction
	if(CLUSTER_CACHE_CORRECTION) {
		cacheFrontend::getInstance();
		clusterCacheSync::getInstance();
	}

	$remoteIP = getServer('REMOTE_ADDR');
	$blackIps = array();

	$result1 = l_mysql_query("SHOW TABLES LIKE 'cms3_objects'");
	$result2 = l_mysql_query("SHOW TABLES LIKE 'cms3_object_types'");
	if(mysql_num_rows($result1) && mysql_num_rows($result2)) {
		$result =	l_mysql_query("SELECT name FROM `cms3_objects` where type_id = (SELECT id FROM `cms3_object_types` where guid='ip-blacklist')");
		while($row = mysql_fetch_array($result)){
			$blackIps[] = $row[0];
		}
	}

	$ipList = $config->get('kernel', 'ip-blacklist');
	if(!empty($ipList) && $remoteIP !== null) {
		$ips = explode(",", $ipList);
		$blackIps = array_merge($blackIps, $ips);
	}

	foreach ($blackIps as $id => $blackIp) {
		$blackIp = trim($blackIp);
			if ($blackIp == $remoteIP) {
			$buffer = OutputBuffer::current('HTTPOutputBuffer');
			$buffer->contentType('text/html');
			$buffer->charset('utf-8');
			$buffer->status('403 Forbidden');
			$buffer->clear();
			$buffer->end();
		}
	}

	function umiAutoload($className) {
        showWorkTime("umiAutoload ".$className." start",2);
		global $includes;

		if ($className == "XSLTProcessor" && !class_exists("XSLTProcessor")){
			xslt_fatal();
		}
        
		//Debug section
		if(defined('INTERRUPT_DEPRECATED_CALL') && INTERRUPT_DEPRECATED_CALL) {
			$deprecatedClasses = array('umiSelection', 'umiSelectionsParser');
			if(in_array($className, $deprecatedClasses)) {
				$e = new coreException("Deprecated class \"{$className}\" called");
				traceException($e);
			}
		}

		if(isset($includes[$className])) {
			$files = $includes[$className];
			if(is_array($files))
            {
                foreach($files as $filePath)
                {
                    require_once $filePath;
                    showWorkTime("umiAutoload ".basename($filePath)." required",2);
                }
            }
		}
        showWorkTime("umiAutoload ".$className." end",2);
	}


	function initConfigConstants($ini) {
		$defineConstants = array(
			'system:db-driver' => array('DB_DRIVER', '%value%'),
			'system:version-line' => array('CURRENT_VERSION_LINE', '%value%'),
			'system:session-lifetime' => array('SESSION_LIFETIME', '%value%'),
			'system:default-date-format' => array('DEFAULT_DATE_FORMAT', '%value%'),
			'kernel:use-reflection-extension' => array('USE_REFLECTION_EXT', '%value%'),
			'kernel:cluster-cache-correction' => array('CLUSTER_CACHE_CORRECTION', '%value%'),
			'kernel:xslt-nested-menu' => array('XSLT_NESTED_MENU', '%value%'),
			'kernel:pages-auto-index' => array('PAGES_AUTO_INDEX', '%value%'),
			'kernel:enable-pre-auth' => array('PRE_AUTH_ENABLED', '%value%'),
			'kernel:ignore-module-names-overwrite' => array('IGNORE_MODULE_NAMES_OVERWRITE', '%value%'),
			'kernel:xml-format-output' => array('XML_FORMAT_OUTPUT', '%value%'),
			'kernel:selection-max-joins' => array('MAX_SELECTION_TABLE_JOINS', '%value%'),
			'kernel:property-value-mode' => array('XML_PROP_VALUE_MODE', '%value%'),
			'kernel:xml-macroses-disable' => array('XML_MACROSES_DISABLE', '%value%'),
			'kernel:selection-calc-found-rows-disable' => array('DISABLE_CALC_FOUND_ROWS', '%value%'),
			'kernel:sql-query-cache' => array('SQL_QUERY_CACHE', '%value%'),
			'seo:calculate-e-tag' => array('CALC_E_TAG', '%value%'),
			'seo:calculate-last-modified' => array('CALC_LAST_MODIFIED', '%value%')
		);

		foreach($defineConstants as $name => $const) {
			list($section, $variable) = explode(':', $name);
			$value = $const[1];

			if(is_string($value)) {
				$iniValue = isset($ini[$section][$variable]) ? $ini[$section][$variable] : "";
				$value = str_replace('%value%', $iniValue, $value);
			} else if (!$value && isset($const[2])) {
				$value = $const[2];
			}

			if(!defined($const[0])) {
				if($const[0] == 'CURRENT_VERSION_LINE' && !$value) {
					continue;
				}
				define($const[0], $value);
			}
		}
	}


	function initConfigConnections($ini) {
		$connections = array();

		foreach($ini['connections'] as $name => $value) {
			list($class, $pname) = explode('.', $name);
			if(!isset($connections[$class])) {
				$connections[$class] = array(
										'type'        => 'mysql',
										'host'		  => 'localhost',
										'login'       => 'root',
										'password'    => '',
										'dbname'      => 'umi',
										'port'	      => false,
										'persistent'  => false,
										'compression' => false);
			}
			$connections[$class][$pname] = $value;
		}

		$pool = ConnectionPool::getInstance();
		foreach($connections as $class => $con) {
				switch($con['type']) {
						default:
								$pool->setConnectionObjectClass();
				}

				if($con['dbname'] == '-=demo=-' || $con['dbname'] == '-=custom=-') {
					if($con['dbname'] == '-=demo=-') {
						require './demo-center.php';
					}

					$con['host'] = MYSQL_HOST;
					$con['login'] = MYSQL_LOGIN;
					$con['password'] = MYSQL_PASSWORD;
					$con['dbname'] = ($con['dbname'] == '-=custom=-') ? MYSQL_DB_NAME : DEMO_DB_NAME;
				}

				$pool->addConnection($class, $con['host'], $con['login'], $con['password'], $con['dbname'],
					($con['port'] !== false) ? intval($con['port']) : false,
					(bool) intval($con['persistent']) );
		}

		if(DB_DRIVER == "mysql") {
			$connection = ConnectionPool::getInstance()->getConnection();
			ini_set('mysql.trace_mode', false);
		}
	}

	function mysql_fatal() {
		require "./errors/mysql_failed.html";
		exit();
	}

	function xslt_fatal(){
		require ("./errors/xslt_failed.html");
		exit();
	}


	if (!defined('_C_ERRORS')) define('_C_ERRORS', true);

	error_reporting(DEBUG ? ~E_STRICT : E_ERROR);
	
	ini_set("display_errors", "1");

	function traceException($e) {
		global $message, $traceAsString;

		$message = $e->getMessage();
		$traceAsString = $e->getTraceAsString();

		header("HTTP/1.1 500 Internal Server Error");
		header("Content-type: text/html; charset=utf-8");
		header("Status: 500 Internal Server Error");
		require SYS_ERRORS_PATH . "exception.php";
		exit();
	}
	
	if (!defined('CRON')) set_exception_handler('traceException');

	function criticalErrorsBufferHandler($buffer) {
		if(isset($GLOBALS['memoryReserve'])) unset($GLOBALS['memoryReserve']);
		$errors = Array('Fatal', 'Parse');
		
		foreach($errors as $error) {
			if(strstr($buffer, "<br />\n<b>{$error} error</b>:") !== false) {
				$message = substr(trim(strip_tags($buffer)), strlen($error) + 9);
				$traceAsString  = "Backtrace can't be displayed";
				$e = new coreException($message);
				require SYS_ERRORS_PATH . 'exception.php';
				
				$errorBuffer = ob_get_contents();
				$buffer = substr($errorBuffer, strlen($buffer));
				break;
			}
		}
		return $buffer;
	}
	
	$GLOBALS['memoryReserve'] = str_repeat(" ", 1024);
	
	if(!defined("DEBUG") && function_exists("libxml_use_internal_errors")) {
	    libxml_use_internal_errors(true);
	}
	
	function checkXmlError($dom) {
	    if(defined("DEBUG") || !function_exists("libxml_get_last_error")) return;

		if($dom === false) {
			$error = libxml_get_last_error();
			libxml_clear_errors();
			
			$message = $error->message;
			$traceAsString = $error->file . "<br />in line " . $error->line . " column " . $error->column;
			
			require SYS_ERRORS_PATH . "exception.php";
			exit();
		}
	}
	
	function xsltErrorsHandler($errno, $errstr, $errfile, $errline, $e) {
	    if(defined("DEBUG") || !function_exists("libxml_get_last_error")) return;
		$message = $errfile;

		if($errline != 0 || $errno != 2) return;

		$message = "XSLT template in not correct.";
		$errors = libxml_get_errors();
			
		$traceAsString = "";
		foreach($errors as $error) {
			$traceAsString .= "<li>XSLT error: " . $error->message . "</li>";
		}
			
		require SYS_ERRORS_PATH . "exception.php";
		exit();
	}
	
	function errorsXsltListen() {
	    if(defined("DEBUG")) return;
		set_error_handler("xsltErrorsHandler");
		return error_reporting(~E_STRICT);
	}
	
	function errorsXsltCheck($er) {
	    if(defined("DEBUG")) return;
		error_reporting($er);
		restore_error_handler();
	}


	function system_is_allowed($module, $method = false, $element_id = false) {
		static $cache = Array();
		static $user_id = false;

		if($user_id == false) {
			$users_ext = cmsController::getInstance()->getModule("users");
			if($users_ext) {
				$user_id = $users_ext->user_id;
			}
		}

		$ck = md5($module . $method . $element_id);
		if(array_key_exists($ck, $cache)) return $cache[$ck];

		$pc = permissionsCollection::getInstance();
		$isSv = $pc->isSv($user_id);

		if($isSv) {
			return $cache[$ck] = true;
		}

		if($method == "config" || ($module == "config" && $method == false)) {
			return false;
		}

		if($element_id !== false && $element_id !== 0 && !is_null($element_id)) {
			list($r, $w) = $pc->isAllowedObject($user_id, $element_id);

			if(strstr($method, "edit") !== false) {
				return $cache[$ck] = $w;
			} else {
				return $cache[$ck] = $r;
			}
		}

		if($method !== false && $method) {
			if($module == "system" || $module == "core" || $module == "custom") return $cache[$ck] = true;
			return $cache[$ck] = $pc->isAllowedMethod($user_id, $module, $method);
		}

		if($module !== false) {
			return $cache[$ck] = $pc->isAllowedModule($user_id, $module);
		}
	}


	function system_get_tpl($mode = 'default') {
		$config = mainConfiguration::getInstance();
        showWorkTime("system mainconfig init");
		$controller = cmsController::getInstance();
        showWorkTime("system cmscontroller init");
		$dirPath = '';
		$fileName = '';
		$filePath = '';
		if ($controller->getCurrentMode() == 'admin' && $mode == 'current') {
			$type = 'xslt';
			$className = 'xslAdminTemplater';
			$fileName = 'main.xsl';
			$dirPath = $config->includeParam('templates.skins', array('skin' => system_get_skinName()));

			$permissions = permissionsCollection::getInstance();
			$userId = $permissions->getUserId();
			$isAllowed = $permissions->isAllowedMethod($userId, $controller->getCurrentModule(), $controller->getCurrentMethod());

			if((!$permissions->isAdmin() || !$isAllowed) && file_exists($dirPath . 'main_login.xsl')) {
				if($permissions->isAuth()) {
					$sqlWhere = "owner_id = {$userId}";
					$userGroups = umiObjectsCollection::getInstance()->getObject($userId)->getValue('groups');
					foreach ($userGroups as $userGroup) {
						$sqlWhere .= " or owner_id = {$userGroup}";
					}

					$sql = "SELECT `module` FROM cms_permissions WHERE (" . $sqlWhere . ") and (method = '' or method is null)";
					$result = l_mysql_query($sql);

					if (mysql_num_rows($result) !==0) {
						$regedit = regedit::getInstance();
						while ($row = mysql_fetch_array($result)){
							$module = $row[0];
							$method = $regedit->getVal("//modules/{$module}/default_method_admin");
							if ($permissions->isAllowedMethod($userId, $module, $method)) {
								def_module::redirect('http://' . $controller->getCurrentDomain()->getHost() . '/admin/'. $module . '/' . $method);
								break;
							}
						}
					}
				}
				$fileName = 'main_login.xsl';
			}
			$filePath = $dirPath . $fileName;
		}
		else {
			$templatesColl = templatesCollection::getInstance();
			$tpl = false;
			if ($template_id = getRequest('template_id')) {
				$tpl = $templatesColl->getTemplate($template_id);
			}
			if (!$tpl instanceof template) {
				$tpl = ($mode == 'current') ? $templatesColl->getCurrentTemplate() : $templatesColl->getDefaultTemplate();
			}
			if ($tpl instanceof template) {
				$fileName = $tpl->getFilename();
				$templateName = $tpl->getName();
				$type = $tpl->getType();
				if (!$type) {
					switch (array_pop(explode('.', $fileName))) {
						case "xsl":$type = 'xslt';break;
						case "tpl":$type = 'tpls';break;
					}
				}
				$templateDirPath = CURRENT_WORKING_DIR . '/templates/'.$templateName.'/'.$type.'/';
				switch ($type) {
					case "xslt":
						$dirPath = (file_exists($templateDirPath . $fileName)) ? $templateDirPath : $config->includeParam('templates.xsl');
						$className = 'xslTemplater';
						break;
					case "tpls":
						$dirPath = (file_exists($templateDirPath . 'content/' . $fileName)) ? $templateDirPath : $config->includeParam('templates.tpl');
						$className = 'tplTemplater';
						break;
					default :
						$dirPath = (file_exists($templateDirPath . $fileName)) ? $templateDirPath : '';
						$className = (file_exists(dirname(__FILE__) . '/' . $type . '/' . $type . 'Templater.php')) ? $type . 'Templater' : '';
				}
				if ($mode == 'streams') {
					$className = 'xslTemplater';
					$type      = 'xslt';
					$dirPath   = $config->includeParam('templates.xsl');
					$fileName  = 'sample.xsl';
				}
				if (system_is_mobile() && file_exists($dirPath . 'mobile/' . $fileName)) {
					$dirPath = $dirPath . 'mobile/';
				}
				$filePath = $dirPath . ($type == 'tpls' ? 'content/' : '') . $fileName;
			}
			else if ($mode == 'default' || $mode == 'streams') {
				$className = 'xslTemplater';
				$type      = 'xslt';
				$dirPath   = $config->includeParam('templates.xsl');
				$filePath  = $config->includeParam('templates.xsl') . 'sample.xsl';
			}
			else {
				$buffer = outputBuffer::current();
				$buffer->clear();
				$buffer->push(file_get_contents(SYS_ERRORS_PATH . 'no_design_template.html'));
				$buffer->end();
			}
		}
		$params = array(
			'class_name' => $className,
			'type'       => $type,
			'dir_path'   => $dirPath,
			'file_path'  => $filePath
		);
		return $params;
	}

	function system_get_skinName() {
		static $skinName;
		if ($skinName) return $skinName;

		$config = mainConfiguration::getInstance();
		$controller = cmsController::getInstance();

		$casualSkins = $config->getList('casual-skins');
		$methodName = $controller->getCurrentModule() . '::' . $controller->getCurrentMethod();
		foreach($casualSkins as $casualSkinName) {
			if(in_array($methodName, $config->get('casual-skins', $casualSkinName))) {
				return $skinName = $casualSkinName;
			}
		}

		$skins = $config->get('system', 'skins');

		if(isset($_GET['skin_sel']) || isset($_POST['skin_sel'])) {
			if(is_null($skin_sel = getArrayKey($_GET, 'skin_sel'))) {
				$skin_sel = getArrayKey($_POST, 'skin_sel');
			}
			setcookie('skin_sel', $skin_sel, time() + 3600*24*365, '/');
			if(in_array($skinName, $skins)) {
				return $skinName = $skin_sel;
			}
		}

		if(getCookie('skin_sel')) {
			if(in_array(getCookie('skin_sel'), $skins)) {
				return $skinName = getCookie('skin_sel');
			}
		}

		return $skinName = $config->get('system', 'default-skin');
	}

	function system_buildin_load($moduleName) {
		static $mc = Array();

		if(isset($mc[$moduleName])) {
			return $mc[$moduleName];
		}
		$config = mainConfiguration::getInstance();

		$modulePath = $config->includeParam('system.virtual-modules') . $moduleName . ".php";
		if(file_exists($modulePath)) {
			require $modulePath;
			if(class_exists($moduleName)) {
				return $mc[$moduleName] = new $moduleName;
			}
		}
		return false;
	}

	function system_remove_cache($alt) {
		$cacheFolder = ini_get('include_path') . "cache";
		$cacheFileName = md5($alt);
		$cacheFilePath = $this->cacheFolder . "/" . $this->cacheFileName;

		if(file_exists($cacheFilePath))
			return unlink(md5($cacheFilePath));
		else
			return false;
	}


	function system_checkSession() {
		if(is_array($_COOKIE))
			return array_key_exists("umicms_session", $_COOKIE);
		return false;
	}

	function system_setSession() {
		$sess_id = md5(time());
		$sessionLifetime = mainConfiguration::getInstance()->get('system', 'session-lifetime');
		$sessionLifetime = $sessionLifetime ? (60 * $sessionLifetime) : 36000;
		setcookie("umicms_session", $sess_id, time() + $sessionLifetime, "/");
		return $sess_id;
	}

	function system_removeSession() {
		setcookie("umicms_session", "", time() - 3600, "/");
	}

	function system_getSession() {
		if(is_array($_COOKIE))
			return $_COOKIE['umicms_session'];
		else
			return false;
	}

	function system_runSession() {
		if(!system_checkSession())
			return system_setSession();
		else
			return system_getSession();
	}



	function system_gen_password($length = 12, $avLetters = "\$#@^&!1234567890qwertyuiopasdfghjklzxcvbnmQWERTYUIOPASDFGHJKLZXCVBNM") {
			$npass = "";
			for($i = 0; $i < $length; $i++) {
				$npass .= $avLetters[rand(0, strlen($avLetters)-1)];
			}
			return $npass;
	}


	function truncStr($sSomeStr, $iLength="50", $sEndingStr="...", $bStripTags = false) {
		$sResult = $sSomeStr;
		if ($bStripTags) {
			$sResult = html_entity_decode(strip_tags($sResult), ENT_QUOTES, "UTF-8");
		}
		if ($iLength<=0) return '';
		if (wa_strlen($sSomeStr) > $iLength) {
			$iLength -= wa_strlen($sEndingStr);
			$sResult = wa_substr($sResult, 0, $iLength+1);
			$sResult = preg_replace('/\s+([^\s]+)?$/i', '', $sResult) . $sEndingStr;
		}
		return $sResult;
	}

	function toTimeStamp($ds) {

		if(is_numeric($ds)) return $ds;

		$day = "";
		$month = "";
		$year = "";
		$hours = "";
		$mins = "";

		$ds = trim($ds);

		if($ds == "сейчас") {
			return time();
		}

		$s = "[ \.\-\/\\\\]{1,10}";
		//for common formats...

		$ds = str_replace("-", " ", $ds);
		$ds = str_replace(",", " ", $ds);

		$ds = str_replace("\\'", " ", $ds);

		if(preg_match("/\d{2}\:\d{2}/", $ds, $temp)) {
			$ms = $temp[0];
			preg_replace("/\d{2}\:\d{2}/", "", $ds);

			list($hours, $mins) = explode(":", $ms);
		}

		$ds = preg_replace("/(\d{4})$s(\d{2})$s(\d{2})/im", "^\\3^ !\\2! ?\\1?", $ds);
		$ds = preg_replace("/(\d{1,2})$s(\d{1,2})$s(\d{2,4})/im", "^\\1^ !\\2! ?\\3?", $ds);


		//for uncommon formats

		$days = Array(
				'понедельник',
				'вторник',
				'среда',
				'четверг',
				'пятница',
				'суббота',
				'воскресенье'
				);

		$months = Array(
				'январь',
				'февраль',
				'март',
				'апрель',
				'май',
				'июнь',
				'июль',
				'август',
				'сентябрь',
				'октябрь',
				'ноябрь',
				'декабрь'
				);

		$months_vin = Array(
				'января',
				'февраля',
				'марта',
				'апреля',
				'мая',
				'июня',
				'июля',
				'августа',
				'сентября',
				'октября',
				'ноября',
				'декабря'
				);

		$months_short = Array(
				'янв',
				'фев',
				'мар',
				'апр',
				'май',
				'июн',
				'июл',
				'авг',
				'сен',
				'окт',
				'ноя',
				'дек'
				);

		$months_to = Array(
				'01',
				'02',
				'03',
				'04',
				'05',
				'06',
				'07',
				'08',
				'09',
				'10',
				'11',
				'12'
				);

		foreach($months as $k => $v)
			$months[$k] = "/" . $v . "/i";

		foreach($months_vin as $k => $v)
			$months_vin[$k] = "/" . $v . "/i";

		foreach($months_short as $k => $v)
			$months_short[$k] = "/" . $v . "/i";

		foreach($months_to as $k => $v) {
			$months_to[$k] = " !" . $v . "! ";
		}

		$ds = preg_replace($months, $months_to, $ds);
		$ds = preg_replace($months_vin, $months_to, $ds);
		$ds = preg_replace($months_short, $months_to, $ds);

		//let's convert year
		$years = Array(
				'/(\d{2,4})[ ]*года/i',
				'/(\d{2,4})[ ]*год/i',
				'/(\d{2,4})[ ]*г/i',
				'/(\d{4})/i',
				);

		$ds = preg_replace($years, "?\\1?", $ds);

		$ds = preg_replace("/[^!^\?^\d](\d{1,2})[^!^\?^\d]/i", "^\\1^", " ".$ds." ");


		if(preg_match("/\^(\d{1,2})\^/", $ds, $mt)) {
			$day = $mt[1];
			if(strlen($day) == 1)
				$day = "0" . $day;
		}

		if(preg_match("/!(\d{1,2})!/", $ds, $mt)) {
			$month = $mt[1];
			if(strlen($month) == 1)
				$month = "0" . $month;
		}

		if(preg_match("/\?(\d{2,4})\?/", $ds, $mt)) {
			$year = $mt[1];
			if(strlen($year) == 2) {
				$ss = (int) substr($year, 0, 1);
				if( ($ss >= 0 && $ss <= 4))
					$year = "20" . $year;
				else
					$year = "19" . $year;
			}
		}

		if($day > 31) {
			$t = $year;
			$year = $day;
			$day = $t;
		}

		if($month > 12) {
			$t = $month;
			$month = $day;
			$day = $t;
			unset($t);
		}


		$tds = trim(strtolower($ds));
		switch($tds) {

			case "сегодня":
					$ts = time();

					$year = date("Y", $ts);
					$month = date("m", $ts);
					$day = date("d", $ts);

					break;


			case "завтра":
					$ts = time() + (3600*24);

					$year = date("Y", $ts);
					$month = date("m", $ts);
					$day = date("d", $ts);

					break;
			case "вчера":
					$ts = time() - (3600*24);

					$year = date("Y", $ts);
					$month = date("m", $ts);
					$day = date("d", $ts);


					break;

			case "послезавтра":
					$ts = time() + (3600*48);

					$year = date("Y", $ts);
					$month = date("m", $ts);
					$day = date("d", $ts);

					break;
			case "позавчера":
					$ts = time() - (3600*48);

					$year = date("Y", $ts);
					$month = date("m", $ts);
					$day = date("d", $ts);


					break;
		}


		if(!$day) {
			$tds = str_replace(Array($year, $month), "", $ds);
			preg_match("/(\d{1,2})/", $tds, $tmp);
			$day = isset($tmp[1]) ? $tmp[1] : NULL;
		}

		if(!$month && !$day && !$year) return 0;
		if($day && !$month) {
			$month = $day;
			$day = 0;
		}
		return $timestamp = mktime((int) $hours, (int) $mins, 0, (int) $month, (int) $day, (int) $year);
	}


function translit($input, $mode = "R_TO_E") {
	$rusBig = Array( "Э", "Ч", "Ш", "Ё", "Ё", "Ж", "Ю", "Ю", "\Я", "\Я", "А", "Б", "В", "Г", "Д", "Е", "З", "И", "Й", "К", "Л", "М", "Н", "О", "П", "Р", "С", "Т", "У", "Ф", "Х", "Ц", "Щ", "Ъ", "Ы", "Ь");
	$rusSmall = Array("э", "ч", "ш", "ё", "ё","ж", "ю", "ю", "я", "я", "а", "б", "в", "г", "д", "е", "з", "и", "й", "к", "л", "м", "н", "о", "п", "р", "с", "т", "у", "ф", "х", "ц", "щ", "ъ", "ы", "ь" );
	$engBig = Array("E\'", "CH", "SH", "YO", "JO", "ZH", "YU", "JU", "YA", "JA", "A","B","V","G","D","E", "Z","I","J","K","L","M","N","O","P","R","S","T","U","F","H","C", "W","~","Y", "\'");
	$engSmall = Array("e\'", "ch", "sh", "yo", "jo", "zh", "yu", "ju", "ya", "ja", "a", "b", "v", "g", "d", "e", "z", "i", "j", "k", "l", "m", "n", "o", "p", "r", "s",  "t", "u", "f", "h", "c", "w", "~", "y", "\'");
	$rusRegBig = Array("Э", "Ч", "Ш", "Ё", "Ё", "Ж", "Ю", "Ю", "Я", "Я", "А", "Б", "В", "Г", "Д", "Е", "З", "И", "Й", "К", "Л", "М", "Н", "О", "П", "Р", "С", "Т", "У", "Ф", "Х", "Ц", "Щ", "Ъ", "Ы", "Ь");
	$rusRegSmall = Array("э", "ч", "ш", "ё", "ё", "ж", "ю", "ю", "я", "я", "а", "б", "в", "г", "д", "е", "з", "и", "й", "к", "л", "м", "н", "о", "п", "р", "с", "т", "у", "ф", "х", "ц", "щ", "ъ", "ы", "ь");
	$engRegBig = Array("E'", "CH", "SH", "YO", "JO", "ZH", "YU", "JU", "YA", "JA", "A", "B", "V", "", "D", "E", "Z", "I", "J", "K", "L", "M", "N", "O", "P", "R", "S", "T", "U", "F", "H", "C", "W", "~", "Y", "'");
	$engRegSmall = Array("e'", "ch", "sh", "yo", "jo", "zh", "yu", "ju", "ya", "ja", "a", "b", "v", "", "d", "e", "z", "i", "j", "k", "l", "m", "n", "o", "p", "r", "s", "t", "u", "f", "h", "c", "w", "~", "y", "'");


	$textar = $input;
	$res = $input;

	if($mode == "E_TO_R") {
		if ($textar) {
			for ($i=0; $i<sizeof($engRegSmall); $i++) {
				$textar = str_replace($engRegSmall[$i], $rusSmall[$i], $textar);
			}
			for ($i=0; $i<sizeof($engRegBig); $i++) {
				$textar = str_replace($engRegBig[$i], $rusBig[$i], $textar);
				$textar = str_replace($engRegBig[$i], $rusBig[$i], $textar);
			}
			$res = $textar;
		}
	}

	if($mode == "R_TO_E") {
		if ($textar) {
			$textar = str_replace($rusRegSmall, $engSmall, $textar);
			$textar = str_replace($rusRegBig, $engSmall, $textar);
			$res = strtolower($textar);
		}
	}

	$from = Array("/", "\\", "'", "\t", "\r\n", "\n", "\"", " ", "?", ".");
	$to = Array("", "", "", "", "", "", "", "_", "", "");

	$res = str_replace($from, $to, $res);

	$res = preg_replace("/[ ]+/", "_", $res);
	return $res;
}


function system_parse_short_calls($res, $element_id = false, $object_id = false, $scopeVariables = array()) {
	if(!is_string($res) || (strpos($res, "%") === false)) return $res;

	$controller = cmsController::getInstance();
	$objectsColl = umiObjectsCollection::getInstance();

	$scopeDump = (strpos($res, "%scope%") !== false);
	$element = NULL;
	$object = NULL;

	if($element_id === false && $object_id === false) {
		$element_id = $controller->getCurrentElementId();
	}

	if(strpos($res, "id%") !== false) {
		$res = str_replace("%id%", $element_id, $res);
		$res = str_replace("%pid%", $controller->getCurrentElementId(), $res);
	}

	if($element_id !== false) {
		if(!($element = umiHierarchy::getInstance()->getElement($element_id))) {
			return $res;
		} else {
			$object = $element->getObject();
		}
	}

	if($object_id !== false) {
		if(!($object = $objectsColl->getObject($object_id))) {
			return $res;
		}

	}

	if(!$object) return $res;

	$object_type_id = $object->getTypeId();
	$object_type = umiObjectTypesCollection::getInstance()->getType($object_type_id);

	if($scopeDump) {
		$fields = $object_type->getAllFields();
		foreach($fields as $field) {
			$name = $field->getName();
			$scopeVariables[$name] = $object->getValue($name);
		}
		$res = str_replace("%scope%", system_print_template_scope($scopeVariables), $res);
	}

	if(preg_match_all("/%([A-z0-9\-_]*)%/", $res, $out)) {
		foreach($out[1] as $obj_prop_name) {
			if($object_type->getFieldId($obj_prop_name) != false) {
				$val = $object->getValue($obj_prop_name);

				if(is_object($val)) {
					if($val instanceof umiDate) {
						$val = $val->getFormattedDate("U");
					}

					if($val instanceof umiFile) {
						$val = $val->getFilePath(true);
					}

					if($val instanceof umiHierarchy) {
						$val = $val->getName();
					}
				}

				if(is_array($val)) {
					$value = "";

					$sz = sizeof($val);
					for($i = 0; $i < $sz; $i++) {
						$cval = $val[$i];

						if(is_numeric($cval)) {
							if($obj = $objectsColl->getObject($cval)) {
								$cval = $obj->getName();
								unset($obj);
							}
							else continue;
						}

						if($cval instanceof umiHierarchyElement) {
							$cval = $cval->getName();
						}

						$value .= $cval;
						if($i < ($sz - 1)) $value .= ", ";
					}

					$val = $value;
				}

				if(strpos($val, "%") !== false ) {
					$val = templater::getInstance()->parseInput($val);
				}

				$res = str_replace("%" . $obj_prop_name . "%", $val, $res);
			}
		}
	}

	if(strpos($res, "id%") !== false) {
		$res = str_replace("%id%", $element_id, $res);
		$res = str_replace("%pid%", $controller->getCurrentElementId(), $res);
	}

	return $res;
}

function system_print_template_scope($scopeVariables, $scopeName = false) {
	list($block, $varLine, $macroLine) = def_module::loadTemplates("system/reflection", "scope_dump_block", "scope_dump_line_variable", "scope_dump_line_macro");

	$assembledLines = "";
	foreach($scopeVariables as $name => $value) {
		if($name == "#meta") continue;
		if(is_array($value)) {
			$tmp = str_replace("%name%", $name, $macroLine);
		} else {
			$tmp = $varLine;
			$tmp = str_replace("%name%", $name, $tmp);
			$tmp = str_replace("%type%", gettype($value), $tmp);
			$tmp = str_replace("%value%", htmlspecialchars($value), $tmp);
		}
		$assembledLines .= $tmp;
	}

	if(isset($scopeVariables["#meta"])) {
		$scopeName = isset($scopeVariables["#meta"]["name"]) ? $scopeVariables["#meta"]["name"] : "";
		$scopeFile = isset($scopeVariables["#meta"]["file"]) ? $scopeVariables["#meta"]["file"] : "";
	} else {
		$scopeName = "";
		$scopeFile = "";
	}

	$block = str_replace("%lines%", $assembledLines, $block);
	$block = str_replace("%block_name%", $scopeName, $block);
	$block = str_replace("%block_file%", $scopeFile, $block);
	$block = preg_replace("/%[A-z0-9_]+%/i", "", $block);
	return $block;
}

	function getPrintableTpl($_sTplName) {
		if(!isset($_GET['print'])) {
			return $_sTplName;
		}
		$sNewTplPath = substr($tpl_path, 0, strrpos($tpl_path, '.')) . '.print.tpl';
		return (file_exists('tpls/content/'.$sNewTplPath)) ? $sNewTplPath : $_sTplName;
	}

	function is_demo() {
		return defined('CURRENT_VERSION_LINE') and strtolower(CURRENT_VERSION_LINE) == 'demo';
	}

	function detectCharset($sStr) {
		if (preg_match("/[\x{0000}-\x{FFFF}]+/u", $sStr)) return 'UTF-8';
		$sAnswer = 'CP1251';
		if (!function_exists('iconv')) return $sAnswer;

		$arrCyrEncodings = array(
			'CP1251',
			'ISO-8859-5',
			'KOI8-R',
			'UTF-8',
			'CP866'
		);

		if(function_exists("mb_detect_encoding")) {
			return mb_detect_encoding($sStr, implode(", ",$arrCyrEncodings));
		} else {
			return "UTF-8";
		}
	}
	/**
	* Check allowed disk size for write N bytes
	*
	* @param mixed $bytes - bytes for write
	* @param mixed $dirs - directories, which summary in busy size
	* @return boolean true, if allowed, else false
	*/
	function checkAllowedDiskSize($bytes=false, $dirs = array('/images', '/files')) {
		if ($bytes==false) {
			return false;
		}
		$max_files_size = mainConfiguration::getInstance()->get('system', 'quota-files-and-images');
		if ($max_files_size==0) {
			return true;
		}

		$max_files_size = getBytesFromString($max_files_size);
		$busySize = getBusyDiskSize($dirs);

		return $max_files_size>=$busySize+$bytes;
	}

	/**
	* Return busy disk size in dirs
	*
	* @param array $dirs - directories for summ
	* @return int summary busy disk size in bytes
	*/
	function getBusyDiskSize($dirs = array('/images', '/files')) {
		clearstatcache();
		$busySize = 0;
		foreach($dirs as $dir) {
			$busySize += getDirSize(CURRENT_WORKING_DIR.$dir);
		}
		return $busySize;
	}

	function getBytesFromString($str) {
		if(empty($str)) return 0;

		$str = str_replace(' ', '', strtolower($str));

		$bytes = $str;
		if( strpos( $str, 'kb') ) {
			$bytes = (int) str_replace( 'kb', '', $str) * 1024;
		}
		if( strpos( $str, 'k') ) {
			$bytes = (int) str_replace( 'k', '', $str) * 1024;
		}
		if( strpos( $str, 'mb') ) {
			$bytes = (int) str_replace( 'mb', '', $str) * 1024 * 1024;
		}
		if( strpos( $str, 'm') ) {
			$bytes = (int) str_replace( 'm', '', $str) * 1024 * 1024;
		}
		if( strpos( $str, 'gb') ) {
			$bytes = (int) str_replace( 'gb', '', $str) * 1024 * 1024 * 1024;
		}
		if( strpos( $str, 'g') ) {
			$bytes = (int) str_replace( 'g', '', $str) * 1024 * 1024 * 1024;
		}
		return $bytes;
	}

	/**
	* Return summary busy size of directory
	*
	* @param string $path - path to directory
	* @return int at bytes
	*/
	function getDirSize($path) {
		$size = 0;

		if (substr($path, -1, 1) !== DIRECTORY_SEPARATOR) {
			$path .= DIRECTORY_SEPARATOR;
		}

		if (is_file($path)) {
			return filesize($path);
		} elseif (!is_dir($path)) {
			return false;
		}

		$queue = array($path);
		for ($i = 0, $j = count($queue); $i < $j; ++$i)
		{
			$parent = $i;
			if (is_dir($queue[$i]) && $dir = @dir($queue[$i])) {
				$subdirs = array();
				while (false !== ($entry = $dir->read())) {
					if ($entry == '.' || $entry == '..') {
						continue;
					}

					$path = $queue[$i] . $entry;
					if (is_dir($path)) {
						$path .= DIRECTORY_SEPARATOR;
						$subdirs[] = $path;
					} elseif (is_file($path)) {
						$size += filesize($path);
					}
				}

				unset($queue[0]);
				$queue = array_merge($subdirs, $queue);

				$i = -1;
				$j = count($queue);

				$dir->close();
				unset($dir);
			}
		}

		return $size;
	}

	function checkFileForReading($path, $aExt = array())
	{
		$path = realpath($path);

		if( !file_exists($path) ) {
			return false;
		}

		$path = str_replace("\\", "/", $path);
		$pathinfo = pathinfo($path);

		//print_R($pathinfo);die;
		if(strpos ($path, CURRENT_WORKING_DIR) !== 0 ) {
			 return false;
		}
		if( $pathinfo['filename'] == '.htaccess' || $pathinfo['filename'] == '.htpasswd') {
			 return false;
		}
		if( sizeof($aExt) && !in_array($pathinfo['extension'],$aExt)) {
			 return false;
		}

		return true;
	}

	function system_is_mobile() {
		$reg = "/(windows\sce|android|symbian|series60|ip[ao]d|phone" .
			"|blackberry|opera\sm[io][nb]i|netfront|obigo|maemo|[pc].brow" .
			"|up\.link|wap|^noki|^htc|^mot|ericsson|samsu|psp|ppc)/i";
		switch (false) {
			case (is_null(getServer('HTTP_PROFILE'))) : return true;
			case (is_null(getServer('HTTP_X_WAP_PROFILE'))) : return true;
			case (strpos(getServer('HTTP_ACCEPT'), 'vnd.wap') == false) : return true;
			case (preg_match($reg, getServer('HTTP_USER_AGENT')) == false) : return true;
			default : return false;
		}
	}



	interface iUmiField {
		public function getName();
		public function setName($name);

		public function getTitle();
		public function setTitle($title);

		public function getIsLocked();
		public function setIsLocked($isLocked);

		public function getIsInheritable();
		public function setIsInheritable($isInheritable);

		public function getIsVisible();
		public function setIsVisible($isVisible);

		public function getFieldTypeId();
		public function setFieldTypeId($fieldTypeId);

		public function getFieldType();

		public function getGuideId();
		public function setGuideId($guideId);

		public function getIsInSearch();
		public function setIsInSearch($isInSearch);

		public function getIsInFilter();
		public function setIsInFilter($isInFilter);

		public function getTip();
		public function setTip($tip);

		public function getIsRequired();
		public function setIsRequired($isRequired = false);

		public function getIsSortable();
		public function setIsSortable($sortable = false);

		public function getRestrictionId();
		public function setRestrictionId($restrictionId = false);

		public function getIsSystem();
		public function setIsSystem($isSystem = false);

		public function getDataType();
	};

	interface iUmiFieldType {
		public function getName();
		public function setName($name);

		public function getIsMultiple();
		public function setIsMultiple($isMultiple);

		public function getIsUnsigned();
		public function setIsUnsigned($isUnsigned);

		public function getDataType();
		public function setDataType($dataTypeStr);

		public static function getDataTypes();
		public static function getDataTypeDB($dataType);
		public static function isValidDataType($dataTypeStr);
	};

	interface iUmiFieldTypesCollection {
		public function addFieldType($name, $dataType = "string", $isMultiple = false, $isUnsigned = false);
		public function delFieldType($fieldTypeId);
		public function getFieldType($fieldTypeId);

		public function getFieldTypesList();
	};

	interface iUmiFieldsCollection {
		public function addField($name, $title, $fieldTypeId, $isVisible = true, $isLocked = false, $isInheritable = false);
		public function delField($field_id);
		public function getField($fieldId);
	};

	interface iUmiFieldsGroup {
		public function getName();
		public function setName($name);

		public function getTitle();
		public function setTitle($title);

		public function getTypeId();
		public function setTypeId($typeId);

		public function getOrd();
		public function setOrd($ord);

		public function getIsActive();
		public function setIsActive($isActive);

		public function getIsVisible();
		public function setIsVisible($isVisible);

		public function getIsLocked();
		public function setIsLocked($isLocked);

		public function getFields();

		public function attachField($fieldId);
		public function detachField($fieldId);

		public function moveFieldAfter($fieldId, $beforeFieldId, $group_id, $is_last);

		public static function getAllGroupsByName($fieldName);
	};

	interface iUmiObject {
		public function getName();
		public function setName($name);

		public function getIsLocked();
		public function setIsLocked($isLocked);

		public function getTypeId();
		public function getTypeGUID();
		public function setTypeId($typeId);

		public function getPropGroupId($groupName);
		public function getPropGroupByName($groupName);
		public function getPropGroupById($groupId);

		public function getPropByName($propName);
		public function getPropById($propId);

		public function isPropertyExists($id);

		public function isFilled();

		public function getValue($propName);
		public function setValue($propName, $propValue);

		public function setOwnerId($ownerId);
		public function getOwnerId();
	};

	interface iUmiObjectProperty {
		public function getValue();
		public function setValue($value);
		public function resetValue();

		public function getName();
		public function getTitle();

		public function getIsMultiple();
		public function getIsUnsigned();
		public function getDataType();
		public function getIsLocked();
		public function getIsInheritable();
		public function getIsVisible();

		public static function filterOutputString($string);
		public static function filterCDATA($string);

		public function getObject();
		public function getField();
	};

	interface iUmiObjectType {
		public function addFieldsGroup($name, $title, $isActive = true, $isVisible = true);
		public function delFieldsGroup($fieldGroupId);

		public function getFieldsGroupByName($fieldGroupName);

		public function getFieldsGroup($fieldGroupId);
		public function getFieldsGroupsList($showDisabledGroups = false);

		public function getName();
		public function setName($name);

		public function setIsLocked($isLocked);
		public function getIsLocked();

		public function setIsGuidable($isGuidable);
		public function getIsGuidable();

		public function setIsPublic($isPublic);
		public function getIsPublic();

		public function setHierarchyTypeId($hierarchyTypeId);
		public function getHierarchyTypeId();

		public function getParentId();

		public function setFieldGroupOrd($groupId, $newOrd, $isLast);


		public function getFieldId($fieldName);

		public function getAllFields($returnOnlyVisibleFields = false);

		public function getModule();
		public function getMethod();
	};

	interface iUmiObjectTypesCollection {
		public function addType($parentId, $name, $isLocked = false);
		public function delType($typeId);

		public function getType($typeId);
		public function getSubTypesList($typeId);

		public function getParentClassId($typeId);
		public function getChildClasses($typeId);

		public function getGuidesList($publicOnly = false);

		public function getTypesByHierarchyTypeId($hierarchyTypeId, $ignoreMicroCache = false);
		public function getTypeByHierarchyTypeId($hierarchyTypeId, $ignoreMicroCache = false);

		public function getBaseType($typeName, $typeExt = "");
	};

	interface iUmiObjectsCollection {
		public function getObject($objectId);
		public function addObject($name, $typeId, $isLocked = false);
		public function delObject($objectId);

		public function cloneObject($iObjectId);

		public function getGuidedItems($guideId);

		public function unloadObject($objectId);
	};


	interface iDomain {
		public function getIsDefault();
		public function setIsDefault($isDefault);

		public function addMirrow($mirrowHost);
		public function delMirrow($mirrowId);

		public function getMirrowId($mirrowHost);
		public function getMirrow($mirrowId);

		public function getMirrowsList();
		public function delAllMirrows();


		public function isMirrowExists($mirrowId);

		public function getDefaultLangId();
		public function setDefaultLangId($langId);
	};

	interface iDomainMirrow {
		public function getHost();
		public function setHost($host);
	};

	interface iDomainsCollection {
		public function addDomain($host, $defaultLangId, $isDefault = false);
		public function delDomain($domainId);
		public function getDomain($domainId);

		public function getDefaultDomain();
		public function setDefaultDomain($domainId);

		public function getDomainId($host, $useMirrows = true);

		public function getList();
	};

	interface iLang {
		public function getTitle();
		public function setTitle($title);

		public function getPrefix();
		public function setPrefix($prefix);

		public function getIsDefault();
		public function setIsDefault($isDefault);
	};

	interface iLangsCollection {
		public function addLang($prefix, $title, $isDefault = false);
		public function delLang($langId);

		public function getDefaultLang();
		public function setDefault($langId);

		public function getLangId($prefix);
		public function getLang($langId);

		public function getList();

		public function getAssocArray();
	};

	interface iTemplate {
		/**
		 * Получить директорию с ресурсами для шаблона дизайна
		 * @return string
		 */
		public function getResourcesDirectory();

		/**
		 * Получть полный путь к шаблону дизайна
		 * @return string
		 */
		public function getFilePath();

		public function getFilename();
		public function setFilename($filename);

		public function getTitle();
		public function setTitle($title);

		public function getDomainId();
		public function setDomainId($domainId);

		public function getLangId();
		public function setLangId($langId);

		public function getIsDefault();
		public function setIsDefault($isDefault);

		public function getUsedPages();
		public function setUsedPages($elementIdArray);
	};

	interface iTemplatesCollection {
		public function addTemplate($filename, $title, $domainId = false, $langId = false, $isDefault = false);
		public function delTemplate($templateId);


		public function getDefaultTemplate($domain_id = false, $lang_id = false);
		public function setDefaultTemplate($template_id, $domain_id = false, $lang_id = false);

		public function getTemplatesList($domainId, $langId);

		public function getTemplate($templateId);
	};

	interface iUmiHierarchy {
		public function addElement($relId, $hierarchyTypeId, $name, $alt_name, $objectTypeId = false, $domainId = false, $langId = false, $templateId = false);
		public function getElement($elementId, $ignorePermissions = false, $ignoreDeleted = false);
		public function delElement($elementId);

		public function copyElement($elementId, $newRelId, $copySubPages = false);
		public function cloneElement($elementId, $newRelId, $copySubPages = false);


		public function getDeletedList();

		public function restoreElement($elementId);
		public function removeDeletedElement($elementId);
		public function removeDeletedAll();


		public function getParent($elementId);
		public function getAllParents($elementsId, $selfInclude = false);

		public function getChilds($elementId, $allowUnactive = true, $allowUnvisible = true, $depth = 0, $hierarchyTypeId = false, $domainId = false);
		public function getChildsCount($elementId, $allowUnactive = true, $allowUnvisible = true, $depth = 0, $hierarchyTypeId = false, $domainId = false);

		public function getPathById($elementId, $ignoreLang = false, $ignoreIsDefaultStatus = false);
		public function getIdByPath($elementPath, $showDisabled = false, &$errorsCount = 0);

		public static function compareStrings($string1, $string2);
		public static function convertAltName($alt_name, $separator = false);
		public static function getTimeStamp();

		public function getDefaultElementId($langId = false, $domainId = false);

		public function moveBefore($elementId, $relId, $beforeId = false);
		public function moveFirst($elementId, $relId);

		public function getDominantTypeId($elementId);

		//public function applyFilter(umiHierarchyFilter);

		public function addUpdatedElementId($elementId);
		public function getUpdatedElements();

		public function unloadElement($elementId);

		public function getElementsCount($module, $method = "");

		public function forceAbsolutePath($bIsForced = true);

		public function getObjectInstances($objectId, $bIgnoreDomain = false, $bIgnoreLang = false, $bIgnoreDeleted = false);

		public function getLastUpdatedElements($limit, $updateTimeStamp = 0);

		public function checkIsVirtual($elementIds);
	};

	interface iUmiHierarchyElement {
		public function getIsDeleted();
		public function setIsDeleted($isDeleted = false);

		public function getIsActive();
		public function setIsActive($isActive = true);

		public function getIsVisible();
		public function setIsVisible($isVisible = true);

		public function getTypeId();
		public function setTypeId($typeId);

		public function getLangId();
		public function setLangId($langId);

		public function getTplId();
		public function setTplId($tplId);

		public function getDomainId();
		public function setDomainId($domainId);

		public function getUpdateTime();
		public function setUpdateTime($timeStamp = 0);

		public function getOrd();
		public function setOrd($ord);

		public function getRel();
		public function setRel($rel_id);

		public function getObject();
		public function setObject(umiObject $object);

		public function setAltName($altName, $autoConvert = true);
		public function getAltName();

		public function setIsDefault($isDefault = true);
		public function getIsDefault();

		public function getParentId();

		public function getValue($propName, $params = NULL);
		public function setValue($propName, $propValue);

		public function getFieldId($FieldName);

		public function getName();
		public function setName($name);

		public function getObjectTypeId();

		public function getHierarchyType();

		public function getObjectId();


		public function getModule();
		public function getMethod();
	};

	interface iUmiHierarchyType {
		public function getName();
		public function setName($name);

		public function getTitle();
		public function setTitle($title);

		public function getExt();
		public function setExt($ext);
	};

	interface iUmiHierarchyTypesCollection {
		public function addType($name, $title, $ext = "");
		public function getType($typeId);
		public function delType($typeId);
		public function getTypeByName($typeName, $extName = false);

		public function getTypesList();
	};


	interface iXmlTranslator {

		public function __construct(DOMDocument $dom);
		
		public function translateToXml(DOMElement $rootNode, $userData);
		
		public static function getSubKey($key);
		public static function getRealKey($key);

	};


	interface iOutputBuffer {
		static public function current($bufferClassName = false);
		public function push($data);
		public function calltime();
		public function content();
		public function length();
		public function clear();
		public function send();
		public function end();
		public static function contentGenerator($generatorType = null);
	};


	abstract class outputBuffer implements iOutputBuffer {
		private static $buffers = array(), $current = false;

		final static public function current($bufferClassName = false) {
		showWorkTime("buffer current init",2);
		$buffers = &self::$buffers;
        showWorkTime("buffer current self done",2);
			if(!$bufferClassName) {
				if(self::$current) {
					$bufferClassName = self::$current;
				} else {
					throw new coreException('No output buffer selected');
				}
			}
			showWorkTime("buffer not exists class",2);
			self::$current = $bufferClassName;
			showWorkTime("buffer self current initiated",2);

			if(isset($buffers[$bufferClassName]) == false) {
				if(class_exists($bufferClassName)) {
					$buffer = new $bufferClassName;
					showWorkTime("buffer new bufferClassName initiated",2);
					if($buffer instanceof iOutputBuffer) {
						$buffers[$bufferClassName] = $buffer;
						showWorkTime("buffers array element initiated",2);
					} else {
						throw new coreException("Output buffer class \"{$bufferClassName}\" must implement iOutputBuffer");
					}
				} else {
					throw new coreException("Output buffer of class \"{$bufferClassName}\" not found");
				}
			}
			showWorkTime("buffer current end",2);

			return $buffers[$bufferClassName];
		}


		//Methods useful for extending
		protected $buffer = "", $invokeTime;

		public function __construct() { $this->invokeTime = microtime(true); }

		public function clear() { $this->buffer = ""; }

		public function length() { return strlen($this->buffer); }

		public function content() { return $this->buffer; }

		public function push($data) { $this->buffer .= $data; }

		public function end() { $this->send(); }

		public function calltime() { return round(microtime(true) - $this->invokeTime, 6);  }

		public function __call($method, $params) { return null; }

		public function redirect($url, $status = '301 Moved Permanently') { }

		/**
		 * @static
		 * Возвращает / устанавливает название генератора контента
		 * Используется для вывода в generate time блоке
		 * @param string|null $generatorType
		 *
		 * @return string|null
		 */
		public static function contentGenerator($generatorType = null) {
			static $contentGenerator = null;
			if (is_null($generatorType)) {
				return $contentGenerator;
			}
			return $contentGenerator = $generatorType;
		}

		public function __destruct() {
			$this->send();
		}
	};


	abstract class baseException extends Exception {
		protected $strcode, $id;

		public static $catchedExceptions = Array();
		
		public function __construct ($message, $code = 0, $strcode = "") {
			baseException::$catchedExceptions[$this->getId()] = $this;
			$this->strcode = $strcode;
			$message = def_module::parseTPLMacroses($message);
			parent::__construct($message, $code);
		}
		
		public function getStrCode() {
			return (string) $this->strcode;
		}
		
		public function unregister() {
			$catched = baseException::$catchedExceptions;
			$id = $this->getId();
			
			if(isset($catched[$id])) {
				unset($catched[$id]);
			}
		}
		
		protected function getId() {
			static $id = 0;
			if(is_null($this->id))  {
				$this->id = $id++;
			}
			return $this->id;
		}
	};


	class coreException extends baseException {};
	
	class coreBreakEventsException extends coreException {};

	class selectorException extends coreException {};


/**
 * Класс исключения, связаного с бд
 * Фатально по своей природе
 */
class databaseException extends coreException {};


	class privateException extends baseException {};

	class wrongParamException extends privateException {};
	
	class errorPanicException extends Exception {};
	
	class breakException extends Exception {};
	
	
	abstract class fieldRestrictionException extends privateException {};
	
	class wrongValueException extends fieldRestrictionException {};
	
	class valueRequiredException extends fieldRestrictionException {};


	class publicException extends baseException {};

	class publicAdminException extends publicException {};

	class expectElementException extends publicAdminException {};
	class expectObjectException extends publicAdminException {};
	class expectObjectTypeException extends publicAdminException {};
	
	class requireAdminPermissionsException extends publicAdminException {};
	class requreMoreAdminPermissionsException extends publicAdminException {};
	class requireAdminParamException extends publicAdminException {};
	class wrongElementTypeAdminException extends publicAdminException {};
	class publicAdminPageLimitException extends publicAdminException {};
	class publicAdminLicenseLimitException extends publicAdminException {};
	
	class maxIterationsExeededException extends publicException {};
	
	class umiRemoteFileGetterException extends publicException {};
	
	class xsltOnlyException extends publicException {
		public function __construct ($message = "", $code = 0, $strcode = "") {
			parent::__construct(getLabel('error-only-xslt-method'));
		}
	};
	
	class tplOnlyException extends publicException {
		public function __construct ($message = "", $code = 0, $strcode = "") {
			parent::__construct(getLabel('error-only-tpl-method'));
		}
	};


	interface iRegedit {
		public function getKey($keyPath, $rightOffset = 0);

		public function getVal($keyPath);
		public function setVar($keyPath, $value);
		public function setVal($keyPath, $value);

		public function delVar($keyPath);

		public function getList($keyPath);
	};



class regedit extends singleton implements iRegedit {
	protected $cacheFilePath, $cache = Array(), $cacheSaved = false;


	public static function getInstance($c = NULL) {
		return parent::getInstance(__CLASS__);
	}


	public function getKey($path, $rightOffset = 0) {
		static $cache = array();
		$path = trim($path, "/");

		if(isset($this->cache['keys'][$path])) {
			return $this->cache['keys'][$path];
		}

		$keyId = 0; $previousPaths = array();
		foreach(explode("/", $path) as $key) {
			$key = l_mysql_real_escape_string($key);
			$previousPaths[] = $key;
			$currentKey = implode('/', $previousPaths);

			if(isset($cache[$currentKey])) {
				$keyId = $cache[$currentKey];
				continue;
			}

			$sql = "SELECT id FROM cms_reg WHERE rel = '$keyId' AND var = '{$key}'";
			$result = l_mysql_query($sql, true);
			if(mysql_num_rows($result)) {
				list($keyId) = mysql_fetch_row($result);
				$cache[$currentKey] = $keyId;
			} else {
				return $this->cache['keys'][$path] = false;
			}
		}
		return $this->cache['keys'][$path] = (int) $keyId;
	}

	public function getVal($path) {
		$keyId = $this->getKey($path);

		if(isset($this->cache['values'][$path])) {
			return $this->cache['values'][$path];
		}

		if($keyId) {
			if(isset($this->cache['values'][$keyId])) {
				return $this->cache['values'][$keyId];
			}
			$this->cacheSaved = false;

			$sql = "SELECT val FROM cms_reg WHERE id = '{$keyId}'";
			$result = l_mysql_query($sql, true);

			list($value) = mysql_fetch_row($result);
			return $this->cache['values'][$keyId] = $value;
		} else {
			return $this->cache['values'][$path] = false;
		}
	}

	public function setVar($path, $value) {
		return $this->setVal($path, $value);
	}

	public function setVal($path, $value) {
		if(defined('CURRENT_VERSION_LINE') && CURRENT_VERSION_LINE == 'demo') {
			return false;
		}

		$this->resetCache();
		$keyId = $this->getKey($path);
		if($keyId == false) {
			$keyId = $this->createKey($path);
		}

		$value = l_mysql_real_escape_string($value);
		$sql = "UPDATE cms_reg SET val = '{$value}' WHERE id = '{$keyId}'";
		l_mysql_query($sql);

		$this->resetCache();
	}

	public function delVar($path) {
		if(defined('CURRENT_VERSION_LINE') && CURRENT_VERSION_LINE == 'demo') {
			return false;
		}

		$keyId = $this->getKey($path);
		if($keyId) {
			$sql = "DELETE FROM cms_reg WHERE rel = '{$keyId}' OR id = '{$keyId}'";
			l_mysql_query($sql, true);
			$this->resetCache();
			return true;
		} else {
			return false;
		}
	}

	public function getList($path) {
		if(isset($this->cache['lists'][$path])) {
			return $this->cache['lists'][$path];
		}

		$keyId = $this->getKey($path);

		if($path == "//") {
			$keyId = 0;
		}

		if($keyId || $path == "//") {
			if(isset($this->cache['lists'][$keyId])) {
				return $this->cache['lists'][$keyId];
			}
			$this->cacheSaved = false;

			$sql = "SELECT id, var, val FROM cms_reg WHERE rel = '{$keyId}' ORDER BY id ASC";
			$result = l_mysql_query($sql, true);

			$values = Array();
			while(list($id, $var, $val) = mysql_fetch_array($result)) {
				$values[] = Array($var, $val);
			}
			return $this->cache['lists'][$keyId] = $values;
		} else {
			return $this->cache['lists'][$path] = false;
		}
	}

	final public static function checkSomething($a, $b, $return=false) {
		$trial_lifetime = 3600*24*45;

		if(($_SERVER['HTTP_HOST'] == 'localhost' || $_SERVER['HTTP_HOST'] == 'subdomain.localhost') && $_SERVER['SERVER_ADDR'] == '127.0.0.1') {
			return true;
		}

		if(substr($_SERVER['HTTP_HOST'], strlen($_SERVER['HTTP_HOST']) - 4, 4) == "cvs5") {
			return true;
		}

		$commerce_enc = self::getInstance()->getVal("//modules/autoupdate/system_edition")=='commerce_enc';

		foreach($b as $version_line => $c3) {
			$is_valid = (bool) (substr($a, 12, strlen($a) - 12) == $c3);

			if($is_valid === true) {
				define("CURRENT_VERSION_LINE", $version_line);

				if($version_line == "trial" || $commerce_enc) {
					$create_time = filectime(__FILE__);
					$current_time = time();

					if(file_exists(SYS_CACHE_RUNTIME . "trash")) {
						unlink(SYS_CACHE_RUNTIME . "trash");
					}

					if(($current_time - $create_time) > $trial_lifetime){
						if ($return) {
							return false;
						}
						else {
						include CURRENT_WORKING_DIR . "/errors/trial_expired.html";
						exit();
					}
				}
				}
				return true;
			}
		}
		return false;
	}


	final public function checkSelfKeycode() {
		$keycode = $this->getVal("//settings/keycode");

		if (strlen($keycode)==0) {
			return false;
		}

		$codename = $this->getVal("//settings/system_edition");

		$pro = array('commerce', 'business', 'corporate', 'commerce_enc', 'business_enc', 'corporate_enc');
		$internalCodeName = in_array($codename, $pro) ? 'pro' : $codename;

		$b = array($internalCodeName => umiTemplater::getSomething($internalCodeName));

		return self::checkSomething($keycode, $b, true);
	}

	public function getDaysLeft() {
		return 45 - floor((time() - filectime(__FILE__)) / (3600*24));
	}


	protected function __construct() {
		$config = mainConfiguration::getInstance();
		$this->cacheFilePath = $config->includeParam('system.runtime-cache') . 'registry';
		$this->loadCache();
	}

	public function __destruct() {
		if(!$this->cacheSaved) {
			$this->saveCache();
		}
	}

	protected function loadCache() {
		$cacheFrontend = cacheFrontend::getInstance();

		if($cacheFrontend->getIsConnected()) {
				if($cache = $cacheFrontend->loadSql("registry")) {
					$this->cache = unserialize($cache);
					$this->cacheSaved = true;
					return;
				}
		}

		if(file_exists($this->cacheFilePath)) {
			$cache = unserialize(file_get_contents($this->cacheFilePath));
			if(is_array($cache)) {
				$this->cacheSaved = true;
				$this->cache = $cache;
			}
		}
	}

	protected function saveCache() {
		if(is_array($this->cache)) {
			if(is_dir(dirname($this->cacheFilePath))) {
				file_put_contents($this->cacheFilePath, serialize($this->cache));
			}
			if(cacheFrontend::getInstance()->getIsConnected()) {
				cacheFrontend::getInstance()->saveSql("registry", serialize($this->cache));
			}
		}
		$this->cacheSaved = true;
	}

	protected function createKey($path) {
		$path = trim($path, "/");
		$subKeyPath = "//";

		$relId = 0;
		foreach(explode("/", $path) as $key) {
			$subKeyPath .= $key . "/";


			if($keyId = $this->getKey($subKeyPath)) {
				$relId = $keyId;
			} else {
				$sql = "INSERT INTO cms_reg (rel, var, val) VALUES ('$relId', '{$key}', '')";
				l_mysql_query($sql, true);
				$relId = $keyId = (int) l_mysql_insert_id();
			}
		}
		return $keyId;
	}

	protected function resetCache($keys = false) {
		if(is_array($keys)) {
			foreach($keys as $key) {
				if(isset($this->cache[$key])) {
					unset($this->cache[$key]);
				}
			}
		} else {
			$this->cache = Array();
		}

		$this->saveCache();
	}
};



	interface iSearchModel {
		public function runSearch($searchString, $searchTypesArray = NULL);
		public function getContext($elementId, $searchString);
		public function getIndexPages();
		public function getAllIndexablePages();
		public function getIndexWords();
		public function getIndexWordsUniq();
		public function getIndexLast();
		public function truncate_index();
		public function index_all($limit = false);
		public function index_item($elementId);

		public function index_items($elementId);
		public function unindex_items($elementId);
		
		public function suggestions($string, $limit = 10);
	};


/**
	* Класс для работы с поисковой базой по сайту.
*/
	class searchModel extends singleton implements iSingleton, iSearchModel {
		public function __construct() {
		}

		/**
			* Получить экземпляр класса
			* @return searchModel экземпляр класса
		*/
		public static function getInstance($c = NULL) {
			return parent::getInstance(__CLASS__);
		}

		/**
			* Проиндексировать все страницы, где дата последней модификации меньше даты последней индексации
			* @param Integer $limit = false ограничить количество индексируемых страниц
			* @return Integer количество проиндексированных страниц
		*/
		public function index_all($limit = false, $lastId = 0) {
			$total = 0;

			$sql = "SELECT id, updatetime FROM cms3_hierarchy WHERE is_deleted = '0' AND is_active = '1' AND id > '{$lastId}' ORDER BY id LIMIT 1";
			$result = l_mysql_query($sql, true);

			while(list($element_id, $updatetime) = mysql_fetch_row($result)) {
				++$total;
				$lastId = $element_id;
				$sql = "SELECT id, updatetime FROM cms3_hierarchy WHERE is_deleted = '0' AND is_active = '1' and id > '{$element_id}' ORDER BY id LIMIT 1";
				$result = l_mysql_query($sql, true);

				if(!$this->elementIsReindexed($element_id, $updatetime)) {
					$indexResult = $this->index_item($element_id, true);
					}

					if(($limit !== false) && (--$limit == 0)) {
						break;
					}
				}

			$sql = "SELECT COUNT(*) FROM `cms3_search` LIMIT 1";
			$current = mysql_result(l_mysql_query($sql, true), 0);

			return array("current"=>$current, "lastId"=>$lastId);
			}

		/**
			* Проиндексировать определенную страницу
			* @param Integer $element_id id страницы
			* @param Boolean $is_manual = false устаревший параметр, больше не используется
		*/
		public function index_item($element_id, $is_manual = false) {
			if(defined("UMICMS_CLI_MODE") || defined("DISABLE_SEARCH_REINDEX")) {
				return false;
			}

			l_mysql_query("START TRANSACTION /* Reindexing element #{$element_id} */", true);
			$index_data = $this->parseItem($element_id);
			l_mysql_query("COMMIT", true);

			return $index_data;
		}

		/**
			* Узнать, индесировалась ли страница $element_id после даты $updatetime
			* @param Integer $element_id id страницы
			* @param Integer $updatetime требуемое время индексации
			* @return Boolean результат операции
		*/
		public function elementIsReindexed($element_id, $updatetime) {
			$sql = "SELECT COUNT(*) FROM cms3_search WHERE rel_id = '{$element_id}' AND indextime > '{$updatetime}'";
			$result = l_mysql_query($sql, true);
			list($c) = mysql_fetch_row($result);

			return (bool) $c;
		}

		public function parseItem($element_id) {
			if(!($element = umiHierarchy::getInstance()->getElement($element_id, true, true))) {
				return false;
			}

			if($element->getValue("is_unindexed")) {
				$domain_id = $element->getDomainId();
				$lang_id = $element->getLangId();
				$type_id = $element->getTypeId();

				$sql = "SELECT COUNT(*) FROM cms3_search WHERE rel_id = '{$element_id}'";
				list($c) = mysql_fetch_row(l_mysql_query($sql, true));

		    		if(!$c) {
					$sql = "INSERT INTO cms3_search (rel_id, domain_id, lang_id, type_id) VALUES('{$element_id}', '{$domain_id}', '{$lang_id}', '{$type_id}')";
					l_mysql_query($sql, true);
				}
				return false;
			}

			$index_fields = Array();

			$type_id = $element->getObject()->getTypeId();
			$type = umiObjectTypesCollection::getInstance()->getType($type_id);

			$field_groups = $type->getFieldsGroupsList();
			foreach($field_groups as $field_group_id => $field_group) {
				foreach($field_group->getFields() as $field_id => $field) {
					if($field->getIsInSearch() == false) continue;

					$field_name = $field->getName();
					$val = $element->getValue($field_name);
					$data_type = $field->getFieldType()->getDataType();

					if($data_type) {
						if(is_array($val)) {
							if($data_type == 'relation') {
								foreach($val as $i => $v) {
									if($item = selector::get('object')->id($v)) {
										$val[$i] = $item->name;
										unset($item);
									}
								}
							}
							$val = implode(' ', $val);
						} else {
							if(is_object($val)) {
								continue;
							}

							if($data_type == 'relation') {
								if($item = selector::get('object')->id($val)) {
									$val = $item->name;
								}
							}
						}
					}

					if(is_null($val) || !$val) continue;


					// kill macroses
					$val = preg_replace("/%([A-z_]*)%/m", "", $val);
					$val = preg_replace("/%([A-zЂ-пРђ-СЏ \/\._\-\(\)0-9%:<>,!@\|'&=;\?\+#]*)%/m", "", $val);

					$index_fields[$field_name] = $val;
				}
			}

			$index_image = $this->buildIndexImage($index_fields);
			$this->updateSearchIndex($element_id, $index_image);
		}

		public function buildIndexImage($indexFields) {
			$img = Array();

			$weights = Array(
				'h1' => 5,
				'title' => 5,
				'meta_keywords' => 3,
				'meta_descriptions' => 3,
				'tags' => 3
			);

			foreach($indexFields as $fieldName => $str) {
				$arr = $this->splitString($str);

				if(isset($weights[$fieldName])) {
					$weight = (int) $weights[$fieldName];
				} else {
					$weight = 1;
				}

				foreach($arr as $word)  {
					if(array_key_exists($word, $img)) {
						$img[$word] += $weight;
					} else {
						$img[$word] = $weight;
					}
				}
			}
			return $img;
		}

		public static function splitString($str) {
			if(is_object($str)) {    //TODO: Temp
				return NULL;
			}

			$to_space = Array("&nbsp;", "&quote;", ".", ",", "?", ":", ";", "%", ")", "(", "/", 0x171, 0x187, "<", ">", "-");

			$str = str_replace(">", "> ", $str);
			$str = str_replace("\"", " ", $str);
			$str = strip_tags($str);
			$str = str_replace($to_space, " ", $str);
			$str = preg_replace("/([ \t\r\n]{1-100})/u", " ", $str);
			//$str = wa_strtolower($str);
			$tmp = explode(" ", $str);

			$res = Array();
			foreach($tmp as $v) {
				$v = trim($v);

				if(wa_strlen($v) <= 2) continue;

				$res[] = $v;
			}

			return $res;
		}

		public function updateSearchIndex($element_id, $index_image) {
			$element = umiHierarchy::getInstance()->getElement($element_id, true);

			$domain_id = $element->getDomainId();
			$lang_id = $element->getLangId();
			$type_id = $element->getTypeId();

			$sql = "SELECT COUNT(*) FROM cms3_search WHERE rel_id = '{$element_id}'";
			list($c) = mysql_fetch_row(l_mysql_query($sql, true));

			if(!$c) {
				$sql = "INSERT INTO cms3_search (rel_id, domain_id, lang_id, type_id) VALUES('{$element_id}', '{$domain_id}', '{$lang_id}', '{$type_id}')";
				l_mysql_query($sql, true);
			}

			$sql = "DELETE FROM cms3_search_index WHERE rel_id = '{$element_id}'";
			l_mysql_query($sql, true);

			$sql = "INSERT INTO cms3_search_index (rel_id, weight, word_id, tf) VALUES ";
			$n = 0;

			$total_weight = array_sum($index_image);
			foreach($index_image as $word => $weight) {
				if(($word_id = $this->getWordId($word)) == false) continue;
				$TF = $weight / $total_weight;
				$sql .= "('{$element_id}', '{$weight}', '{$word_id}', '{$TF}'), ";
				++$n;
			}

			if($n) {
				$sql = substr($sql, 0, wa_strlen($sql) - 2);
				l_mysql_query($sql, true);
			}

			$time = time();

			$sql = "UPDATE cms3_search SET indextime = '{$time}' WHERE rel_id = '{$element_id}'";
			l_mysql_query($sql, true);

			umiHierarchy::getInstance()->unloadElement($element_id);

			return true;
		}

		/**
			* Получить id слова $word в поисковой базе
			* @param String $word слово
			* @return Integer|Boolean id слова, либо false
		*/
		public static function getWordId($word) {
			$word = str_replace("037", "", $word);
			$word = trim($word, "\r\n\t? ;.,!@#$%^&*()_+-=\\/:<>{}[]'\"`~|");
			$word = wa_strtolower($word);

			if(wa_strlen($word) < 3) {
				return false;
			}

			$word = l_mysql_real_escape_string($word);

			$sql = "SELECT id FROM cms3_search_index_words WHERE word = '{$word}'";
			$result = l_mysql_query($sql, true);

			if(list($word_id) = mysql_fetch_row($result)) {
				return $word_id;
			} else {
				$sql = "INSERT INTO cms3_search_index_words (word) VALUES('{$word}')";
				$result = l_mysql_query($sql, true);

				return (int) l_mysql_insert_id();
			}
		}

		/**
			* Получить количество проиндексированных страниц
			* @return Integer кол-во проиндексированных страниц
		*/
		public function getIndexPages() {
			$sql = "SELECT SQL_SMALL_RESULT COUNT(*) FROM cms3_search";
			$result = l_mysql_query($sql, true);

			list($c) = mysql_fetch_row($result);
			return (int) $c;
		}

		/**
			* Получить общее количество страниц, которые можно проиндексировать
			* @return Integer кол-во страниц, годных к индексации
		*/
		public function getAllIndexablePages() {
			$sql = "SELECT COUNT(*) FROM cms3_hierarchy WHERE is_deleted = '0' AND is_active = '1' ORDER BY id LIMIT 1";
			$result = l_mysql_query($sql, true);

			list($c) = mysql_fetch_row($result);
			return (int) $c;
		}

		/**
			* Получить количество проиндескированных слов
			* @return Integer количество слов
		*/
		public function getIndexWords() {
			$sql = "SELECT SQL_SMALL_RESULT SUM(weight) FROM cms3_search_index";
			$result = l_mysql_query($sql, true);

			list($c) = mysql_fetch_row($result);
			return (int) $c;
		}

		/**
			* Получить количество проиндескированных уникальных слов
			* @return Integer количество уникальных слов
		*/
		public function getIndexWordsUniq() {
			$sql = "SELECT SQL_SMALL_RESULT COUNT(*) FROM cms3_search_index_words";
			$result = l_mysql_query($sql, true);

			list($c) = mysql_fetch_row($result);
			return (int) $c;
		}

		/**
			* Получить дату последней индексации
			* @return Integer дата последней индексации
		*/
		public function getIndexLast() {
			$sql = "SELECT SQL_SMALL_RESULT indextime FROM cms3_search ORDER BY indextime DESC LIMIT 1";
			$result = l_mysql_query($sql, true);

			list($c) = mysql_fetch_row($result);
			return (int) $c;
		}

		/**
			* Очистить поисковый индекс
		*/
		public function truncate_index () {
			$sql = "TRUNCATE TABLE cms3_search_index_words";
			l_mysql_query($sql, true);

			$sql = "TRUNCATE TABLE cms3_search_index";
			l_mysql_query($sql, true);

			$sql = "TRUNCATE TABLE cms3_search";
			l_mysql_query($sql, true);

			return true;
		}

		/**
			* Искать по поисковому индексу
			* @param String $str поисковая строка
			* @param Array $search_types = NULL если указан, то будут выраны только страницы с необходимым hierarchy-type-id
			* @param Array $hierarchy_rels = NULL если указан, то искать только в определенном разделе сайта
			* @param Boolean $orMode = false если true, то искать в режиме OR, иначе в режиме AND
			* @return Array массив, стостоящий из id найденых страниц
		*/
		public function runSearch($str, $search_types = NULL, $hierarchy_rels = NULL, $orMode = false) {
			$words_temp = preg_split("/[ \-\_]/", $str);    //TODO
			$words = Array();

			foreach($words_temp as $word) {
				if(wa_strlen($word) >= 3) {
					$words[] = $word;
				}
			}

			$elements = $this->buildQueries($words, $search_types, $hierarchy_rels, $orMode);

			return $elements;
		}

		public function buildQueries($words, $search_types = NULL, $hierarchy_rels = NULL, $orMode = false) {
			$lang_id = cmsController::getInstance()->getCurrentLang()->getId();
			$domain_id = cmsController::getInstance()->getCurrentDomain()->getId();

			$morph_disabled  = mainConfiguration::getInstance()->get('system','search-morph-disabled');
			$words_conds = Array();
			foreach($words as $i => $word) {
				if(wa_strlen($word) < 3) {
					unset($words[$i]);
					continue;
				}

				$word = l_mysql_real_escape_string($word);
				$word = str_replace(Array("%", "_"), Array("\\%", "\\_"), $word);

				$word_subcond = "siw.word LIKE '{$word}%' ";

				if(!$morph_disabled)  {
					$word_subcond .=' OR ';
					$word_base = language_morph::get_word_base($word);

					if(wa_strlen($word_base) >= 3) {
						$word_base = l_mysql_real_escape_string($word_base);
						$word_subcond .= "siw.word LIKE '{$word_base}%'";
					} else {
						$word_subcond = trim($word_subcond, " OR ");
					}
				}

				$words_conds[] = "(" . $word_subcond . ")";
			}

			$words_cond = implode(" OR ", $words_conds);

			$users = cmsController::getInstance()->getModule("users");
			$user_id = $users->user_id;
			$user = umiObjectsCollection::getInstance()->getObject($user_id);
			$groups = $user->getValue("groups");
			$groups[] = $user_id;
			$groups[] = regedit::getInstance()->getVal("//modules/users/guest_id");
			$groups = array_extract_values($groups);

			$perms_sql = "";
			$sz = sizeof($groups);
			for($i = 0; $i < $sz; $i++) {
				if($i == 0) {
					$perms_sql .= " AND (";
				}

				$perms_sql .= "(c3p.owner_id = '{$groups[$i]}' AND c3p.rel_id = h.id AND level >= 1)";

				if($i == ($sz - 1)) {
					$perms_sql .= ")";
				} else {
					$perms_sql .= " OR ";
				}
			}
			$perms_table = ", cms3_permissions c3p";

			if(cmsController::getInstance()->getModule('users')->isSv()) {
				$perms_table = "";
				$perms_sql = "";
			}

			$types_sql = "";
			if(is_array($search_types)) {
				if(sizeof($search_types)) {
					if($search_types && $search_types[0]) {
						$types_sql = " AND s.type_id IN (" . implode(", ", $search_types) . ")";
					}
				}
			}

			$hierarchy_rels_sql = "";
			if (is_array($hierarchy_rels) && count($hierarchy_rels)) {
				$hierarchy_rels_sql = " AND h.rel IN (" . implode(", ", $hierarchy_rels) . ")";
			}

			if($words_cond == false) {
				return Array();
			}

			l_mysql_query("CREATE TEMPORARY TABLE temp_search (rel_id int unsigned, tf float, word varchar(64))");

			$sql = <<<SQL

INSERT INTO temp_search SELECT SQL_SMALL_RESULT HIGH_PRIORITY  s.rel_id, si.tf, siw.word

	FROM    cms3_search_index_words siw,
		cms3_search_index si,
		cms3_search s,
		cms3_hierarchy h
		{$perms_table}

			WHERE    ({$words_cond}) AND
				si.word_id = siw.id AND
				s.rel_id = si.rel_id AND
				s.domain_id = '{$domain_id}' AND
				s.lang_id = '{$lang_id}' AND
				h.id = s.rel_id AND
				h.is_deleted = '0' AND
				h.is_active = '1'
				{$types_sql}
				{$hierarchy_rels_sql}
				{$perms_sql}


SQL;


			$res = Array();

			l_mysql_query($sql);

			if($orMode) {
				$sql = <<<SQL
SELECT rel_id, (SUM(tf) / AVG(tf)) AS x
	FROM temp_search
		GROUP BY rel_id
			ORDER BY x DESC
SQL;

			} else {
				$wordsCount = sizeof($words);

				$sql = <<<SQL
SELECT rel_id, (SUM(tf) / AVG(tf)) AS x, COUNT(word) AS wc
	FROM temp_search
		GROUP BY rel_id
			HAVING wc >= '{$wordsCount}'
				ORDER BY x DESC
SQL;
			}
			$result = l_mysql_query($sql);

			while(list($element_id) = mysql_fetch_row($result)) {
				$res[] = $element_id;
			}

			l_mysql_query("DROP TEMPORARY TABLE IF EXISTS temp_search");

			return $res;
		}

		public function prepareContext($element_id, $uniqueOnly = false) {
			if(!($element = umiHierarchy::getInstance()->getElement($element_id))) {
				return false;
			}

			if($element->getValue("is_unindexed")) return false;

			$context = Array();

			$type_id = $element->getObject()->getTypeId();
			$type = umiObjectTypesCollection::getInstance()->getType($type_id);

			$field_groups = $type->getFieldsGroupsList();
			foreach($field_groups as $field_group_id => $field_group) {
				foreach($field_group->getFields() as $field_id => $field) {
					if($field->getIsInSearch() == false) continue;

					$field_name = $field->getName();
					$data_type = $field->getFieldType()->getDataType();

					$val = $element->getValue($field_name);

					if($data_type == 'relation') {
						if(!is_array($val)) {
							$val = array($val);
						}
						foreach($val as $i => $v) {
							if($item = selector::get('object')->id($v)) {
								$val[$i] = $item->name;
							}
						}
						$val = implode(' ', $val);
					}

					if(is_null($val) || !$val) continue;

					if(is_object($val)) {
						continue;
					}

					$context[] = $val;
				}
			}

			if($uniqueOnly) {
			    $context = array_unique($context);
			}

			$res = "";
			foreach($context as $val) {
				if(is_array($val)) {
					continue;
				}
				$res .= $val . " ";
			}

			$res = preg_replace("/%[A-z0-9_]+ [A-z0-9_]+\([^\)]+\)%/im", "", $res);


			$res = str_replace("%", "&#037", $res);
			return $res;
		}

		/**
			* Получить контекст, в котором употреблены поисковые слова на страние $element_id
			* @param Integer $element_id id страницы
			* @param String $search_string поисковая строка
			* @return String контекст поисковой строки
		*/
		public function getContext($element_id, $search_string) {
			$content = $this->prepareContext($element_id, true);

			$content = preg_replace("/%content redirect\((.*)\)%/im", "::CONTENT_REDIRECT::\\1::", $content);
			$content = preg_replace("/(%|&#037)[A-z0-9]+ [A-z0-9]+\((.*)\)(%|&#037)/im", "", $content);

			$bt = "<b>";
			$et = "</b>";


			$words_arr = explode(" ", $search_string);


			$content = preg_replace("/([A-zА-я0-9])\.([A-zА-я0-9])/im", "\\1&#46;\\2", $content);

			$context = str_replace(">", "> ", $content);
			$context = str_replace("<br>", " ", $context);
			$context = str_replace("&nbsp;", " ", $context);
			$context = str_replace("\n", " ", $context);
			$context = strip_tags($context);


			if(preg_match_all("/::CONTENT_REDIRECT::(.*)::/i", $context, $temp)) {
				$sz = sizeof($temp[1]);

				for($i = 0; $i < $sz; $i++) {
					if(is_numeric($temp[1][$i])) {
						$turl = cmsController::getInstance()->getModule('content')->get_page_url($temp[1][$i]);
						$turl = umiHierarchy::getInstance()->getPathById($temp[1][$i]);
						$turl = trim($turl, "'");
						$res = str_replace($temp[0][$i], "<p>%search_redirect_text% \"<a href='$turl'>$turl</a>\"</p>", $context);
					} else {
						$turl = strip_tags($temp[1][$i]);
						$turl = trim($turl, "'");
						$context = str_replace($temp[0][$i], "<p>%search_redirect_text% <a href=\"" . $turl . "\">" . $turl . "</a></p>", $context);
					}
				}
			}

			$context .= "\n";


			$res_out = "";

			$lines = Array();
			foreach($words_arr as $cword) {
				if(wa_strlen($cword) <= 1)    continue;

				$tres = $context;
				$sword = language_morph::get_word_base($cword);
                $sword = preg_quote($sword);
				$pattern_sentence = "/([^\.^\?^!^<^>.]*)$sword([^\.^\?^!^<^>.]*)[!\.\?\n]/imu";
				$pattern_word = "/([^ ^[\.[ ]*]^!^\?^\(^\).]*)($sword)([^ ^\.^!^\?^\(^\).]*)/imu";

				if (preg_match($pattern_sentence, $tres, $tres)) {
					$lines[] = $tres[0];
				}
			}

			$lines = array_unique($lines);

			$res_out = "";
			foreach($lines as $line) {
				foreach($words_arr as $cword) {
					$sword = language_morph::get_word_base($cword);
					$sword = preg_quote($sword);
					$pattern_word = "/([^ ^.^!^\?.]*)($sword)([^ ^.^!^\?.]*)/imu";
					$line = preg_replace($pattern_word, $bt . "\\1\\2\\3" . $et, $line);
				}

				if($line) {
					$res_out .= "<p>" . $line . "</p>";
				}
			}

			if(!$res_out) {
				preg_match("/([^\.^!^\?.]*)([\.!\?]*)/im", $context, $res_out);
				$res_out = $res_out[0];
				$res_out = "<p></p>";
			}
			return $res_out;
		}

		/**
			* Стереть индекс для страницы $element_id
			* @param Integer $element_id id страницы
		*/
		public function unindex_items($element_id) {
			$element_id = (int) $element_id;

			$sql = "DELETE FROM cms3_search WHERE rel_id = '{$element_id}'";
			l_mysql_query($sql, true);

			$sql = "DELETE FROM cms3_search_index WHERE rel_id = '{$element_id}'";
			l_mysql_query($sql, true);

			return true;
		}

		/**
			* Проиндексировать страницу $element_id и всех ее детей
			* @param Integer $element_id id страницы
		*/
		public function index_items($element_id) {
			$hierarchy = umiHierarchy::getInstance();
			$childs = $hierarchy->getChilds($element_id, true, true, 99);
			$elements = array($element_id);
			$this->expandArray($childs, $elements);

			foreach($elements as $element_id) {
				$this->index_item($element_id);
			}
		}

		/**
			* Посчитать IDF слова $wordId
			* @param Integer $wordId id слова в поисковой базе
		*/
		public function calculateIDF($wordId) {
			static $IDF = false;

			if($IDF === false) {
				$sql = "SELECT COUNT(*) FROM cms3_search";
				$result = l_mysql_query($sql);
				list($d) = mysql_fetch_row($result);

				$sql = "SELECT COUNT(*) FROM cms3_search_index WHERE word_id = {$wordId}";
				$result = l_mysql_query($sql);
				list($dd) = mysql_fetch_row($result);

				$IDF = log($d / $dd);
			}
			return $IDF;
		}

		public function suggestions($string, $limit = 10) {
			$string = trim($string);
			if(!$string) return false;
			$string = wa_strtolower($string);

			$rus = str_split('йцукенгшщзхъфывапролджэячсмитьбю');
			$eng = str_split('qwertyuiop[]asdfghjkl;\'zxcvbnm,.');

			$string_cp1251 = iconv("UTF-8", "CP1251", $string);
			$mirrowed_rus = iconv("CP1251", "UTF-8", str_replace($rus, $eng, $string_cp1251));
			$mirrowed_eng = iconv("CP1251", "UTF-8", str_replace($eng, $rus, $string_cp1251));

			$mirrowed = ($mirrowed_rus != $string) ? $mirrowed_rus : $mirrowed_eng;

			$string = l_mysql_real_escape_string($string);
			$mirrowed = l_mysql_real_escape_string($mirrowed);
			$limit = (int) $limit;

			$sql = <<<SQL
SELECT `siw`.`word` as `word`, COUNT(`si`.`word_id`) AS `cnt`
	FROM
		`cms3_search_index_words` `siw`,
		`cms3_search_index` `si`
	WHERE
		(
			`siw`.`word` LIKE '{$string}%' OR
			`siw`.`word` LIKE '{$mirrowed}%'
		) AND
		`si`.`word_id` = `siw`.`id`
	GROUP BY
		`siw`.`id`
	ORDER BY SUM(`si`.`tf`) DESC
	LIMIT {$limit}
SQL;

			$connection = ConnectionPool::getInstance()->getConnection('search');
			return $connection->queryResult($sql);
		}

		private function expandArray($arr, &$result) {
			if(is_null($result)) $result = array();

			foreach($arr as $id => $childs) {
				$result[] = $id;
				$this->expandArray($childs, $result);
			}
		}
	};


	interface iPermissionsCollection {

		public function getOwnerType($ownerId);
		public function makeSqlWhere($ownerId);

		public function isAllowedModule($ownerId, $module);
		public function isAllowedMethod($ownerId, $module, $method);
		public function isAllowedObject($ownerId, $objectId);
		public function isSv($userId = false);
		public function isAdmin($userId = false);
		public function isOwnerOfObject($objectId, $userId = false);

		public function resetElementPermissions($elementId, $ownerId = false);
		public function resetModulesPermissions($ownerId);
		
		public function setElementPermissions($ownerId, $elementId, $level);
		public function setModulesPermissions($ownerId, $module, $method = false);

		public function setDefaultPermissions($elementId);

		public function hasUserPermissions($ownerId);
		
		public function copyHierarchyPermissions($fromOwnerId, $toOwnerId);
		
		public function getUserId();
		
		public function setAllElementsDefaultPermissions($ownerId);
		
		public function getUsersByElementPermissions($elementId, $level = 1);
		
		public function pushElementPermissions($elementId, $level = 1);
		
		public function cleanupBasePermissions();
		
		public function isAuth();
	};


/**
	* Управляет правами доступа на страницы и ресурсы модулей.
	* Синглтон. Экземпляр класса можно получить через статичесик метод getInstance.
*/
	class permissionsCollection extends singleton implements iSingleton, iPermissionsCollection {
		protected $methodsPermissions = array(), $user_id = 0, $tempElementPermissions = array();
		protected $elementsCache = array();

		// Some permissions constants
		const E_READ_ALLOWED   = 0;
		const E_EDIT_ALLOWED   = 1;
		const E_CREATE_ALLOWED = 2;
		const E_DELETE_ALLOWED = 3;
		const E_MOVE_ALLOWED   = 4;

		const E_READ_ALLOWED_BIT   = 1;
		const E_EDIT_ALLOWED_BIT   = 2;
		const E_CREATE_ALLOWED_BIT = 4;
		const E_DELETE_ALLOWED_BIT = 8;
		const E_MOVE_ALLOWED_BIT   = 16;

		/**
			* Конструктор
		*/
		public function __construct() {
			if(is_null(getRequest('guest-mode')) == false) {
				$this->user_id = self::getGuestId();
				return;
			}

			$users = cmsController::getInstance()->getModule("users");

			if($users instanceof def_module) {
				$this->user_id = $users->user_id;

				if($this->isAllowedMethod($this->user_id, "content", "sitetree")){
					   $_SESSION['_umi_opaf_disabled_html']=1;
			    }
			    else{
					   $_SESSION['_umi_opaf_disabled_html']=0;
				}
			}


		}

		/**
			* Получить экземпляр коллекци
			* @return permissionsCollection экземпляр класса permissionsCollection
		*/
		public static function getInstance($c = NULL) {
			return parent::getInstance(__CLASS__);
		}

		/**
			* Внутрисистемный метод, не является частью публичного API
			* @param Integer $owner_id id пользователя или группы
			* @return Integer|array
		*/
		public function getOwnerType($owner_id) {
			if($owner_object = umiObjectsCollection::getInstance()->getObject($owner_id)) {
				if($groups = $owner_object->getPropByName("groups")) {
					return $groups->getValue();
				} else {
					return $owner_id;
				}
			} else {
				return false;
			}
		}

		/**
			* Внутрисистемный метод, не является частью публичного API
			* @param Integer $owner_id id пользователя или группы
			* @return String фрагмент SQL-запроса
		*/
		public function makeSqlWhere($owner_id, $ignoreSelf = false) {
			static $cache = array();
			if(isset($cache[$owner_id])) return $cache[$owner_id];

			$owner = $this->getOwnerType($owner_id);

			if(is_numeric($owner)) {
				$owner = array();
			}

			if($owner_id) {
				$owner[] = $owner_id;
			}
			$owner[] = self::getGuestId();

			$owner = array_unique($owner);

			if(sizeof($owner) > 2) {
				foreach($owner as $i => $id) {
					if($id == $owner_id && $ignoreSelf) {
						unset($owner[$i]);
					}
				}
				$owner = array_unique($owner);
				sort($owner);
			}

			$sql = "";
			$sz = sizeof($owner);
			for($i = 0; $i < $sz; $i++) {
				$sql .= "cp.owner_id = '{$owner[$i]}'";
				if($i < ($sz - 1)) {
					$sql .= " OR ";
				}
			}
			$sql = "({$sql})";

			return $cache[$owner_id] = $sql;
		}


		/**
			* Узнать, разрешен ли пользователю или группе $owner_id доступ к модулю $module
			* @param Integer $owner_id id пользователя или группы пользователей
			* @param String $module название модуля
			* @return Boolean true если доступ разрешен
		*/
		public function isAllowedModule($owner_id, $module) {
			static $cache = array();


			if($owner_id == false) {
				$owner_id = $this->getUserId();
			}

			if($this->isSv($owner_id)) return true;
			if(isset($cache[$owner_id][$module])) {
				return $cache[$owner_id][$module];
			}

			$sql_where = $this->makeSqlWhere($owner_id);
			$module = l_mysql_real_escape_string($module);

			if(substr($module, 0, 7) == "macros_") return false;

			$sql = "SELECT module, MAX(cp.allow) FROM cms_permissions cp WHERE method IS NULL AND {$sql_where} GROUP BY module";
			$result = l_mysql_query($sql);
			while(list($m, $allow) = mysql_fetch_row($result)) {

				$cache[$owner_id][$m] = $allow;
			}
			return isset($cache[$owner_id][$module]) ? (bool) $cache[$owner_id][$module] : false;
		}

		/**
			* Узнать, разрешен ли пользователю или группе $owner_id доступ к методу $method модуля $module
			* @param Integer $owner_id id пользователя или группы пользователей
			* @param String $module название модуля
			* @param String $method название метода
			* @return Boolean true если доступ на метод разрешен
		*/
		public function isAllowedMethod($owner_id, $module, $method, $ignoreSelf = false) {
			if($module == "content" && !strlen($method)) return 1;
			if($module == "config" && $method == "menu") return 1;
			if($module == "eshop" && $method == "makeRealDivide") return 1;

			if($this->isAdmin($owner_id)) {
				if($this->isAdminAllowedMethod($module, $method)) {
					return 1;
				}
			}

			if($this->isSv($owner_id)) return true;
			if(!$module) return false;

			$method = $this->getBaseMethodName($module, $method);

			$methodsPermissions = &$this->methodsPermissions;
			if(!isset($methodsPermissions[$owner_id]) || !is_array($methodsPermissions[$owner_id])) {
				$methodsPermissions[$owner_id] = array();
			}
			$cache = &$methodsPermissions[$owner_id];

			$sql_where = $this->makeSqlWhere($owner_id, $ignoreSelf);

			if($module == "backup" && $method == "rollback") return true;
			if($module == "autoupdate" && $method == "service") return true;
			if($module == "config" && ($method == "lang_list" || $method == "lang_phrases")) return true;
			if($module == "users" && ($method == "auth" || $method == "login_do" || $method == "login")) return true;

			$cache_key = $module;
			if(!array_key_exists($cache_key, $cache)) {
				$cacheData = cacheFrontend::getInstance()->loadData('module_perms_' . $owner_id . '_' . $cache_key);
				if(is_array($cacheData)) {
					$cache[$module] = $cacheData;
				} else {
					$sql = "SELECT cp.method, MAX(cp.allow) FROM cms_permissions cp WHERE module = '{$module}' AND {$sql_where} GROUP BY module, method";
					$result = l_mysql_query($sql);

					$cache[$module] = array();
					while(list($cmethod) = mysql_fetch_row($result)) {
						$cache[$cache_key][] = $cmethod;
					}

					cacheFrontend::getInstance()->saveData('module_perms_' . $owner_id . '_' . $cache_key, $cache[$module], 3600);
				}
			}

			if (in_array($method, $cache[$cache_key]) || in_array(strtolower($method), $cache[$cache_key])) {
				return true;
			} else {
				return false;
			}
		}

		/**
			* Узнать, разрешен ли пользователю или группе $owner_id доступ на чтение страницы $object_id (класс umiHierarchyElement)
			* @param Integer $owner_id id пользователя или группы пользователей
			* @param Integer $object_id id страницы, доступ к которой проверяется
			* @return Boolean true если есть доступ хотя бы на чтение
		*/
		public function isAllowedObject($owner_id, $object_id, $resetCache = false) {
			$object_id = (int) $object_id;
			if($object_id == 0) return array(false, false, false, false, false);

			if($this->isSv($owner_id)) {
				return array(true, true, true, true, true);
			}

			if(array_key_exists($object_id, $this->tempElementPermissions)) {
				$level = $this->tempElementPermissions[$object_id];
				return array((bool)($level&1), (bool)($level&2), (bool)($level&4), (bool)($level&8), (bool)($level&16) );
			}

			$cache = &$this->elementsCache;

			if(!$resetCache && isset($cache[$object_id]) && isset($cache[$object_id][$owner_id])) {
				return $cache[$object_id][$owner_id];
			}

			$sql_where = $this->makeSqlWhere($owner_id);

			$sql = "SELECT BIT_OR(cp.level) FROM cms3_permissions cp WHERE rel_id = '{$object_id}' AND {$sql_where}";
			$level = false;
			cacheFrontend::getInstance()->loadSql($sql);

			if(!$level || $resetCache) {
				$result = l_mysql_query($sql);
				list($level) = mysql_fetch_row($result);
				$level = array((bool)($level&1), (bool)($level&2), (bool)($level&4), (bool)($level&8), (bool)($level&16) );

			}

			if($level) {
				cacheFrontend::getInstance()->saveSql($sql, $level, 600);
			}

			if(!isset($cache[$object_id])) $cache[$object_id] = array();
			$cache[$object_id][$owner_id] = $level;
			return $level;
		}

		/**
			* Узнать, является ли пользователь или группа пользователей $user_id супервайзером
			* @param Integer $user_id id пользователя (по умолчанию используется id текущего пользователя)
			* @return Boolean true, если пользователь является супервайзером
		*/
		public function isSv($user_id = false) {
			static $is_sv = array();

			if($user_id === false) {
				$user_id = $this->getUserId();
			}

			if(isset($is_sv[$user_id])) {
				return $is_sv[$user_id];
			}

			if(is_null(getRequest('guest-mode')) == false) {
				return $is_sv[$user_id] = false;
			}

			$sv_group_id = umiObjectsCollection::getInstance()->getObjectIdByGUID('users-users-15');
			if($user = umiObjectsCollection::getInstance()->getObject($user_id)) {
				$user_groups = $user->getValue('groups');
				if((is_array($user_groups) && in_array($sv_group_id, $user_groups)) || $user_id == $sv_group_id) {
					return $is_sv[$user_id] = true;
				}
			}

			return $is_sv[$user_id] = false;
		}

		/**
			* Узнать, является ли пользователь $user_id администратором, т.е. есть ли у него доступ
			* к администрированию хотя бы одного модуля
			* @param Integer $user_id = false id пользователя (по умолчанию используется id текущего пользователя)
			* @return Boolean true, если пользователь является администратором
		*/
		public function isAdmin($user_id = false, $ignoreCache = false) {
			static $is_admin = array();
			if($user_id === false) $user_id = $this->getUserId();
			if(isset($is_admin[$user_id])) return $is_admin[$user_id];
			if($this->isSv($user_id)) return $is_admin[$user_id] = true;

			if(!$ignoreCache && is_array(getSession('is_admin'))) {
				$is_admin = getSession('is_admin');
				if(isset($is_admin[$user_id])) return $is_admin[$user_id];
			}

			$sql_where = $this->makeSqlWhere($user_id);
			$sql = <<<SQL
SELECT COUNT(cp.allow)
	FROM cms_permissions cp
	WHERE method IS NULL AND {$sql_where} AND cp.allow IN (1, 2) GROUP BY module
SQL;
			$result = l_mysql_query($sql);

			list($cnt) = mysql_fetch_row($result);
			$is_admin[$user_id] = (bool) $cnt;
			$_SESSION['is_admin'] = $is_admin;
			return $is_admin[$user_id];
		}

		/**
			* Узнать, является ли пользователь $user_id владельцем объекта (класс umiObject) $object_id
			* @param Integer $object_id id объекта (класс umiObject)
			* @param $user_id id пользователя
			* @return Boolean true, если пользователь является владельцем
		*/
		public function isOwnerOfObject($object_id, $user_id = false) {
			if($user_id == false) {
				$user_id = $this->getUserId();
			}

			if($user_id == $object_id) {	//Objects == User, that's ok
				return true;
			} else {
				$object = umiObjectsCollection::getInstance()->getObject($object_id);
				if($object instanceof umiObject) {
					$owner_id = $object->getOwnerId();
				} else {
					$owner_id = 0;
				}

				if($owner_id == 0 || $owner_id == $user_id) {
					return true;
				} else {
					$guestId = umiObjectsCollection::getInstance()->getObjectIdByGUID('system-guest');
					if($owner_id == $guestId && class_exists('customer')) {
						$customer = customer::get();
						if($cusotmer && ($customer->id == $owner_id)) {
							return true;
						}
					}
					return false;
				}
			}
		}

		/**
			* Сбросить настройки прав до дефолтных для страницы (класс umiHierarchyElement) $element_id
			* @param Integer $element_id id страницы (класс umiHierarchyElement)
			* @return Boolean false если произошла ошибка
		*/
		public function setDefaultPermissions($element_id) {
			if(!umiHierarchy::getInstance()->isExists($element_id)) {
				return false;
			}

			l_mysql_query("START TRANSACTION");


			$sql = "DELETE FROM cms3_permissions WHERE rel_id = '{$element_id}'";
			l_mysql_query($sql);


			$element = umiHierarchy::getInstance()->getElement($element_id, true, true);
			$hierarchy_type_id = $element->getTypeId();
			$hierarchy_type = umiHierarchyTypesCollection::getInstance()->getType($hierarchy_type_id);

			$module = $hierarchy_type->getName();
			$method = $hierarchy_type->getExt();


			//Getting outgroup users
			$type_id = umiObjectTypesCollection::getInstance()->getBaseType("users", "user");

			$sel = new umiSelection;
			$sel->setObjectTypeFilter();
			$sel->addObjectType($type_id);

			$group_field_id = umiObjectTypesCollection::getInstance()->getType($type_id)->getFieldId("groups");
			$sel->setPropertyFilter();
			$sel->addPropertyFilterIsNull($group_field_id);

			$users = umiSelectionsParser::runSelection($sel);


			//Getting groups list
			$object_type_id = umiObjectTypesCollection::getInstance()->getBaseType("users", "users");

			$sel = new umiSelection;

			$sel->setObjectTypeFilter();
			$sel->addObjectType($object_type_id);
			$groups = umiSelectionsParser::runSelection($sel);

			$objects = array_merge($users, $groups);


			//Let's get element's ownerId and his groups (if user)
			$owner_id = $element->getObject()->getOwnerId();
			if($owner = umiObjectsCollection::getInstance()->getObject($owner_id)) {
				if($owner_groups = $owner->getValue("groups")) {
					$owner_arr = $owner_groups;
				} else {
					$owner_arr = array($owner_id);
				}
			} else {
				$owner_arr = array();
			}


			foreach($objects as $ugid) {
				if($ugid == SV_GROUP_ID) continue;
				if($module == "content") $method == "page";

				if($this->isAllowedMethod($ugid, $module, $method)) {
					if(in_array($ugid, $owner_arr) || $ugid == SV_GROUP_ID || $this->isAllowedMethod($ugid, $module, $method . ".edit")) {
						$level = permissionsCollection::E_READ_ALLOWED_BIT +
								 permissionsCollection::E_EDIT_ALLOWED_BIT +
								 permissionsCollection::E_CREATE_ALLOWED_BIT +
								 permissionsCollection::E_DELETE_ALLOWED_BIT +
								 permissionsCollection::E_MOVE_ALLOWED_BIT;
					} else {
						$level = permissionsCollection::E_READ_ALLOWED_BIT;
					}

					$sql = "INSERT INTO cms3_permissions (rel_id, owner_id, level) VALUES('{$element_id}', '{$ugid}', '{$level}')";
					l_mysql_query($sql);
				}
			}

			l_mysql_query("COMMIT");
			l_mysql_query("SET AUTOCOMMIT=1");

			$this->cleanupElementPermissions($element_id);

			if(isset($this->elementsCache[$element_id])) unset($this->elementsCache[$element_id]);

			$cache_key = $this->user_id . "." . $element_id;
			cacheFrontend::getInstance()->saveSql($cache_key, array(true, true));
		}

		/**
		 * Копирует права с родительского элемента
		 * @param Integer $elementId идентификатор элемента, на который устанавливаем права
		 */
		public function setInheritedPermissions($elementId) {
			$hierarchy = umiHierarchy::getInstance();
			$parentId = false;
			if($element = $hierarchy->getElement($elementId, true)) {
				$parentId = $element->getParentId();
			}
			if($parentId) {
				$records = $this->getRecordedPermissions($parentId);
				$values  = array();
				foreach($records as $ownerId => $level) {
					$values[] = "('{$elementId}', '{$ownerId}', '{$level}')";
				}
				if(empty($values)) return;
				l_mysql_query("START TRANSACTION");
				$sql = "DELETE FROM cms3_permissions WHERE rel_id = '{$elementId}'";
				l_mysql_query($sql);
				$sql = "INSERT INTO cms3_permissions (rel_id, owner_id, level) VALUES ".implode(", ", $values);
				l_mysql_query($sql);
				l_mysql_query("COMMIT");
				l_mysql_query("SET AUTOCOMMIT=1");
				return true;
			} else {
				return $this->setDefaultPermissions($elementId);
			}
		}

		/**
			* Удалить все права на странциу $elementId для ползователя или группы $ownerId
			* @param Integer $elementId id страницы (класс umiHierarchyElement)
			* @param Integer $ownerId=false id пользователя или группы, чьи права сбрасываются. Если false, то права сбрасываются для всех пользователей
		*/
		public function resetElementPermissions($elementId, $ownerId = false) {
			$elementId = (int) $elementId;


			if($ownerId === false) {
				$sql = "DELETE FROM cms3_permissions WHERE rel_id = '{$elementId}'";
				if(isset($this->elementsCache[$elementId]))
					unset($this->elementsCache[$elementId]);
			} else {
				$ownerId = (int) $ownerId;
				$sql = "DELETE FROM cms3_permissions WHERE owner_id = '{$ownerId}' AND rel_id = '{$elementId}'";
				if(isset($this->elementsCache[$elementId]) && isset($this->elementsCache[$elementId][$ownerId]) )
					unset($this->elementsCache[$elementId][$ownerId]);
			}

			l_mysql_query($sql);
			return true;
		}

		/**
			* Сбросить все права на модули и методы для пользователя или группы $ownerId
			* @param Integer $ownerId id пользователя или группы пользователей
			* @param array $modules=NULL массив, который указывает модули, для которых сбросить права. По умолчанию, сбрасываются права на все модули
		*/
		public function resetModulesPermissions($ownerId, $modules = NULL) {
			$ownerId = (int) $ownerId;

			$sql = "DELETE FROM cms_permissions WHERE owner_id = '{$ownerId}'";

			if(is_array($modules)) {
				if(sizeof($modules)) {
					$sql = "DELETE FROM cms_permissions WHERE owner_id = '{$ownerId}' AND module IN ('" . implode("', '", $modules) . "')";
				}
			}

			l_mysql_query($sql);

			$cacheFrontend = cacheFrontend::getInstance();
			foreach($modules as $module) {
				$cacheFrontend->deleteKey('module_perms_' . $ownerId . '_' . $module, true);
			}

			return true;
		}

		/**
			* Установить определенные права на страница $elementId для пользователя или группы $ownerId
			* @param Integer $ownerId id пользователя или группы пользователей
			* @param Integer $elementId id страницы (класс umiHierarchyElement), для которой меняются права
			* @param Integer $level уровень выставляемых прав то "0" до "2". "нет доступа" (0), "только чтение" (1), "чтение и запись" (2)
			* @return Boolean true если не произошло ошибки
		*/
		public function setElementPermissions($ownerId, $elementId, $level) {
			$ownerId = (int) $ownerId;
			$elementId = (int) $elementId;
			$level = (int) $level;

			if($elementId == 0 || $ownerId == 0) {
				return false;
			}

			if(isset($this->elementsCache[$elementId]) && isset($this->elementsCache[$elementId][$ownerId])) {
				unset($this->elementsCache[$elementId][$ownerId]);
            }

			$sql_reset = "DELETE FROM cms3_permissions WHERE owner_id = '".$ownerId."' AND rel_id = '".$elementId."'";
			l_mysql_query($sql_reset);

			$sql = "INSERT INTO cms3_permissions (owner_id, rel_id, level) VALUES('{$ownerId}', '{$elementId}', '{$level}')";
			l_mysql_query($sql);

			$this->cleanupElementPermissions($elementId);

			$this->isAllowedObject($ownerId, $elementId, true);

			return true;
		}


		/**
			* Разрешить пользователю или группе $owner_id права на $module/$method
			* @param Integer $ownerId id пользователя или группы пользователей
			* @param String $module название модуля
			* @param String $method=false название метода
		*/
		public function setModulesPermissions($ownerId, $module, $method = false, $cleanupPermissions = true) {
			$ownerId = (int) $ownerId;
			$module = l_mysql_real_escape_string($module);

			if($method !== false) {
				return $this->setMethodPermissions($ownerId, $module, $method);
			} else {
				$sql = "INSERT INTO cms_permissions (owner_id, module, method, allow) VALUES('{$ownerId}', '{$module}', NULL, '1')";
				l_mysql_query($sql);

				if($cleanupPermissions) $this->cleanupBasePermissions();
				return true;
			}
		}

		protected function setMethodPermissions($ownerId, $module, $method, $cleanupPermissions = true) {
			$method = l_mysql_real_escape_string($method);

			$sql = "INSERT INTO cms_permissions (owner_id, module, method, allow) VALUES('{$ownerId}', '{$module}', '{$method}', '1')";
			l_mysql_query($sql);

			$this->methodsPermissions[$ownerId][$module][] = $method;

			if($cleanupPermissions) $this->cleanupBasePermissions();
			return true;
		}

		/**
			* Узнать, имеет ли пользователь или группа в принципе права на какие-нибудь страницы
			* @param Integer $ownerId id пользователя или группы
			* @return Boolean false, если записей нет
		*/
		public function hasUserPermissions($ownerId) {
			$sql = "SELECT COUNT(*) FROM cms3_permissions WHERE owner_id = '{$ownerId}'";
			$result = l_mysql_query($sql);

			list($cnt) = mysql_fetch_row($result);
			return $cnt;
		}

		/**
			* Скопировать права на все страницы из $fromUserId в $toUserId
			* @param Integer $fromUserId id пользователя или группы пользователей, из которых копируются права
			* @param Integer $fromUserId id пользователя или группы пользователей, в которые копируются права
		*/
		public function copyHierarchyPermissions($fromUserId, $toUserId) {
			if($fromUserId == self::getGuestId()) {
				return false;		//No need in cloning guest permissions now
			}

			$fromUserId = (int) $fromUserId;
			$toUserId = (int) $toUserId;

			$sql = "INSERT INTO cms3_permissions (level, rel_id, owner_id) SELECT level, rel_id, '{$toUserId}' FROM cms3_permissions WHERE owner_id = '{$fromUserId}'";
			l_mysql_query($sql);

			return true;
		}

		/**
			* Системный метод. Получить массив прав из permissions.php и permissions.custom.php
			* @return array
		*/
		public function getStaticPermissions($module, $templater = false) {
			static $cache = array();

			if (isset($cache[$module]) && !$templater) {
				return $cache[$module];
			}

			$static_file = CURRENT_WORKING_DIR . "/classes/modules/" . $module . "/permissions.php";
			if(file_exists($static_file)) {
				require $static_file;
				if(isset($permissions)) {
					$static_permissions = $permissions;

					$static_file_custom = CURRENT_WORKING_DIR . "/classes/modules/" . $module . "/permissions.custom.php";
					if(file_exists($static_file_custom)) {
						unset($permissions);
						require $static_file_custom;
						if(isset($permissions)) {
							$static_permissions = array_merge_recursive($static_permissions, $permissions);
						}
					}

					// подключаем права из ресурсов шаблона
					// TODO: refactoring
					if ($resourcesDir = cmsController::getInstance()->getResourcesDirectory()) {
						$static_file_custom = $resourcesDir . '/classes/modules/' . $module . "/permissions.php";
						if (file_exists($static_file_custom)) {
							unset($permissions);
							require $static_file_custom;
							if(isset($permissions)) {
								$static_permissions = array_merge_recursive($static_permissions, $permissions);
							}
						}
					}

					$cache[$module] = $static_permissions;
					unset($static_permissions);
					unset($permissions);
				}
				else $cache[$module] = array();
			}
			else $cache[$module] = array();

			return $cache[$module];
		}

		/**
			* Получить название корневого метода в системе приритета прав для $module::$method
			* @param String $module название модуля
			* @param String $method название метода
			* @return String название корневого метода
		*/
		protected function getBaseMethodName($module, $method) {
			//TODO: WTF
			//$methods = $this->getStaticPermissions($module, cmsController::getInstance()->getCurrentTemplater());
			$methods = $this->getStaticPermissions($module);

			if($method && is_array($methods)) {
				if(array_key_exists($method, $methods)) {
					return $method;
				} else {
					foreach($methods as $base_method => $sub_methods) {
						if(is_array($sub_methods)) {
							if(in_array($method, $sub_methods) || in_array(strtolower($method), $sub_methods)) {
								return $base_method;
							}
						}
					}
					return $method;
				}
			} else {
				return $method;
			}
		}

		/**
			* Получить id текущего пользователя
			* @return Integer id текущего пользователя
		*/
		public function getUserId() {
			return $this->user_id;
		}


		/**
			* Удалить все записи о правах на модули и методы для пользователей, если они ниже, чем у гостя
		*/
		public function cleanupBasePermissions() {
			$guestId = self::getGuestId();

			$sql    = "SELECT module, method FROM cms_permissions WHERE owner_id = '{$guestId}' AND allow = 1";
			$result = l_mysql_query($sql);

			$sql = array();
			while(list($module, $method) = mysql_fetch_row($result)) {
				if($method) {
					$sql[] = "(module = '{$module}' AND method = '{$method}')";
				} else {
					$sql[] = "(module = '{$module}' AND method IS NULL)";
				}
			}
			if(!empty($sql))
				l_mysql_query("DELETE FROM cms_permissions WHERE owner_id != '{$guestId}' AND (" . implode(' OR ', $sql) . ")");
		}

		/**
			* Удалить для страницы  с id $rel_id записи о правах пользователей, которые ниже, чем у гостя
			* @param Integer $rel_id id страница (класс umiHierarchyElement)
		*/
		protected function cleanupElementPermissions($rel_id) {
			$rel_id = (int) $rel_id;
			$guestId = self::getGuestId();

			$sql = "SELECT level FROM cms3_permissions WHERE owner_id = '{$guestId}' AND rel_id = {$rel_id}";
			$result = l_mysql_query($sql);
			$maxLevel = 0;
			while(list($level) = mysql_fetch_row($result)) {
				if($level>$maxLevel) $maxLevel = $level;
			}
			l_mysql_query("DELETE FROM cms3_permissions WHERE owner_id != '{$guestId}' AND level <= {$maxLevel} AND rel_id = {$rel_id}");
		}

		/**
			* Узнать, разрешено ли пользователю или группе $owner_id администрировать домен $domain_id
			* @param Integer $owner_id id пользователя или группы пользователей
			* @param Integer $domain_id id домена (класс domain)
			* @return Integer 1, если доступ разрешен, 0 если нет
		*/
		public function isAllowedDomain($owner_id, $domain_id) {
			$owner_id = (int) $owner_id;
			$domain_id = (int) $domain_id;

			if($this->isSv($owner_id)) {
				return 1;
			}

			$sql_where_owners = $this->makeSqlWhere($owner_id);

			$sql = "SELECT MAX(cp.allow) FROM cms_permissions cp WHERE cp.module = 'domain' AND cp.method = '{$domain_id}' AND " . $sql_where_owners;
			$result = l_mysql_query($sql);

			if($row = mysql_fetch_row($result)) {
				list($level) = $row;
				return (int) $level;
			} else return 0;
		}

		/**
			* Установить права пользователю или группе $owner_id на администрирование домена $domain_id
			* @param Integer $owner_id id пользователя или группы пользователей
			* @param Integer $domain_id id домена (класс domain)
			* @param Boolean $allow=true если true, то доступ разрешен
		*/
		public function setAllowedDomain($owner_id, $domain_id, $allow = 1) {
			$owner_id = (int) $owner_id;
			$domain_id = (int) $domain_id;
			$allow = (int) $allow;

			$sql = "DELETE FROM cms_permissions WHERE module = 'domain' AND method = '{$domain_id}' AND owner_id = '{$owner_id}'";
			$result = l_mysql_query($sql);

			$sql = "INSERT INTO cms_permissions (module, method, owner_id, allow) VALUES('domain', '{$domain_id}', '{$owner_id}', '{$allow}')";
			$result = l_mysql_query($sql);

			return true;
		}

		/**
			* Установить права по умолчанию для страницы $element по отношению к пользователю $owner_id
			* @param umiHierarchyElement $element экземпляр страницы
			* @param Integer $owner_id id пользователя или группы пользователей
			* @return Integer уровен доступа к странице, который был выбран системой
		*/
		public function setDefaultElementPermissions(iUmiHierarchyElement $element, $owner_id) {
			$module = $element->getModule();
			$method = $element->getMethod();

			$level = 0;
			if($this->isAllowedMethod($owner_id, $module, $method, true)) {
				$level = permissionsCollection::E_READ_ALLOWED_BIT;
			}

			if($this->isAllowedMethod($owner_id, $module, $method . ".edit", true)) {
				$level = permissionsCollection::E_READ_ALLOWED_BIT +
						 permissionsCollection::E_EDIT_ALLOWED_BIT +
						 permissionsCollection::E_CREATE_ALLOWED_BIT +
						 permissionsCollection::E_DELETE_ALLOWED_BIT +
						 permissionsCollection::E_MOVE_ALLOWED_BIT;
			}

			$this->setElementPermissions($owner_id, $element->getId(), $level);

			return $level;
		}

		/**
			* Сбросить для пользователя или группы $owner_id права на все страницы на дефолтные
			* @param Integer $owner_id id пользователя или группы пользователей
		*/
		public function setAllElementsDefaultPermissions($owner_id) {
			$owner_id = (int) $owner_id;
			$hierarchyTypes = umiHierarchyTypesCollection::getInstance();

			$this->elementsCache = array();

			$owner = $this->getOwnerType($owner_id);
			if(is_numeric($owner)) {
				$owner = array();
			}

			$owner[] = self::getGuestId();
			$owner = array_unique($owner);

			l_mysql_query("START TRANSACTION");

			$read = array();
			$write = array();

			foreach($hierarchyTypes->getTypesList() as $hierarchyType) {
				$module = $hierarchyType->getName();
				$method = $hierarchyType->getExt();

				if($this->isAllowedMethod($owner_id, $module, $method . ".edit", true)) {
					foreach($owner as $gid) {
						if($this->isAllowedMethod($gid, $module, $method . ".edit", true)) {
							continue 2;
						}
					}
					$write[] = $hierarchyType->getId();
					$level = 2;
				} else if($this->isAllowedMethod($owner_id, $module, $method, true)) {
					foreach($owner as $gid) {
						if($this->isAllowedMethod($gid, $module, $method, true)) {
							continue 2;
						}
					}

					$read[] = $hierarchyType->getId();
					$level = 1;
				} else {
					$level = 0;
				}
			}

			if(sizeof($read)) {
				$types = implode(", ", $read);

				$sql = <<<SQL
INSERT INTO cms3_permissions (level, owner_id, rel_id)
	SELECT 1, '{$owner_id}', id FROM cms3_hierarchy WHERE type_id IN ({$types})
SQL;
				l_mysql_query($sql);
			}

			if(sizeof($write)) {
				$types = implode(", ", $write);

				$sql = <<<SQL
INSERT INTO cms3_permissions (level, owner_id, rel_id)
	SELECT 31, '{$owner_id}', id FROM cms3_hierarchy WHERE type_id IN ({$types})
SQL;
				l_mysql_query($sql);
			}

			l_mysql_query("COMMIT");
		}

		/**
			* Получить список всех пользователей или групп, имеющих права на страницу $elementId
			* @param Integer $elementId id страницы
			* @param Integer $level = 1 искомый уровень прав
			* @return array массив id пользователей или групп, имеющих права на страницу
		*/
		public function getUsersByElementPermissions($elementId, $level = 1) {
			$elementId = (int) $elementId;
			$level = (int) $level;

			$sql = "SELECT owner_id FROM cms3_permissions WHERE rel_id = '{$elementId}' AND level >= '{$level}'";
			$result = l_mysql_query($sql);

			$owners = array();
			while(list($ownerId) = mysql_fetch_row($result)) {
				$owners[] = (int) $ownerId;
			}

			return $owners;
		}

		/**
		 * Получить список сохраненных прав для страницы $elementId
		 * @param Integer $elementId
		 * @return array $ownerId => $permissionsLevel
		 */

		public function getRecordedPermissions($elementId) {
			$elementId = (int) $elementId;

			$sql = "SELECT owner_id, level FROM cms3_permissions WHERE rel_id = '{$elementId}'";

			$result = l_mysql_query($sql);

			$records = array();
			while(list($ownerId, $level) = mysql_fetch_row($result)) {
				$records[$ownerId] = (int) $level;
			}

			return $records;
		}

		/**
			* Указать права на страницу. Влияет только на текущую сессию, данные в базе изменены не будут
			* @param Integer $elementId id страницы
			* @param Integer $level = 1 уровень прав доступа (0-3).
		*/
		public function pushElementPermissions($elementId, $level = 1) {
			//if(false && array_key_exists($elementId, $this->tempElementPermissions) == false) {
				$this->tempElementPermissions[$elementId] = (int) $level;
			//}
		}

		/**
			* Узнать, авторизован ли текущий пользователь
			* @return Boolean true, если авторизован
		*/
		public function isAuth() {
			return ($this->getUserId() != self::getGuestId());
		}

		/**
			* Позволяет узнать id пользователя "Гостя"
			* @return Integer $guestId id пользователя "Гость"
		*/
		public static function getGuestId() {
			static $guestId;
			if(!$guestId) {
				$guestId = (int) umiObjectsCollection::getInstance()->getObjectIdByGUID('system-guest');
			}
			return $guestId;
		}

		/**
			* Авторизовать клиента как пользователя $userId
			* @param Int|umiObject id пользователя, либо объект пользователя
			* @return Boolean успешность операции
		*/
		public function loginAsUser($userId) {
			if(is_null($userId)) return false;
			if(is_array($userId) && sizeof($userId)) {
				list($userId) = $userId;
			}

			if($userId instanceof iUmiObject) {
				$user = $userId;
				$userId = $user->id;
			} else $user = selector::get('object')->id($userId);
			$this->user_id = $userId;

			$login = $user->login;
			$passwordHash = $user->password;

			if(getRequest('u-login-store')) {
				$time = time() + 31536000;
				setcookie("u-login", $user->login, $time, "/");
				setcookie("u-password-md5", $passwordHash, $time, "/");
			}

			$_SESSION['cms_login'] = $login;
			$_SESSION['cms_pass'] = $passwordHash;
			$_SESSION['user_id'] = $userId;

			return true;
		}

		/**
			* Проверить параметры авторизации
			* @param String login логин
			* @param String password пароль
			* @return NULL|umiObject null, либо пользователь
		*/
		public function checkLogin($login, $password) {
			$sel = new selector('objects');
			$sel->types('object-type')->name('users', 'user');
			$sel->where('login')->equals($login);
			$sel->where('password')->equals(md5($password));
			$sel->where('is_activated')->equals(true);

			if ($sel->first) return $sel->first;

			$sel = new selector('objects');
			$sel->types('object-type')->name('users', 'user');
			$sel->where('e-mail')->equals($login);
			$sel->where('password')->equals(md5($password));
			$sel->where('is_activated')->equals(true);

			return $sel->first;
		}

		public function getPrivileged($perms) {
			if(!sizeof($perms)) return array();

			$sql = 'SELECT owner_id FROM cms_permissions WHERE ';
			$sqls = array();
			foreach($perms as $perm) {
				$module = l_mysql_real_escape_string(getArrayKey($perm, 0));
				$method = l_mysql_real_escape_string($this->getBaseMethodName($module, getArrayKey($perm, 1)));
				$sqls[] = "(module = '{$module}' AND method = '{$method}')";
			}
			$sql .= implode(' OR ', $sqls);

			$result = l_mysql_query($sql);

			$owners = array();
			while(list($ownerId) = mysql_fetch_row($result)) {
				$owners[] = $ownerId;
			}
			$owners = array_unique($owners);
			return $owners;
		}

		protected function isAdminAllowedMethod($module, $method) {
			$methods = array(
			'content' =>    array('json_mini_browser', 'old_json_load_files', 'json_load_files',
							'json_load_zip_folder', 'load_tree_node', 'get_editable_region',
							'save_editable_region', 'widget_create', 'widget_delete',
							'getObjectsByTypeList', 'getObjectsByBaseTypeList',
							'json_get_images_panel', 'json_create_imanager_object',
							'domainTemplates', 'json_unlock_page', 'tree_unlock_page'),
			'backup' =>     array('backup_panel'),
			'data'   =>     array('guide_items', 'guide_items_all', 'json_load_hierarchy_level'),
			'webo' => array('show'),
			'users'  => array('getFavourites', 'json_change_dock', 'saveUserSettings', 'loadUserSettings'),
			'*'		 =>		array('dataset_config')
			);

			if(isset($methods[$module])) {
				if(in_array($method, $methods[$module])) {
					return true;
				}
			}
			if(isset($methods['*'])) {
				if(in_array($method, $methods['*'])) {
					return true;
				}
			}
			return false;
		}

		public function clearCache() {
			$this->elementsCache = array();
			$this->methodsPermissions = array();
		}

	};


/**
	* Класс для управления табами в админке модулей.
	* Необходим для динамического изменния количества табов в модулях.
	* Должен быть доступен для подключаемых библиотек модуля при инициализации
	* При инициализации класса создается 2 экземпляра: 'common' и 'config', которые
	* содержат модифицируемый список табов для админки модуля и для конфигурации модуля.
	* После инициализации из шаблона вызывается макрос, который в зависимости от текущей страницы выбирает
	* необходимый экземпляр класса и выводит список табов для отрисовки.
*/
	interface iAdminModuleTabs {
		/**
			* Конструктор, создает класс определенного типа.
			* @param String $type = 'common' тип содержимого. Либо 'common', либо 'type'.
		*/
		public function __construct($type = 'common');
		
		/**
			* Добавить новый таб для метода $methodName
			* @param String $methodName название метода класса-модуля
			* @param Array $aliases = NULL список методов-алиасов, при котором данный таб будет считаться активным (помимо $methodName)
			* @return Boolean результат операции
		*/
		public function add($methodName, $aliases = NULL);
		
		/**
			* Получить список алиасов для таба $methodName
			* @param String $methodName название метода класса-модуля
			* @return Array|Boolean массив алиасов, либо false в случае ошибки
		*/
		public function get($methodName);
		
		/**
			* Получить основной метод таба по методу-алиасу, либо по его основному методу
			* @param String $methodOrAlias 
			* @return String $methodName, либо false в случае ошибки
		*/

		public function getTabNameByAlias($methodOrAlias);

		/**
			* Удалить таб метода $methodName из списка табов
			* @param String $methodName название метода класса-модуля
			* @return Boolean результат операции
		*/
		public function remove($methodName);
		
		/**
			* Получить список всех табов
			* @return Array массив, список всех табов
		*/
		public function getAll();
	};



/**
	* Класс для управления табами в админке модулей.
	* Необходим для динамического изменния количества табов в модулях.
	* Должен быть доступен для подключаемых библиотек модуля при инициализации
	* При инициализации класса создается 2 экземпляра: 'common' и 'config', которые
	* содержат модифицируемый список табов для админки модуля и для конфигурации модуля.
	* После инициализации из шаблона вызывается макрос, который в зависимости от текущей страницы выбирает
	* необходимый экземпляр класса и выводит список табов для отрисовки.
*/
	class adminModuleTabs implements iAdminModuleTabs {
		private $type;
		private $tabs = array();
		/**
			* Конструктор, создает класс определенного типа.
			* @param String $type = 'common' тип содержимого. Либо 'common', либо 'config'.
		*/
		public function __construct($type = 'common') {
			if ($type == 'common' || $type == 'config') {
				$this->type = $type;
			} else {
				throw new coreException("Tabs type \"{$type}\" is unknown.");
			}
		}
		
		/**
			* Добавить новый таб для метода $methodName
			* @param String $methodName название метода класса-модуля
			* @param Array $aliases = NULL список методов-алиасов, при котором данный таб будет считаться активным (помимо $methodName)
			* @return Boolean результат операции
		*/
		public function add($methodName, $aliases = array()) {
			$this->tabs[$methodName] = $aliases;
		}
		
		/**
			* Получить список алиасов для таба $methodName
			* @param String $methodName название метода класса-модуля
			* @return Array|Boolean массив алиасов, либо false в случае ошибки
		*/
		public function get($methodName) {
			if (isset($this->tabs[$methodName])) {
				return $this->tabs[$methodName];
			}
			return false;
		}
		
		/**
			* Получить основной метод таба по методу-алиасу, либо по его основному методу
			* @param String $methodOrAlias 
			* @return String $methodName, либо false в случае ошибки
		*/

		public function getTabNameByAlias($method) {
			if (isset($this->tabs[$method])) return $method;

			foreach ($this->tabs as $tabMethod => $aliases) {
				if (in_array($method, $aliases)) return $tabMethod;
			}

			return false;
		}

		
		/**
			* Удалить таб метода $methodName из списка табов
			* @param String $methodName название метода класса-модуля
			* @return Boolean результат операции
		*/
		public function remove($methodName) {
			if (isset($this->tabs[$methodName])) {
				unset($this->tabs[$methodName]);
				return true;
			}
			return false;
		}
		
		/**
			* Получить список всех табов
			* @return Array массив, список всех табов
		*/
		public function getAll() {
			return (sizeof($this->tabs) > 1) ? $this->tabs : array();
		}
	};


	interface iTranslit {
		public static function convert($string);
	}


/**
	* Работа с транслитом
*/
	class translit implements iTranslit {
		public static	$fromUpper = Array("Э", "Ч", "Ш", "Ё", "Ё", "Ж", "Ю", "Ю", "Я", "Я", "А", "Б", "В", "Г", "Д", "Е", "З", "И", "Й", "К", "Л", "М", "Н", "О", "П", "Р", "С", "Т", "У", "Ф", "Х", "Ц", "Щ", "Ъ", "Ы", "Ь");
		public static	$fromLower = Array("э", "ч", "ш", "ё", "ё", "ж", "ю", "ю", "я", "я", "а", "б", "в", "г", "д", "е", "з", "и", "й", "к", "л", "м", "н", "о", "п", "р", "с", "т", "у", "ф", "х", "ц", "щ", "ъ", "ы", "ь");
		public static	$toLower   = Array("e", "ch", "sh", "yo", "jo", "zh", "yu", "ju", "ya", "ja", "a", "b", "v", "g", "d", "e", "z", "i", "j", "k", "l", "m", "n", "o", "p", "r", "s",  "t", "u", "f", "h", "c", "w", "~", "y", "\'");

		/**
			* Конвертировать строку в транслит
			* @param String $str входная строка
			* @param String $separator заменитель невалидных символов
			* @return String транслитерированная строка
		*/
		public static function convert($str, $separator = '_') {

			if (!$separator) $separator = '_';

			$str = umiObjectProperty::filterInputString($str);

			$str = str_replace(self::$fromLower, self::$toLower, $str);
			$str = str_replace(self::$fromUpper, self::$toLower, $str);
			$str = strtolower($str);

			$str = preg_replace("/([^A-z^0-9^_^\-]+)/", $separator, $str);
			$str = preg_replace("/[\/\\\',\t`\^\[\]]*/", "", $str);
			$str = str_replace(chr(8470), "", $str);
			$str = preg_replace("/[ \.]+/", $separator, $str);

			$str = preg_replace("/([" . $separator . "]+)/", $separator, $str);

			$str = trim(trim($str), $separator);

			return $str;
		}
	}


	interface iTemplater {
		public function init();

		public function loadLangs();
		public function putLangs($input);

		public function parseInput($input);
		public function parseResult();
		public function parseContent($arr, $templater);

		public function loadTemplates($filepath, $c, $args);

		public function parseMacros($macrosStr);
		public function executeMacros($macrosArr);

		public static function pushEditable($module, $method, $id);
		
		public function cleanUpResult($input);
	}



	/**
	 * @deprecated
	 * Оставлено для соблюдения обратной совместимости
	 * Используйте umiTemplater
	 */
	class templater extends singleton {
		public static function getInstance($c = NULL) {
			return cmsController::getInstance()->getCurrentTemplater();
		}

		protected function __construct() {}

		public function init() {}

		public function loadLangs() {}

		public function putLangs($input) {}

		public function parseInput($input) {}
		public function parseResult() {}
		public function parseContent($arr, $templater) {}

		public function loadTemplates($filepath, $c, $args) {
			return array();
		}

		public function parseMacros($macrosStr) {
			return def_module::parseTPLMacroses($macrosStr);
		}
		public function executeMacros($macrosArr) {}

		public static function pushEditable($module, $method, $id) {
			return def_module::pushEditable($module, $method, $id);
		}

		final public static function getSomething($version_line = "pro", $forceHost = null) {
			return umiTemplater::getSomething($version_line, $forceHost);
		}


		public function cleanUpResult($input) {}
	}




	/**
	 * @deprecated
	 * Используйте umiTemplater::create('XSLT');
	 */
	class tplTemplater extends singleton {
		protected function __construct() {}
		/**
		 * @static
		 * @param null $c
		 * @return umiTemplaterXSLT
		 */
		public static function getInstance($c = NULL) {
			return umiTemplater::create('TPL', null);
		}
		}



	interface iCmsController {

		public function loadBuildInModule($moduleName);

//		public function loadModule($moduleName);

		public function getModule($moduleName);

		public function installModule($moduleName);

		public function getSkinPath();


		public function getCurrentModule();
		public function getCurrentMethod();
		public function getCurrentElementId();
		public function getCurrentMode();
		public function getCurrentDomain();
		public function getCurrentTemplater();
		public function getCurrentLang();

		public function getLang();

		public function setCurrentModule($moduleName);
		public function setCurrentMethod($methodName);
		
		public function getRequestId();
		
		public function getPreLang();
		
		public function calculateRefererUri();
		public function getCalculatedRefererUri();
	}


	class cmsController extends singleton implements iSingleton, iCmsController {
		protected
				$modules = array(),
				$current_module = false,
				$current_method = false,
				$current_mode = false,
				$current_element_id = false,
				$current_lang = false,
				$current_domain = false,
				$current_templater = false,
				$calculated_referer_uri = false,
				$modulesPath,
				$url_prefix = '',
				$adminDataSet = array();


		public
				$parsedContent = false,
				$currentTitle = false,
				$currentHeader = false,
				$currentMetaKeywords = false,
				$currentMetaDescription = false,
				$currentEditElementId = false,

				$langs = array(),
				$langs_export = array(),
				$pre_lang = "",
				$errorUrl, $headerLabel = false;

		public		$isContentMode = false;

		public static $IGNORE_MICROCACHE = false;

		protected function __construct() {
			$config = mainConfiguration::getInstance();
            showWorkTime("cmscontroller mainconfig init");
			$this->modulesPath = $config->includeParam('system.modules');
            showWorkTime("cmscontroller includeparam");
			$this->init();
            showWorkTime("cmscontroller init");
		}

		/**
		* @desc
		* @return cmsController
		*/
		public static function getInstance($c = NULL) {
			return parent::getInstance(__CLASS__);
		}


		private function loadModule($module_name) {
			$xpath = "//modules/" . $module_name;

			if(!defined("CURRENT_VERSION_LINE")) {
				define("CURRENT_VERSION_LINE", "");
			}

			if(regedit::getInstance()->getVal($xpath) == $module_name) {
				$module_path = $this->modulesPath . $module_name . "/class.php";
				if(file_exists($module_path)) {
					require_once $module_path;

					if(class_exists($module_name)) {
						$new_module = new $module_name();
						$new_module->pre_lang = $this->pre_lang;
						$new_module->pid = $this->getCurrentElementId();
						$this->modules[$module_name] = $new_module;

						return $new_module;
					}
				} else {
					return false;
				}
			} else {
				return false;
			}
		}


		public function loadBuildInModule($moduleName) {
			//TODO
		}

		public function getModule($module_name) {
			if(!$module_name) return false;

			if(array_key_exists($module_name, $this->modules)) {
				return $this->modules[$module_name];
			} else {
				return $this->loadModule($module_name);
			}
		}

		public function installModule($installPath) {
			if(!file_exists($installPath)) {
				throw new publicAdminException(getLabel("label-errors-13052"), 13052);
			}
			require_once $installPath;

			preg_match("|\/modules\/(\S+)\/|i", $installPath, $matches);
			$name_by_path = $matches[1];

			if ($name_by_path!=$INFO['name']) {
				throw new publicAdminException(getLabel("label-errors-13053"), 13053);
			}

			// Проверяем, что модуль разрешен для данной системы
			$this->checkModuleByName($name_by_path);

			$this->checkModuleComponents($COMPONENTS);

			def_module::install($INFO);
		}

		/** Проверка наличия всех компонентов модуля
		*
		* @param mixed $module_name - имя модуля
		*/
		private function checkModuleComponents($components) {

			if (!is_array($components)) return false;

			$files = array();
			foreach ($components as $component) {
				$file = preg_replace("/.\/(.+)/", CURRENT_WORKING_DIR . '/' . "$1", $component);
				if (!file_exists($file) || !is_readable($file)) $files[] = $file;
			}

			if(count($files)) {
				$error = getLabel("label-errors-13058") . "\n";
				foreach($files as $file) {
					$error .= getLabel('error-file-does-not-exist', null, $file) . "\n";
				}

				throw new coreException($error);
			}
		}

		/** Проверяет, что модуль доступен для данной лицензии
		*
		*
		* @param mixed $module_name - имя модуля
		*/
		private function checkModuleByName($module_name) {
			if (!defined("UPDATE_SERVER")) define("UPDATE_SERVER", base64_decode('aHR0cDovL3Vkb2QudW1paG9zdC5ydS91cGRhdGVzZXJ2ZXIv'));

			$regedit = regedit::getInstance();
			$domainsCollection = domainsCollection::getInstance();

			$info = array();
			$info['type']='get-modules-list';
			$info['revision'] = $regedit->getVal("//modules/autoupdate/system_build");
			$info['host'] = $domainsCollection->getDefaultDomain()->getHost();
			$info['ip'] = getServer('SERVER_ADDR');
			$info['key'] = $regedit->getVal("//settings/keycode");
			$url = UPDATE_SERVER . "?" . http_build_query($info, '', '&');

			$result = $this->get_file($url);

			if (!$result) {
				throw new publicAdminException(getLabel("label-errors-13054"), 13054);
			}

			$xml = new DOMDocument();
			if (!$xml->loadXML($result)) {
				throw new publicAdminException(getLabel("label-errors-13055"), 13055);
			}

			$xpath = new DOMXPath($xml);

			// Проверяем, возможно сервер возвратил ошибку.
			$errors = $xpath->query("error");

			if ($errors->length!=0) {
				$code = $errors->item(0)->getAttribute("code");
				throw new publicAdminException(getLabel("label-errors-".$code), $code);
			}

			$modules = $xpath->query("module");
			if ($modules->length==0) {
				throw new publicAdminException(getLabel("label-errors-13056"), 13056);
			}

			$module_name = strtolower($module_name);

			$modules = $xpath->query("module[@name='".$module_name."']");
			if ($modules->length!=0) {
				$module = $modules->item(0);
				if ($module->getAttribute("active")!="1") {
					throw new publicAdminException(getLabel("label-errors-13057"), 13057);
				}
			}
		}

		/**
		* Выполняет запрос к серверу обновлений
		*
		* @param mixed $url - сформированная строка запроса
		* @return string;
		*/
		private function get_file($url) {
			try {
				$result = umiRemoteFileGetter::get($url);
				return $result;
			} catch (Exception $e) {
				throw new publicAdminException(getLabel("label-errors-13041"), 13041);
			}
		}

		public function getSkinPath() {
			// TODO
		}

		public function getCurrentModule() {
			return $this->current_module;
		}

		public function getCurrentMethod() {
			return $this->current_method;
		}

		public function getCurrentElementId() {
			return $this->current_element_id;
		}

		public function getLang() {
			return $this->current_lang;
		}

		public function getCurrentLang() {
			return $this->getLang();
		}

		public function getCurrentMode() {
			return $this->current_mode;
		}


		public function getCurrentDomain() {
			return $this->current_domain;
		}

		/**
			* Получить текущий шаблонизатор
			* @return umiTemplater
		*/
		public function getCurrentTemplater() {
			if (!$this->current_templater instanceof umiTemplater) {
				$this->detectCurrentTemplater();
			}

			if (!$this->current_templater instanceof umiTemplater) {
				throw new coreException("Can't detect current templater.");
			}

			return $this->current_templater;
		}

		/**
		 * Получить директорию с ресурсами для текущего шаблона
		 * @return string
		*/
		public function getResourcesDirectory() {
			if ($this->getCurrentMode() == 'admin') return false;

			if (($template = $this->detectCurrentDesignTemplate()) instanceof template) {
				return $template->getResourcesDirectory();
			} else {
				return false;
			}
		}

		/**
		 * Получить текущую директорию с шаблонами
		 * @return string
		 */
		public function getTemplatesDirectory() {
			if (($template = $this->detectCurrentDesignTemplate()) instanceof template) {
				return $template->getTemplatesDirectory();
			} else {
				return CURRENT_WORKING_DIR . "xsltTpls/";
			}
		}


		/**
		 * @deprecated
		 * Оставлено для совместимости, ни на что не влияет
		 * @return umiTemplater
		 */
		public function setCurrentTemplater() {
			return $this->getCurrentTemplater();
		}


		/**
		 * Возвращает глобальные переменные в зависимости от
		 * текущего состояния системы
		 *
		 * @param bool $forcePrepare - если true, переменные будут еще раз инициализированы
		 */
		public function getGlobalVariables($forcePrepare = false) {
			static $globalVariables;
			if (!$forcePrepare && !is_null($globalVariables)) return $globalVariables;

			if ($this->getCurrentMode() == 'admin') {
				return $globalVariables = $this->prepareAdminSideGlobalVariables();
			}
			if (def_module::isXSLTResultMode()) {
				return $globalVariables = $this->prepareClientSideGlobalVariablesForXSLT();
			} else {
				return $globalVariables = $this->prepareClientSideGlobalVariablesForTPL();
			}
		}

		/**
		 * Подготавливает и возвращает глобальные переменные в режиме работы со стороны админки
		 * @return array
		 */
		private function prepareAdminSideGlobalVariables() {
			$permissions = permissionsCollection::getInstance();
			$domains = domainsCollection::getInstance();
			$regedit = regedit::getInstance();

			$result = array(
				'@module' => $this->current_module,
				'@method' => $this->current_method,
				'@lang' => $this->current_lang->getPrefix(),
				'@lang-id' => $this->current_lang->getId(),
				'@pre-lang' => $this->pre_lang,
				'@domain' => $this->current_domain->getHost(),
				'@domain-id' => $this->current_domain->getId(),
				'@session-lifetime' => defined('SESSION_LIFETIME') ? SESSION_LIFETIME : 0,
				'@system-build' => $regedit->getVal("//modules/autoupdate/system_build"),
				'@referer-uri' => $this->getCalculatedRefererUri(),
				'@user-id' => $permissions->getUserId(),
				'@interface-lang' => ulangStream::getLangPrefix()

			);


			if (defined('CURRENT_VERSION_LINE') && CURRENT_VERSION_LINE == 'demo') {
				$result['@demo'] = 1;
			}

			if(!is_null($domainFloated = getRequest('domain'))) {
				$result['@domain-floated'] = $domainFloated;
				$result['@domain-floated-id'] = $domains->getDomainId($domainFloated);
			} else {
				if ($this->currentEditElementId) {
					$element = umiHierarchy::getInstance()->getElement($this->currentEditElementId);
					if($element instanceof umiHierarchyElement) {
						$domainId = $element->getDomainId();
						$domain = $domains->getDomain($domainId);
						if($domain instanceof iDomain) {
							$result['@domain-floated'] = $domain_floated = $domain->getHost();
						}
					}
				} else {
					$result['@domain-floated'] = $result['@domain'];
				}
			}


			if ($requestUri = getServer('REQUEST_URI')) {
				$requestUriInfo = parse_url($requestUri);
				$requestUri = getArrayKey($requestUriInfo, 'path');
				$queryParams = getArrayKey($requestUriInfo, 'query');
				if($queryParams) {
					parse_str($queryParams, $queryParamsArr);
					if(isset($queryParamsArr['p'])) unset($queryParamsArr['p']);
					if(isset($queryParamsArr['xmlMode'])) unset($queryParamsArr['xmlMode']);

					$queryParams = http_build_query($queryParamsArr, '', '&');
					if($queryParams) $requestUri .= '?' . $queryParams;
				}
				$result['@request-uri'] = $requestUri;
			}

			$result['@edition'] = CURRENT_VERSION_LINE;
			$result['@disableTooManyChildsNotification'] = (int) mainConfiguration::getInstance()->get('system', 'disable-too-many-childs-notification');


			$isUserAdmin = $permissions->isAdmin();

			if (system_is_allowed($this->current_module, $this->current_method)) {
				// execute admin mode method
				try {
					if ($module = $this->getModule($this->current_module)) {
						$module->cms_callMethod($this->current_method, NULL);
					}
					$result['data'] = $this->adminDataSet;
				} catch (publicException $e) {
					$result['data'] = $e;
				}
			} elseif($isUserAdmin) {
				$result['data'] = new requreMoreAdminPermissionsException(getLabel("error-require-more-permissions"));
			}

			return $result;
		}

		/**
		 * Подготавливает и возвращает глобальные переменные в режиме работы со стороны сайта
		 * для режима TPL
		 * @return array
		 */
		private function prepareClientSideGlobalVariablesForTPL() {
			$permissions = permissionsCollection::getInstance();

			$currentModule = $this->getCurrentModule();
			$currentMethod = $this->getCurrentMethod();
			$elementId = $this->getCurrentElementId();
			$userId = $permissions->getUserId();

			$content = "";
			// check permissions
			$notPermitted = true;
			if ($permissions->isAllowedMethod($userId, $currentModule, $currentMethod)) {
				$notPermitted = false;
				if ($elementId) {
					list($r) = $permissions->isAllowedObject($userId, $elementId);
					$notPermitted = !$r;
				}
			}
			// если нет прав на текущую страницу либо на доступ к текущему методу
			if ($notPermitted) {
				header("Status: 401 Unauthorized");
				$this->setCurrentModule('users');
				$this->setCurrentMethod('login');
				if (!$moduleUsers = $this->getModule('users')) {
					throw new coreException('Module "users" not found.');
				}
				$content = $moduleUsers->login();
			} else {
				$module = $this->getModule($currentModule);
				try {
					$content = $module->cms_callMethod($currentMethod, array());
				} catch (publicException $e) {
					$content = $e->getMessage();
				}
			}

			return array('content' => $content);
		}
		/**
		 * Подготавливает и возвращает глобальные переменные в режиме работы со стороны сайта
		 * для режима XSLT
		 * @return array
		 */
		private function prepareClientSideGlobalVariablesForXSLT() {
			$globalVariables = array();

			$permissions = permissionsCollection::getInstance();
			$regedit = regedit::getInstance();
			$objectsCollection = umiObjectsCollection::getInstance();
			$hierarchy = umiHierarchy::getInstance();

			$userId = $permissions->getUserId();
			$elementId = $this->getCurrentElementId();

			$currentModule = $this->getCurrentModule();
			$currentMethod = $this->getCurrentMethod();

			// check permissions
			$notPermitted = true;
			if ($permissions->isAllowedMethod($userId, $currentModule, $currentMethod)) {
				$notPermitted = false;
				if ($elementId) {
					list($r) = $permissions->isAllowedObject($userId, $elementId);
					if (!$r) {
						$notPermitted = true;
						$globalVariables['attribute:not-permitted'] = 1;
					}
				}
			}

			if ($notPermitted) {
				$currentModule = "users";
				$currentMethod = "login";

				$this->setCurrentModule($currentModule);
				$this->setCurrentMethod($currentMethod);
			}

			$this->currentHeader = def_module::parseTPLMacroses(macros_header());

			$globalVariables += array(
				'@module' => $currentModule,
				'@method' => $currentMethod,
				'@domain' =>  $this->getCurrentDomain()->getHost(),
				'@system-build' => $regedit->getVal("//modules/autoupdate/system_build"),
				'@lang' => $this->getCurrentLang()->getPrefix(),
				'@pre-lang' => $this->pre_lang,
				'@header' => $this->currentHeader,
				'@title' =>  def_module::parseTPLMacroses(macros_title()),
				'meta' => array(
					'keywords' => macros_keywords(),
					'description' => macros_describtion()
				)
			);

			if(defined('CURRENT_VERSION_LINE') and CURRENT_VERSION_LINE=='demo') {
				$globalVariables['@demo'] = 1;
			}

			if(!is_null(getRequest('p'))) {
				$globalVariables['@paging'] = "yes";
			}

			$socialModule = cmsController::getInstance()->getModule("social_networks");
			if ($socialModule && ($currentSocial = $socialModule->getCurrentSocial())) {
				$globalVariables['@socialId'] = $currentSocial->getId();
			}

			if ($requestUri = getServer('REQUEST_URI')) {
				$requestUriInfo = @parse_url($requestUri);
				$requestUri = getArrayKey($requestUriInfo, 'path');
				$queryParams = getArrayKey($requestUriInfo, 'query');

				// TODO: разобраться, зачем из социального модуля срезаются query params.
				if ($socialModule && ($currentSocial = $socialModule->getCurrentSocial())) {
					$queryParams = "";
				}

				if ($queryParams) {
					parse_str($queryParams, $queryParamsArr);
					if(isset($queryParamsArr['p'])) unset($queryParamsArr['p']);
					if(isset($queryParamsArr['xmlMode'])) unset($queryParamsArr['xmlMode']);

					$queryParams = http_build_query($queryParamsArr, '', '&');
					if($queryParams) $requestUri .= '?' . $queryParams;
				}
				$globalVariables['@request-uri'] = $requestUri;
			}

			// user info
			$userInfo = array();
			$userId = $this->getModule('users')->user_id;
			$userInfo['@id'] = $userId;
			$userType = 'guest';
			if($permissions->isAuth() && ($user = $objectsCollection->getObject($userId))) {
				$userType = 'user';
				$userInfo['@status'] = 'auth';
				$userInfo['@login'] = $user->login;
				$userInfo['xlink:href'] = $user->xlink;
				if($permissions->isAdmin()) {
					$userType = 'admin';
					if($permissions->isSv()) $userType = 'sv';
				}
			}
			$userInfo['@type'] = $userType;

			if ($geoip = $this->getModule("geoip")) {
				$geoinfo = $geoip->lookupIp();
				if(!isset($geoinfo['special'])) {
					$userInfo['geo'] = array(
						'country'	=> $geoinfo['country'],
						'region'	=> $geoinfo['region'],
						'city'		=> $geoinfo['city'],
						'latitude'	=> $geoinfo['lat'],
						'longitude'	=> $geoinfo['lon']
					);
				} else {
					$userInfo['geo'] = array('special' => $geoinfo['special']);
				}

			}

			$globalVariables['user'] = $userInfo;


			if ($elementId && ($element = $hierarchy->getElement($elementId))) {

				$parentElements = $hierarchy->getAllParents($elementId);

				$parentsInfo = array();
				foreach($parentElements as $parentElementId) {
					if($parentElementId == 0) continue;

					if($parentElement = $hierarchy->getElement($parentElementId)) {
						$parentsInfo[] = $parentElement;
					}
				}
				$globalVariables += array(
					'@pageId' => $elementId,
					'parents' => array(
						'+page' => $parentsInfo
					),
					'full:page' => $element
				);

				def_module::pushEditable($currentModule, $currentMethod, $elementId);

			} elseif ($currentModule == 'content' && $currentMethod == 'content') {
				$buffer = outputBuffer::current();
				$buffer->status("404 Not Found");
				$globalVariables['@method'] = "notfound";
			} elseif (!$notPermitted && $this->isAllowedExecuteMethod($currentModule, $currentMethod)) {
				// execute site mode method
				try {
					$path = getRequest('path');
					// secure path
					$pathParts = explode("/", $path);
					if (count($pathParts) < 2) {
						throw new coreException("Invalid udata path");
					}
					$pathParts[0] = $currentModule;
					$pathParts[1] = $currentMethod;
					$path = 'udata://' . implode("/", $pathParts);

					$globalVariables['xml:data'] = $this->executeStream($path);
				} catch (publicException $e) {
					$globalVariables['data'] = $e;
				}
			}

			return $globalVariables;
		}

		/**
		 * Запускает umi-stream, возвращает результат работы
		 * @param $uri
		 * @throws coreException - Если не удалось открыть стрим
		 * @return string - результат работы стрима
		 */
		public function executeStream($uri) {
			if (($data = @file_get_contents($uri)) === false) {
				// bugfix: failed to open stream: infinite recursion prevented
				$uri .= (strpos($uri, "?") === false) ? '?r=' : '&r=';
				$uri .= uniqid('');
				if (($data = @file_get_contents($uri)) === false) {
					throw new coreException("Failed to open udata:// stream");
				}
			}
			return $data;
		}

		/**
		 * Методы, вызов которых надо игнорировать в режиме XSLT
		 * Предназначено для избавления от заплатки $this->breakMe
		 * @static
		 * @var array
		 */
		private $skipExecuteMethods = array(
			'eshop/compare',
			'faq/question', 'faq/project', 'faq/category',
			'blogs20/blog', 'blogs20/post', 'blogs20/postEdit',
			'catalog/category', 'catalog/getObjectsList', 'catalog/object', 'catalog/viewObject', 'catalog/search',
			'content/content', 'content/sitemap',
			'dispatches/unsubscribe', 'dispatches/subscribe', 'dispatches/subscribe_do',
			'emarket/compare', 'emarket/order', 'emarket/purchase',
			'filemanager/shared_file',
			'forum/confs_list', 'forum/conf', 'forum/topic', 'forum/topic_last_message', 'forum/conf_last_message',
			'news/lastlist', 'news/rubric', 'news/view', 'news/related_links', 'news/item', 'news/listlents', 'news/lastlents',
			'photoalbum/album', 'photoalbum/photo',
			'search/search_do', 'search/suggestions',
			'users/settings', 'users/registrate', 'users/registrate_done', 'users/activate', 'users/auth',
			'vote/poll', 'vote/insertvote', 'vote/results',
			'webforms/page', 'webforms/posted'
		);

		/**
		 * Предназначен для избавления от заплатки $this->breakMe
		 * Возвращает false, если метод вызывать не нужно
		 *
		 * @param string $module
		 * @param string $method
		 *
		 * @return boolean
		 */
		public function isAllowedExecuteMethod($module, $method) {
		return !in_array($module . '/' . $method, $this->skipExecuteMethods);
		}

		private function init() {
			$this->detectMode();
            showWorkTime("cmscontroller detect mode");
			$this->detectDomain();
            showWorkTime("cmscontroller detect domain");
			$this->detectLang();
            showWorkTime("cmscontroller detect lang");
			$this->loadLangs();
            showWorkTime("cmscontroller load lang");


			cacheFrontend::$currentlangId = $this->getCurrentLang()->getId();
			cacheFrontend::$currentDomainId = $this->getCurrentDomain()->getId();

			$LANG_EXPORT = array();
			$lang_file = CURRENT_WORKING_DIR . "/classes/modules/lang.php";
			if (file_exists($lang_file)) {
				require $lang_file;
			}
			$this->langs = array_merge($this->langs, $LANG_EXPORT);


			$ext_lang = CURRENT_WORKING_DIR . "/classes/modules/lang." . $this->getCurrentLang()->getPrefix() . ".php";
			if(file_exists($ext_lang)) {
				require $ext_lang;
				$this->langs = array_merge($this->langs, $LANG_EXPORT);
			}

			$this->errorUrl = getServer('HTTP_REFERER');
			$this->doSomething();
			$this->calculateRefererUri();
		}

		private function detectDomain() {
			$domains = domainsCollection::getInstance();
			$host = getServer('HTTP_HOST');
			$mirror = false;

			if($domain_id = $domains->getDomainId($host)) {
				$domain = $domains->getDomain($domain_id);
				$mirror = true;
			} else {
				$domain = $domains->getDefaultDomain();
				if (!$domain instanceof domain) throw new coreException("Default domain could not be found");
			}

			if($host != $domain->getHost()) {
				$config = mainConfiguration::getInstance();

				$primaryDomainRedirect = $config->get('seo', 'primary-domain-redirect');

				if($primaryDomainRedirect == 1) {
					$uri = 'http://' . $domain->getHost() . getServer('REQUEST_URI');

					$buffer = outputBuffer::current();
					$buffer->header('Location', $uri);
					$buffer->clear();
					$buffer->end();
				} elseif ($primaryDomainRedirect == 2 && !$mirror) {
					$buffer = outputBuffer::current();
					$buffer->status('404 Not Found');
					$buffer->option('generation-time', false);
					ob_start();
					require CURRENT_WORKING_DIR . "/errors/invalid_domain.html";
					$content = ob_get_clean();
					$buffer->push($content);
					$buffer->end();
				}
			}

			if(is_object($domain)) {
				$this->current_domain = $domain;
				return true;
			} else {
				$domain = $domains->getDefaultDomain();
				if($domain instanceof domain) {
					$this->current_domain = $domain;
					$domain->addMirrow($host);
					return false;
				} else {
					throw new coreException("Current domain could not be found");
				}
			}
		}

		private function detectLang() {
			$LangIDs = getRequest('lang_id');

			$lang_id = false;
			if($LangIDs != null) {
				if(is_array($LangIDs)) list($LangIDs) = $LangIDs;
				$lang_id = intval($LangIDs);
			} else if (!is_null(getRequest('links')) && is_array($rel = getRequest('rel'))) {
				if(sizeof($rel) && ($elementId = array_pop($rel))) {
					$element = umiHierarchy::getInstance()->getElement($elementId, true);
					if($element instanceof umiHierarchyElement) {
						$lang_id = $element->getLangId();
					}
				}
			} else {
				list($sub_path) = $this->getPathArray();
				$lang_id = langsCollection::getInstance()->getLangId($sub_path);
			}

			if (!langsCollection::getInstance()->getDefaultLang()) {
				throw new coreException('Cannot find default language');
			}

			if(($this->current_lang = langsCollection::getInstance()->getLang($lang_id)) === false ) {
				if($this->current_domain) {
					if($lang_id = $this->current_domain->getDefaultLangId()) {
						$this->current_lang = langsCollection::getInstance()->getLang($lang_id);
					} else {
						$this->current_lang = langsCollection::getInstance()->getDefaultLang();
					}
				} else {
					$this->current_lang = langsCollection::getInstance()->getDefaultLang();
				}
			}

			if($this->current_lang->getId() != $this->current_domain->getDefaultLangId()) {
				$this->pre_lang = "/" . $this->current_lang->getPrefix();
				$_REQUEST['pre_lang'] = $this->pre_lang;
			}
		}

		/**
		 * Определяет текущий шаблон дизайна
		 * @return null|template - текущий шаблон дизайна, либо null
		 */
		public function detectCurrentDesignTemplate() {
			static $currentDesignTemplate = null;
			if ($currentDesignTemplate instanceof template) return $currentDesignTemplate;

			$templates = templatesCollection::getInstance();

			// пытаемся взять шаблон из request
			$template = null;
			if ($templateId = getRequest('template_id')) {
				$template = $templates->getTemplate((int) $templateId);
			}
			// пытаемся взять текущий шаблон страницы
			if (!$template instanceof template) {
				$template = $templates->getCurrentTemplate();
			}
			return $template;
		}

		/**
		 * Определяет текущий шаблонизатор.
		 * @return umiTemplater
		 */
		private function detectCurrentTemplater() {
			if (defined('VIA_HTTP_SCHEME') && VIA_HTTP_SCHEME) {
				return $this->current_templater = $this->initHTTPSchemeModeTemplater();
			} elseif ($this->current_mode == 'admin') {
				return $this->current_templater = $this->initAdminModeTemplater();
			} else {
				return $this->current_templater = $this->initSiteModeTemplater();
			}
		}


		/**
		 * Инициализируем шаблонизатор для режима работы VIA_HTTP_SCHEME
		 * @return umiTemplater
		 */
		private function initHTTPSchemeModeTemplater() {
			outputBuffer::contentGenerator('XSLT, HTTP SCHEME MODE');
			return umiTemplater::create('XSLT');
		}

		/**
		 * Инициализируем шаблонизатор для Site Mode,
		 * определяем шаблон и возвращаем инстанс соответсвующего шаблонизатора
		 * @return umiTemplater
		 */
		private function initSiteModeTemplater() {
			$template = $this->detectCurrentDesignTemplate();
			// шаблон не определен, выдаем ошибку, завершаем работу
			if (!$template instanceof template) {
				$buffer = outputBuffer::current();
				$buffer->clear();
				$buffer->push(file_get_contents(SYS_ERRORS_PATH . 'no_design_template.html'));
				$buffer->end();
			}

			$templaterType = $template->getType();
			if ($templaterType == 'xsl') $templaterType = 'XSLT';
			if ($templaterType == 'tpls') $templaterType = 'TPL';

			$templaterType = strtoupper($templaterType);
			outputBuffer::contentGenerator($templaterType . ', SITE MODE');

			return umiTemplater::create($templaterType, $template->getFilePath());
		}

		/**
		 * Инициализируем шаблонизатор для Admin Mode
		 */
		private function initAdminModeTemplater() {
			$config = mainConfiguration::getInstance();
			$skinPath = $config->includeParam('templates.skins', array('skin' => system_get_skinName()));
			$permissions = permissionsCollection::getInstance();
			$userId = $permissions->getUserId();

			$isAllowed = $permissions->isAllowedMethod($userId, $this->current_module, $this->current_method);

			// TODO: вынести в конфиг все названия шаблонов
			$fileName = 'main.xsl';

			if (!$permissions->isAdmin(false, true) || !$isAllowed) {

				if ($permissions->isAuth()) {
					$sqlWhere = "owner_id = {$userId}";
					$userGroups = umiObjectsCollection::getInstance()->getObject($userId)->getValue('groups');
					foreach ($userGroups as $userGroup) {
						$sqlWhere .= " or owner_id = {$userGroup}";
					}

					// TODO: убрать прямые запросы к БД
					$sql = "SELECT `module` FROM cms_permissions WHERE (" . $sqlWhere . ") and (method = '' or method is null)";
					$result = l_mysql_query($sql);

					if (mysql_num_rows($result) !==0) {
						$regedit = regedit::getInstance();
						while ($row = mysql_fetch_array($result)){
							$module = $row[0];
							$method = $regedit->getVal("//modules/{$module}/default_method_admin");
							if ($permissions->isAllowedMethod($userId, $module, $method)) {
								def_module::redirect('http://' . $this->getCurrentDomain()->getHost() . '/admin/'. $module . '/' . $method . "/");
								break;
							}
						}
					}
				}
				$fileName = 'main_login.xsl';
			}
			$templateSource = $skinPath . $fileName;

			if (!is_file($templateSource)) {
				throw new coreException('Template "' . $templateSource . '" not found.');
			}

			outputBuffer::contentGenerator('XSLT, ADMIN MODE');

			return umiTemplater::create('XSLT', $templateSource);
		}


		private function getPathArray() {
			$path = getRequest('path');
			$path = trim($path, "/");

			return explode("/", $path);
		}

		private function detectMode() {
			if (isset($_SERVER['argv']) && 1<=count($_SERVER['argv'])
				&& !(isset($_SERVER['QUERY_STRING']) && $_SERVER['argv'][0]==$_SERVER['QUERY_STRING'])) {
				$this->current_mode = "cli";
				cacheFrontend::$cacheMode = true;
				return;
			}

			$path_arr = $this->getPathArray();

			if(sizeof($path_arr) < 2) {
				$path_arr[1] = NULL;
			}

			list($sub_path1, $sub_path2) = $path_arr;

			if($sub_path1 == "admin" || $sub_path2 == "admin") {
				$this->current_mode = "admin";
				cacheFrontend::$adminMode = true;
			} else {
				$this->current_mode = "";
				cacheFrontend::$cacheMode = true;
				cacheFrontend::$adminMode = false;
			}
		}

		private function getSubPathType($sub_path) {
			$regedit = regedit::getInstance();

			if(!$this->current_module) {

				if($sub_path == "trash") {
					def_module::redirect($this->pre_lang . "/admin/data/trash/");
				}

				if($regedit->getVal("//modules/" . $sub_path)) {
					$this->setCurrentModule($sub_path);
					return "MODULE";
				}
			}

			if($this->current_module && !$this->current_method) {
				$this->setCurrentMethod($sub_path);
				return "METHOD";
			}

			if($this->current_module && $this->current_method) {
				return "PARAM";
			}

			return "UNKNOWN";
		}

		private function reset() {
			$this->current_module = $this->current_method = '';

			for($i=0;$i<10;$i++) {
				if(isset($_REQUEST['param'.$i])) {
					unset($_REQUEST['param'.$i]);
				}
				else break;
			}
		}

		public function analyzePath($reset = false) {
            showWorkTime("analyzePath started");
			$path = getRequest('path');
			$path = trim($path, "/");

			if (!is_null(getRequest('scheme'))) {
				if (preg_replace("/[^\w]/im", "", getRequest('scheme')) == 'upage') {
					preg_match_all("/[\d]+/", $path, $element_id);
					$this->current_element_id = $element_id[0][0];
				}
				return;
			}
            showWorkTime("analyzePath something");

			$regedit = regedit::getInstance();
            showWorkTime("analyzePath regedit init");
			$hierarchy = umiHierarchy::getInstance();
            showWorkTime("analyzePath umiHierarchy init");
			$config = mainConfiguration::getInstance();
            showWorkTime("analyzePath mainConfiguration init");
			$buffer = outputBuffer::current();
            showWorkTime("analyzePath outputBuffer init");

			if($reset === true) {
				$this->reset();
			}

			if ($config->get('seo', 'folder-redirect')) {
				def_module::requireSlashEnding();
			}

			if($config->get('seo', 'watch-redirects-history')) {
				redirects::getInstance()->init();
			}

			$path_arr = $this->getPathArray();

			$sz = sizeof($path_arr);
			$url_arr = Array();
			$p = 0;
			for($i = 0; $i < $sz; $i++) {
				$sub_path = $path_arr[$i];

				if($i <= 1) {
					if(($sub_path == $this->current_mode) || ($sub_path == $this->current_lang->getPrefix())) {
						continue;
					}
				}

				$url_arr[] = $sub_path;

				$sub_path_type = $this->getSubPathType($sub_path);

				if($sub_path_type == "PARAM") {
					$_REQUEST['param' . $p++] = $sub_path;
				}
			}


			if(!$this->current_module) {
				if($this->current_mode == "admin") {
					$module_name = $regedit->getVal("//settings/default_module_admin");
					$this->autoRedirectToMethod($module_name);
				} else {
					$module_name = $regedit->getVal("//settings/default_module");
				}
				$this->setCurrentModule($module_name);
			}

			if(!$this->current_method) {
				if($this->current_mode == "admin") {
					return $this->autoRedirectToMethod($this->current_module);
				} else {
					$method_name = $regedit->getVal("//modules/" . $this->current_module . "/default_method");
				}
				$this->setCurrentMethod($method_name);
			}


			if($this->getCurrentMode() == "admin") {
				return;
			}



			$element_id = false;
			$sz = sizeof($url_arr);
			$sub_path = "";
			for($i = 0; $i < $sz; $i++) {
				$sub_path .= "/" . $url_arr[$i];

				if(!($tmp = $hierarchy->getIdByPath($sub_path, false, $errors_count))) {
					$element_id = false;
					break;
				} else {
					$element_id = $tmp;
				}
			}

			if($element_id) {
				if($errors_count > 0 && !defined("DISABLE_AUTOCORRECTION_REDIRECT")) {
					$path = $hierarchy->getPathById($element_id);

					if($i == 0) {
						if($this->isModule($url_arr[0])) {
							$element_id = false;
							break;
						}
					}

					$buffer->status('301 Moved Permanently');
					$buffer->redirect($path);
				}

				$element = $hierarchy->getElement($element_id);
				if($element instanceof umiHierarchyElement) {
					if($element->getIsDefault()) {
						$path = $hierarchy->getPathById($element_id);

						$buffer->status('301 Moved Permanently');
						$buffer->redirect($path);
					}
				}
			} elseif (isset($url_arr[0])) {
				if($this->isModule($url_arr[0])) {
					$module = $this->getModule($url_arr[0]);
					if(isset($url_arr[1]) && !$module->isMethodExists($url_arr[1])) {
						$this->setCurrentModule('content');
						$this->setCurrentMethod('content');
					}
				} else {
					$this->setCurrentModule('content');
					$this->setCurrentMethod('content');
				}
			}

			if(($path == "" || $path == $this->current_lang->getPrefix() ) && $this->current_mode != "admin") {
				if($element_id = $hierarchy->getDefaultElementId($this->getCurrentLang()->getId(), $this->getCurrentDomain()->getId())) {
					$this->current_element_id = $element_id;

				}
			}

			if($element = $hierarchy->getElement($element_id, true)) {
				$type = umiHierarchyTypesCollection::getInstance()->getType($element->getTypeId());

				if(!$type) return false;

				$this->current_module = $type->getName();

				if($ext = $type->getExt()) {
					$this->setCurrentMethod($ext);
				} else {
					$this->setCurrentMethod("content");	//Fixme: content "constructor". Maybe, fix in future?
				}

				$this->current_element_id = $element_id;
			}

			if($this->current_module == "content" && $this->current_method == "content" && !$element_id) {
				redirects::getInstance()->redirectIfRequired($path);
			}
		}



		public function setCurrentModule($module_name) {
			$this->current_module = $module_name;
		}

		public function setCurrentMode($mode) {
			$this->current_mode = $mode;
		}

		public function setAdminDataSet($dataSet) {
			$this->adminDataSet = $dataSet;
		}

		public function setCurrentMethod($method_name) {
			$magic = array("__construct", "__destruct", "__call", "__callStatic", "__get", "__set", "__isset",
							"__unset", "__sleep", "__wakeup", "__toString", "__invoke", "__set_state", "__clone");
			if(in_array($method_name, $magic)) {
				$this->current_module = "content";
				$this->current_method = "notfound";
				return false;
			}

			$this->current_method = $method_name;
		}

		public function loadLangs() {
            showWorkTime("loadLangs started");
			$modules = regedit::getInstance()->getList("//modules");
            showWorkTime("loadLangs getList");
			foreach($modules as $module) {
				$module_name = $module[0];

				$lang_path = CURRENT_WORKING_DIR . '/classes/modules/' . $module_name . '/';
				$lang_path .= "lang.php";

				if (file_exists($lang_path)) {
					require $lang_path;
				}

				if(isset($C_LANG)) {
					if(is_array($C_LANG)) {
						$this->langs[$module_name] = $C_LANG;
						unset($C_LANG);
					}
				}

				if(isset($LANG_EXPORT)) {
					if(is_array($LANG_EXPORT)) {
						$this->langs = array_merge($this->langs, $LANG_EXPORT);
						//$this->langs = $this->langs + $LANG_EXPORT;
						unset($LANG_EXPORT);
					}
				}

				$lang_path = CURRENT_WORKING_DIR . '/classes/modules/' . $module_name . '/';
				$lang_path .= "lang." . $this->getCurrentLang()->getPrefix() .".php";

				if(file_exists($lang_path)) {
					require $lang_path;

					if(isset($C_LANG) && is_array($C_LANG)) {
						$this->langs[$module_name] = $C_LANG;
						unset($C_LANG);
					}

					if(isset($LANG_EXPORT) && is_array($LANG_EXPORT)) {
						$this->langs = array_merge($this->langs, $LANG_EXPORT);
						//$this->langs = $this->langs + $LANG_EXPORT;
						unset($LANG_EXPORT);
					}
				}
                showWorkTime("loadLangs ".$module_name." loaded",1);
			}
			// загружаем общие языковые файлы
			$try_path = CURRENT_WORKING_DIR . "/classes/modules/lang." . $this->getLang()->getPrefix() . ".php";
			if(!file_exists($try_path)) {
				$try_path = CURRENT_WORKING_DIR . "/classes/modules/lang.php";
		}

			include_once $try_path;

			if(isset($LANG_EXPORT)) {
				$this->langs = array_merge($this->langs, $LANG_EXPORT);

				unset($LANG_EXPORT);
			}


		}

		public function getModulesList() {
			$regedit = regedit::getInstance();
			$list = $regedit->getList('//modules');
			$result = array();
			foreach($list as $arr) {
				$result[] = getArrayKey($arr, 0);
			}
			return $result;
		}


		final private function doSomething () { return false; 
			if(defined("CRON") && (constant('CRON') == 'CLI')) {
				return true;
			}

			if(defined("CURRENT_VERSION_LINE")) {
				if(CURRENT_VERSION_LINE != "demo") {
					require CURRENT_WORKING_DIR . "/errors/invalid_license.html";
					exit();
				} else {
					return true;
				}
			}

			$keycode = regedit::getInstance()->getVal("//settings/keycode");

			if($this->doStrangeThings($keycode)) {
				return true;
			}


			$comp_keycode = Array();
			$comp_keycode['pro'] = umiTemplater::getSomething("pro");
			$comp_keycode['shop'] = umiTemplater::getSomething("shop");
			$comp_keycode['lite'] = umiTemplater::getSomething("lite");
			$comp_keycode['start'] = umiTemplater::getSomething("start");
			$comp_keycode['trial'] = umiTemplater::getSomething("trial");

			if(regedit::checkSomething($keycode, $comp_keycode)) {
				return true;
			} else {
				require CURRENT_WORKING_DIR . "/errors/invalid_license.html";
				exit();
			}
		}





		final private function doStrangeThings($keycode) {
			$license_file = SYS_CACHE_RUNTIME . 'trash';
			$cmp_keycode = false;
			$expire = 604800;

			if(file_exists($license_file)) {
				if((time() - filemtime($license_file)) > $expire) {
					$cmp_keycode = base64_decode(file_get_contents($license_file));
				}
			} else {
				file_put_contents($license_file, base64_encode($keycode));
			}

			if($cmp_keycode !== false && $keycode) {
				if($keycode === $cmp_keycode) {
					return true;
				}
			}
			return false;
		}


		public function getRequestId() {
			static $requestId = false;
			if($requestId === false) $requestId = time();
			return $requestId;
		}

		public function getPreLang() {
			return $this->pre_lang;
		}


		protected function autoRedirectToMethod($module) {
			$pre_lang = $this->pre_lang;
			$method = regedit::getInstance()->getVal("//modules/" . $module . "/default_method_admin");

			$url = $pre_lang . "/admin/" . $module . "/" . $method . "/";

			outputBuffer::current()->redirect($url);
		}


		public function calculateRefererUri() {
			if($referer = getRequest('referer')) {
				$_SESSION['referer'] = $referer;
			} else {
				if($referer = getSession('referer')) {
					unset($_SESSION['referer']);
				} else {
					$referer = getServer('HTTP_REFERER');
				}
			}
			$this->calculated_referer_uri = $referer;
		}


		public function getCalculatedRefererUri() {
			if($this->calculated_referer_uri === false) {
				$this->calculateRefererUri();
			}
			return $this->calculated_referer_uri;
		}


		public function isModule($module_name) {
			$regedit = regedit::getInstance();

			if($regedit->getVal('//modules/' . $module_name)) {
				return true;
			} else {
				return false;
			}

		}

		public function setUrlPrefix($prefix = '') {
			$this->url_prefix = $prefix;
		}

		public function getUrlPrefix(){
			return $this->url_prefix ? $this->url_prefix : '';
		}


	};


	interface iUmiDate {
		public function __construct($timeStamp = false);

		public function getFormattedDate($formatString = false);
		public function getCurrentTimeStamp();
		public function getDateTimeStamp();

		public function setDateByTimeStamp($timeStamp);
		public function setDateByString($dateString);

		public static function getTimeStamp($dateString);
	}


	/**
	* @desc Класс-обертка для внутреннего представления типа данных "Дата"
	*/
	class umiDate implements iUmiDate {
		public $timestamp;
		public static $defaultFormatString = DEFAULT_DATE_FORMAT;
        /**
        * @desc Публичный конструктор
        * @param Int $timestamp Количество секунд с начала эпохи Unix (TimeStamp)
        */
		public function __construct($timestamp = false) {
			if($timestamp === false) {
				$timestamp = self::getCurrentTimeStamp();
			}
			$this->setDateByTimeStamp($timestamp);
		}

		/**
		* @desc Возвращяет текущий Time Stamp
		* @return Int Time Stamp
		*/
		public function getCurrentTimeStamp() {
			if (isset($_SERVER['REQUEST_TIME'])) {
				return $_SERVER['REQUEST_TIME'];
			}
			else {
			return time();
		}
		}
        /**
        * @desc Возвращает Time Stamp для сохраненной даты
        * @return Int Time Stamp
        */
		public function getDateTimeStamp() {
			return intval($this->timestamp);
		}
        /**
        * @desc Возвращает сохраненную дату в отформатированом виде
        * @param String $formtString Форматная строка (см. описание функции date на php.net)
        * @return String отформатированная дата 
        */
		public function getFormattedDate($formatString = false) {
			if($formatString === false) {
				$formatString = self::$defaultFormatString;
			}
			return date($formatString, $this->timestamp);
		}
        /**
        * @desc Устанавливает дату по Time Stamp
        * @param Int $timestamp Time Stamp желаемой даты
        * @return Boolean false - если $timestamp не число, true - в противном случае
        */
		public function setDateByTimeStamp($timestamp) {
			if(!is_numeric($timestamp)) {
				return false;
			}
			$this->timestamp = $timestamp;
			return true;
		}
		/**
		* @desc Устанавливает дату по переданой строке
		* @param String $dateString Строка с датой
		* @return Boolean true - если переданная строка может быть интерпретирована, как дата, false - в противном случае
		*/
		public function setDateByString($dateString) {
			$dateString = umiObjectProperty::filterInputString($dateString);
			$timestamp  = strlen($dateString) ? self::getTimeStamp($dateString) : 0;
			return $this->setDateByTimeStamp($timestamp);
		}
		/**
		* @desc Преобразует строку с датой в Time Stamp
		* @param String $dateString Строка с датой
		* @return Int Time Stamp
		*/
		public static function getTimeStamp($dateString) {
			return toTimeStamp($dateString);
		}
		
		public function __toString() {
			return $this->getFormattedDate();
		}
	}


	interface iUmiFile {
		public function __construct($filePath);
		public function delete();

		public static function upload($variableGroupName, $variableName, $targetFolder);

		public function getSize();
		public function getExt();
		public function getFileName();
		public function getDirName();
		public function getModifyTime();
		public function getFilePath($webMode = false);

		public function getIsBroken();

		public function __toString();
		
		public static function getUnconflictPath($path);
		
		public function download($deleteAfterDownload = false);
	}


/**
	* Класс для работы с файлами в системе
*/
	class umiFile implements iUmiFile {
		protected	$filepath,
				$size, $ext, $name, $dirname, $modify_time,
				$is_broken = false;
		public static $mask = 0777;

		protected static $class_name = 'umiFile';
		protected static $allowedFileTypes = array(
			'txt', 'doc', 'docx', 'xls', 'xlsx', 'ppt', 'pptx', 'pps', 'ppsx',
			'odt', 'sxw', 'ods', 'odg', 'pdf', 'csv',
			'html', 'js', 'tpl', 'xsl', 'xml', 'css',
			'zip', 'rar', '7z', 'tar', 'gz', 'tar.gz', 'exe', 'msi',
			'rtf', 'chm', 'ico', 'jpg', 'jpeg', 'gif', 'png', 'bmp',
			'psd', 'flv', 'mp4', 'swf', 'mp3', 'wav', 'wma', 'ogg', 'aac'
		);

		protected static $allowedImageTypes = array('jpg', 'jpeg', 'gif', 'bmp', 'png');

		protected static $addWaterMark = false;

		/**
			* Конструктор
			* @param String $filepath путь до файла
		*/
		public function __construct($filepath) {
			$filepath = str_replace("//", "/", $filepath);
			$filepath = str_replace("\\\\", "\\", $filepath);

			if(!@is_file($filepath)) {
				$this->is_broken = true;
				return false;
			}

			$this->filepath = $filepath;
			$this->filepath = str_replace("\\", "/", $filepath);
			$this->loadInfo();
		}

		/**
			* Удалить файл из файловой системы
		*/
		public function delete() {
			if(is_writable($this->filepath)) {
				return unlink($this->filepath);
			} else {
				return false;
			}
		}


		/**
			* Послать HTTP заголовки для того, чтобы браузер начал скачивать файл
			* @param Boolean $deleteAfterDownload = false удалить файл после скачивания
		*/
		public function download($deleteAfterDownload = false) {
			while (@ob_end_clean());

			header('HTTP/1.1 200 OK');
			header("Cache-Control: public, must-revalidate");
			header("Pragma: no-cache");
			header("Content-type: application/force-download");
			header("Content-Length: " . $this->getSize());
			header('Accept-Ranges: bytes');
			header("Content-Encoding: None");
			header("Vary:");
			header('Content-Transfer-Encoding: Binary');
			header("Content-Disposition: attachment; filename=" . $this->getFileName());

			readfile(realpath($this->getFilePath()));

			if($deleteAfterDownload) {
				$this->delete();
			}
			exit();
		}

		public static function manualUpload($name, $temp_path, $size, $target_folder) {
			 if(!$size || !$name || $name == ".htaccess" || !is_uploaded_file($temp_path)) return 1;


			 if( !in_array(strtolower(substr($name, strrpos($name, '.') + 1)), self::$allowedFileTypes) ) return 2;


			 list(,, $extension) = array_values(getPathInfo($name));
			$name = substr($name, 0, strlen($name) - strlen($extension));
			$name = translit::convert($name);
			$name .= "." . strtolower($extension);

			$new_path = $target_folder . "/" . $name;

			if($name == ".htaccess") {
				return 3;
			}

			$extension = strtolower($extension);


			if(is_uploaded_file($temp_path)) {
				$new_path = umiFile::getUnconflictPath($new_path);

				if(move_uploaded_file($temp_path, $new_path)) {
					chmod($new_path, self::$mask);

					$new_path = self::getRelPath($new_path);
					return new self::$class_name($new_path);
				} else {
					return 5;
				}
			} else {
				return 6;
			}
		}


		public static function upload($group_name, $var_name, $target_folder, $id = false) {


			$target_folder_input = $target_folder;
			if(substr($target_folder_input, strlen($target_folder_input) - 1, 1) != "/") $target_folder_input .= "/";

			$target_folder = realpath($target_folder);

			if(!is_dir($target_folder)) {
				return false;
			}

			if(!is_writable($target_folder)) {
				return false;
			}

			$aForbiddenTypes = array("php", "php3", "php4", "php5", "phtml");

			if($group_name === false && $var_name === false) {

				$name = $_REQUEST['filename'];
				$content = file_get_contents('php://input');

				list(,, $extension) = array_values(getPathInfo($name));
				$name = substr($name, 0, strlen($name) - strlen($extension));
				$name = translit::convert($name);
				$extension = strtolower($extension);

				$name .= "." . $extension;

				if($name == ".htaccess") {
					return false;
				}

				if (in_array($extension, $aForbiddenTypes)) return false;
				if (!in_array( $extension, self::$allowedFileTypes)) return false;

				$new_path = $target_folder . "/" . $name;

				if(file_put_contents($new_path, $content) == 0) {
					return false;
				}

				chmod($new_path, self::$mask);
				$new_path = self::getRelPath($new_path);
				return new self::$class_name($new_path);

			} else {
				global $_FILES;
				$files_array = &$_FILES;

				if(!is_array($files_array)) {
					return false;
				}

				if(!isset($files_array[$group_name]) && isset($files_array['pics'])) {
					$files_array[$group_name] = $files_array['pics'];
					$group_name = "pics";
				}

				if(array_key_exists($group_name, $files_array)) {

					$file_info = $files_array[$group_name];

					if(isset($file_info['size'][$var_name])) {
						$id = false;
					}

					$size = ($id === false) ?
													(isset($file_info['size'][$var_name])? $file_info['size'][$var_name] : 0)
														 :
													(isset($file_info['size'][$id][$var_name])? $file_info['size'][$id][$var_name] : 0);

					if($size == 0) {
						return false;
					} else {
						$temp_path = ($id === false) ? $file_info['tmp_name'][$var_name] : $file_info['tmp_name'][$id][$var_name];
						$name = ($id === false) ? $file_info['name'][$var_name] : $file_info['name'][$id][$var_name];	//TODO: make cyrilic to translit conversion

						if( in_array(substr($name, strrpos($name, '.')), $aForbiddenTypes) ) return false;

						list(,, $extension) = array_values(getPathInfo($name));
						$name = substr($name, 0, strlen($name) - strlen($extension));
						$name = translit::convert($name);
						$name .= "." . strtolower($extension);

						$new_path = $target_folder . "/" . $name;

						if($name == ".htaccess") {
							return false;
						}

						$extension = strtolower($extension);

						if( !in_array( $extension, self::$allowedFileTypes ) ) {
							return false;
						}

						if(is_uploaded_file($temp_path)) {
							$new_path = umiFile::getUnconflictPath($new_path);
							if(move_uploaded_file($temp_path, $new_path)) {
								chmod($new_path, self::$mask);
								$new_path = self::getRelPath($new_path);
								
								return new self::$class_name($new_path);
							} else {
								return false;
							}
						} else {
							return false;
						}
					}
				} else {
					return false;
				}
			}
		}

		// Ф-я распаковки zip-архива
		public static function upload_zip ($var_name, $file = "", $folder = "./images/cms/data/", $addWaterMark = false)  {

			if ($file == "") {
				$temp_path = $var_name['tmp_name'];
				$name = $var_name['name'];

				list(,, $extension) = array_values(getPathInfo($name));
				$name = substr($name, 0, strlen($name) - strlen($extension));
				$name = translit::convert($name);
				$name .= "." . $extension;

				$new_path = $folder.$name;
				$upload_path = CURRENT_WORKING_DIR . "/sys-temp/uploads";
				if(!is_dir($upload_path)) {
					mkdir($upload_path);
				}
				$new_zip_path = $upload_path.'/'.$name;

				if ($var_name['size'] == 0) {
					return false;
				}

				if(is_uploaded_file($temp_path)) {

						$new_path = umiFile::getUnconflictPath($new_path);
						if(move_uploaded_file($temp_path, $new_zip_path)) {
							chmod($new_zip_path, self::$mask);
						} else {
							return false;
						}
				} else {
					return false;
				}

			} else {

				$file = CURRENT_WORKING_DIR . "/" . $file;

				if (!file_exists ($file) || !is_writable($file)) return "File not exists!";

				$path_parts = getPathInfo ($file);

				if ($path_parts['extension'] != "zip") {
					return "It's not zip-file!";
				}

				$new_path = $file;
				$new_zip_path = $file;
			}

			$oldAddWaterMark = self::$addWaterMark;
			self::$addWaterMark = $addWaterMark;

			$archive = new PclZip($new_zip_path);
			
			// Проверяем, что каждый файл не превышает заданного максимального размера для изображений
			$list = $archive->listContent();
			if (count($list)<1) {
				throw new publicAdminException(getLabel('zip-file-empty'));
			}

			$upload_max_filesize = cmsController::getInstance()->getModule('data')->getAllowedMaxFileSize();
			$max_img_filesize =	regedit::getInstance()->getVal("//settings/max_img_filesize");
			
			if (!$max_img_filesize) {
				$max_img_filesize = $upload_max_filesize;
			}
			// Значение указывается в мегабайтах, нам нужны байты
			$max_img_filesize = $max_img_filesize * 1024 * 1024;
			
			$summary = 0;
			foreach($list as $key=>$oneFile) {
				$extension = strtolower(preg_replace('/^[^.]*\./', '', $oneFile['filename']));
				// Пропускаем файлы, которые не будут распаковываться
				if (!umiFile::isAllowedImageType($extension)) {
					unset($list[$key]);
					continue;
				}
				// Проверяем размер файла, не должен превышать разрешенный для изображений
				if ($oneFile['size']>$max_img_filesize) {
					throw new publicAdminException(getLabel('zip-file-image-max-size')."{$oneFile['filename']}");
				}
				
				$summary+=$oneFile['size'];
			}

			// Повторная проверка, что у нас есть файлы для обработки
			if (count($list)<1) {
				throw new publicAdminException(getLabel('zip-file-images-absent'));
			}

			// Проверяем, что у нас есть место для распаковки изображений
			if (!checkAllowedDiskSize($summary)) {
				throw new publicAdminException(getLabel('zip-file-images-no-free-size'));
			}

			$list = $archive->extract(PCLZIP_OPT_PATH, $folder,
				PCLZIP_CB_PRE_EXTRACT, "callbackPreExtract",
				PCLZIP_CB_POST_EXTRACT, "callbackPostExtract",
				PCLZIP_OPT_REMOVE_ALL_PATH);

			self::$addWaterMark = $oldAddWaterMark;

			if (!is_array ($list)) {
				throw new coreException ("Zip extracting error: ".$archive->errorInfo(true));
			}

			// unlink zip
			if(is_writable($new_zip_path)) {
				unlink($new_zip_path);
			}

			return $list;
		}

		/**
			* Получить название файла
			* @return String название файла
		*/
		public function getFileName() {
			return $this->name;
		}

		/**
			* Получить путь директорию, в которой лежит файл
			* @return String адрес директории, в которой лежит файл относительно UNIX TIMESTAMP
		*/
		public function getDirName() {
			return $this->dirname;
		}

		/**
			* Получить время последней модификации файла
			* @return Integer время последней модификации файла в UNIX TIMESTAMP
		*/
		public function getModifyTime() {
			return $this->modify_time;
		}

		/**
			* Получить расширение файла
			* @return String расширение файла
		*/
		public function getExt() {
			return $this->ext;
		}

		/**
			* Получить размер файла
			* @return Integer размер файла в байтах
		*/
		public function getSize() {
			return $this->size;
		}

		/**
			* Получить путь до файла в файловой системе
			* @param Boolean $web_mode если true, то путь будет указан относительно DOCUMENT_ROOT'а
			* @return String путь до файла
		*/
		public function getFilePath($web_mode = false) {
			if($web_mode) {
				$sIncludePath = ini_get("include_path");
				if ($sIncludePath!='.' && substr($this->filepath, 0, strlen($sIncludePath)) === $sIncludePath) {
					return "/" . substr($this->filepath, strlen($sIncludePath));
				}
				$sIncludePath = CURRENT_WORKING_DIR;
				if (substr($this->filepath, 0, strlen($sIncludePath)) === $sIncludePath) {
					return substr($this->filepath, strlen($sIncludePath));
				}
				return (substr($this->filepath, 0, 2) == "./") ? ("/" . substr($this->filepath, 2, strlen($this->filepath) - 2)) : $this->filepath;
			} else {
				return $this->filepath;
			}
		}

		private function loadInfo() {
			if(!is_file($this->filepath)) {
				$this->is_broken = true;
				return false;
			}

			if(!is_readable($this->filepath)) {
				$this->is_broken = true;
				return false;
			}

			$pathinfo = getPathInfo($this->filepath);

			$this->modify_time = filemtime($this->filepath);
			$this->size = filesize($this->filepath);
			$this->dirname = $pathinfo['dirname'];
			$this->name = $pathinfo['basename'];
			$this->ext = strtolower(getArrayKey($pathinfo, 'extension'));

			if($this->ext == "php" || $this->ext == "php5" || $this->ext == "phtml") {
				$this->is_broken = true;
			}

			if($this->name == ".htaccess") {
				$this->is_broken = true;
			}
		}

		public function __toString() {
			$filepath = $this->getFilePath(true);
			return is_null($filepath) ? "" : $filepath;
		}

		/**
			* Узнать, все ли в порядке с файлом, на который ссылается объект umiFile
			* @return Boolean true, если нет ошибок
		*/
		public function getIsBroken() {
			return (bool) $this->is_broken;
		}


		public static function getUnconflictPath($new_path) {
			if(!file_exists($new_path)) {
				return $new_path;
			} else {
				$info = getPathInfo($new_path);
				$dirname = $info['dirname'];
				$filename = $info['filename'];
				$ext = $info['extension'];

				for($i = 1; $i < 257; $i++) {
					$new_path = $dirname . "/" . $filename . $i . "." . $ext;
					if(!file_exists($new_path)) {
						return $new_path;
					}
				}
				throw new coreException("This is really hard to happen");
			}
		}


		protected static function getRelPath($path) {
			$cwd = realpath(getcwd());
			return "." . substr(realpath($path), strlen($cwd));
		}

		public static function getAddWaterMark() {
			return self::$addWaterMark;
		}
		
		public static function isAllowedImageType($extension) {
			return in_array($extension, self::$allowedImageTypes);
		}
		
	};


// Контроль извлекаемых из zip-архива файлов
function callbackPreExtract ($p_event, &$p_header) {
	$info = getPathInfo($p_header['filename']);

	$extension = strtolower($info['extension']);
	if (!umiFile::isAllowedImageType($extension)) {
		return 0;
	}

	$basename = substr($info['basename'], 0, (strlen($info['basename']) - strlen($info['extension']))-1);
	$basename = translit::convert($basename);
	$p_header['filename'] = $info['dirname']."/".$basename.".".$info['extension'];

	$p_header['filename'] = umiFile::getUnconflictPath($p_header['filename']);

	return 1;
}

function callbackPostExtract ($p_event, &$p_header) {

	$info = getPathInfo($p_header['stored_filename']);
	$extension = strtolower($info['extension']);
	$filename = $p_header['filename'];

	if (!umiFile::isAllowedImageType($extension)) {
		unlink ($filename);
	} else {
		$imgSize = @getimagesize($filename);
		if (!is_array($imgSize)) {
			@unlink($filename);
	}

		if(umiFile::getAddWaterMark()) {
			if (umiImageFile::addWatermark($filename) !== false) return 1;
		}

		$jpgThroughGD = (bool) mainConfiguration::getInstance()->get("kernel", "jpg-through-gd");
		if ($jpgThroughGD) {
			if ($extension == 'jpg' || $extension == 'jpeg'){
				$res = imagecreatefromjpeg($filename);
				if($res) {
					imagejpeg($res, $filename, 100);
					imagedestroy($res);
				}
			}
		}
	}

	return 1;
}


	interface iUmiImageFile {
		public function getWidth();
		public function getHeight();
	}


/**
	* Класс для работы с файлами изображений, наследуется от класса umiFile
*/
	class umiImageFile extends umiFile implements iUmiImageFile {
		private static $aSupportedTypes = null;
		private static $useWatermark = false;
		private static $CurrentBit = 0;

		/**
			* Конструктор, принимает в качестве аргумента путь до файла в локальной файловой системе.
			* @param String $filepath путь до файла в локальной файловой системе
		*/
		public function __construct($filepath) {
			parent::__construct($filepath);
			if (!$this->is_broken) {
				$this->is_broken = ! self::getIsImage($this->name);
			}

		}

		/**
			* Получить список поддерживаемых расширений файлов
			* @return Array массив, стостоящий из допустимых расширений файлов изображений
		*/
		public static function getSupportedImageTypes() {
			if (is_null(self::$aSupportedTypes)) {
				self::$aSupportedTypes = array();
				self::$aSupportedTypes[] = "GIF";
				self::$aSupportedTypes[] = "JPG";
				self::$aSupportedTypes[] = "JPEG";
				self::$aSupportedTypes[] = "PNG";
				self::$aSupportedTypes[] = "WBMP";
				self::$aSupportedTypes[] = "BMP";
				self::$aSupportedTypes[] = "SWF";
			}

			return self::$aSupportedTypes;
		}
		
		/**
			* Указывает на необходимость добавления водного знака к следующей загружаемой картинке
		*/
		public static function setWatermarkOn () {
			self::$useWatermark = true;
		}
		/**
			* Отключает водный знак
		*/
		public static function setWatermarkOff () {
			self::$useWatermark = false;
		}

		/**
			* Загрузить файл из запроса и сохранить локально. Информация о файле берется из массива $_FILES[$group_name]["size"][$var_name]
			* @param String $group_name
			* @param String $var_name
			* @param String $target_folder локальная папка, в которую необходимо сохранить файл
			* @return Boolean true в случае успеха
		*/
		public static function upload($group_name, $var_name, $target_folder, $id = false) {
			self::$class_name = __CLASS__;		
			$filepath = parent::upload($group_name, $var_name, $target_folder, $id);
			
			$regedit = regedit::getInstance();
			$max_img_filesize = (int) $regedit->getVal("//settings/max_img_filesize");
			$upload_max_filesize = (int) ini_get("upload_max_filesize");
			$max_img_filesize = ($max_img_filesize < $upload_max_filesize) ? $max_img_filesize : $upload_max_filesize;

			$filesize = (int) filesize("." . $filepath);
			$max_img_filesize = (int) $max_img_filesize*1024*1024;
			
			if($max_img_filesize > 0) {
				if($max_img_filesize < $filesize) {
					unlink("." . $filepath);
					return false;
				}
			}
			
			$info = @getimagesize(".".$filepath);
			if(!is_array($info)) {
				@unlink("." . $filepath);
				return false;				
			}
			
			//Пропуск через GD, чтобы избавиться от EXIF
			$jpgThroughGD = (bool) mainConfiguration::getInstance()->get("kernel", "jpg-through-gd");
			if ($jpgThroughGD) {

				list(,, $extension) = array_values(getPathInfo("." . $filepath));
				$extension = strtolower($extension);
				if ($extension == 'jpg' || $extension == 'jpeg'){
					$res = imagecreatefromjpeg("." . $filepath);
					if ($res) {
						imagejpeg($res, "." . $filepath, 100);
						imagedestroy($res);
					} else {
						return false;
					}
				}
			}

			// Если нужно добавляем водяной знак и отключаем его для следующих изображений
			if (self::$useWatermark) {
				self::addWatermark ("./".$filepath);
			}
			self::setWatermarkOff ();
			
			return $filepath;
		}
		
		/**
			* Проверить, является ли файл допустимым изображением
			* @param String $sFilePath путь до файла, который необходимо проверить
			* @return Boolean true, если файл является изображением
		*/
		public static function getIsImage($sFilePath) {
			$arrFParts = explode(".", $sFilePath);
			$sFileExt = strtoupper(array_pop($arrFParts));
			return in_array($sFileExt, self::getSupportedImageTypes());
		}

		public function getWidth() {			
			list($width, $height) = getimagesize($this->filepath);
			return $width;
		}

		public function getHeight() {
			list($width, $height) = getimagesize($this->filepath);
			return $height;
		}
		
		/**
			* Добавляет водный знак на изображение
			* @param string $filePath путь до изображения
			* @return boolean
		*/
		public static function addWatermark ($filePath) {
			if (!empty($_REQUEST['disable_watermark'])) return false;
			
			$regedit = regedit::getInstance ();
		
			$srcWaterImage = $regedit->getVal ("//settings/watermark/image");
			$alphaWaterImage = $regedit->getVal ("//settings/watermark/alpha");
			$valignWaterImage = $regedit->getVal ("//settings/watermark/valign");
			$halignWaterImage = $regedit->getVal ("//settings/watermark/halign");
			
			if (!file_exists ($srcWaterImage)) {
				return false;
			}
			if (!$alphaWaterImage) { 
				$alphaWaterImage = 100;
			}
			if (!$valignWaterImage) { 
				$valignWaterImage = "bottom";
			}
			if (!$halignWaterImage) {
				$halignWaterImage = "right";
			}

			$waterImgParam = self::createImage ($srcWaterImage);
			$srcImgParam = self::createImage ($filePath);
			$imageFileInfo = getPathInfo ($filePath);
			
			if (!$waterImgParam || !$srcImgParam) {
				return false;
			}
			
			$x_ins = 0;
			$y_ins = 0;
			
			switch ($halignWaterImage){
				case "center" : {
					$x_ins = floor (($srcImgParam["width"] - $waterImgParam["width"]) / 2);
					break;
				}
				case "right" : {
					$x_ins = $srcImgParam["width"] - $waterImgParam["width"];
				}
			}
			switch ($valignWaterImage) {
				case "center" : {
					$y_ins = floor (($srcImgParam["height"] - $waterImgParam["height"]) / 2);
					break;
				}
				case "bottom" : {
					$y_ins = $srcImgParam["height"] - $waterImgParam["height"];
				}
			}

			$tmp = $waterImgParam['im'];
			
			$cut = imagecreatetruecolor($waterImgParam["width"], $waterImgParam["height"]);
			imagecopy($cut, $srcImgParam['im'], 0, 0, $x_ins , $y_ins, $waterImgParam["width"], $waterImgParam["height"]);
			imagecopy($cut, $tmp, 0, 0, 0, 0, $waterImgParam["width"], $waterImgParam["height"]);
			
			imagecopymerge($srcImgParam['im'], $cut, $x_ins , $y_ins, 0, 0, $waterImgParam["width"], $waterImgParam["height"], $alphaWaterImage);

			switch ($imageFileInfo['extension']) {
				case "jpeg" :
				case "jpg"  :
				case "JPEG" :
				case "JPG"  : {
					imagejpeg ($srcImgParam['im'], $filePath, 90);
					break;
				}
				case "png" :
				case "PNG" : {
					imagepng ($srcImgParam['im'], $filePath);
				}
				case "gif" :
				case "GIF" : {
					imagegif ($srcImgParam['im'], $filePath);
					break;
				}
				case "bmp" :
				case "BMP" :
					imagewbmp($srcImgParam['im'], $filePath);
					break;
			}
			
			imagedestroy ($srcImgParam["im"]);
			imagedestroy ($waterImgParam["im"]);
			
			return;

		}
		
		/**
			* Создает и возвращает индентификатор изображения
			* @param string $imageFilePath путь до изображения
			* @return array массив: индентификатор (im), ширина (width), высота (height)
		*/
		public static function createImage ($imageFilePath) {
			$imageFilePath = str_replace(CURRENT_WORKING_DIR, '', $imageFilePath);

			$image_identifier = 0;
			$pathinfo = parse_url ($imageFilePath);

			$imageFilePath = (substr ($pathinfo["path"], 0, 1) == "/")
								? substr ($pathinfo["path"], 1)
								: $pathinfo["path"];
								
			list ($width, $height, $type, $attr) = getimagesize ($imageFilePath);

			$types = array (
				"GIF" => "1",
				"JPG" => "2",
				"PNG" => "3",
				"BMP" => "6",
				"WBMP"=> "15",
				"XBM" => "16"
			);
			
			switch($type){
				case $types["GIF"] : {
					$image_identifier = imagecreatefromgif ($imageFilePath);
					break;
				}				
				case $types["JPG"] : {
					$image_identifier = imagecreatefromjpeg ($imageFilePath);
					break;
				}
				case $types["PNG"] : {
					$image_identifier = imagecreatefrompng ($imageFilePath);
					break;
				}
				case $types["BMP"] : {
					$image_identifier = self::imagecreatefrombmp($imageFilePath);
					break;
				}
				case $types["WBMP"] : {
					$image_identifier = imagecreatefromwbmp ($imageFilePath);
					break;
				}
				case $types["XBM"]: {
					$image_identifier = imagecreatefromxbm ($imageFilePath);
				}	
			}
			
			if (!$image_identifier) {
				return false;
			}
				
			return array (
				"im"     => $image_identifier,
				"width"  => $width,
				"height" => $height
			);
		}
		
		
		/** Создает изображение из bmp, т.к. встроенная поддержка в php отсутствует
			* Нарыто на просторах интернета
			* @param string $file путь до изображения
			* @return resource type image идентификатор изображения
		*/
		private static function imagecreatefrombmp($file) {
			$f=fopen($file,"r");
			$Header=fread($f,2);

			if($Header=="BM") {
				$Size=self::freaddword($f);
				$Reserved1=self::freadword($f);
				$Reserved2=self::freadword($f);
				$FirstByteOfImage=self::freaddword($f);

				$SizeBITMAPINFOHEADER=self::freaddword($f);
				$Width=self::freaddword($f);
				$Height=self::freaddword($f);
				$biPlanes=self::freadword($f);
				$biBitCount=self::freadword($f);
				$RLECompression=self::freaddword($f);
				$WidthxHeight=self::freaddword($f);
				$biXPelsPerMeter=self::freaddword($f);
				$biYPelsPerMeter=self::freaddword($f);
				$NumberOfPalettesUsed=self::freaddword($f);
				$NumberOfImportantColors=self::freaddword($f);
	
				if($biBitCount<24) {
					$img=imagecreate($Width,$Height);
					$Colors=pow(2,$biBitCount);
					for($p=0;$p<$Colors;$p++) {
						$B=self::freadbyte($f);
						$G=self::freadbyte($f);
						$R=self::freadbyte($f);
						$Reserved=self::freadbyte($f);
						$Palette[]=imagecolorallocate($img,$R,$G,$B);
					}
         
					if($RLECompression==0) {
						$Zbytek=(4-ceil(($Width/(8/$biBitCount)))%4)%4;
	
						for($y=$Height-1;$y>=0;$y--) {
							$CurrentBit=0;
							for($x=0;$x<$Width;$x++) {
								$C=self::freadbits($f,$biBitCount);
								imagesetpixel($img,$x,$y,$Palette[$C]);
							}
							if($CurrentBit!=0) {
								self::freadbyte($f);
							}
							for($g=0;$g<$Zbytek;$g++) {
								self::freadbyte($f);
							}
						}
					}
				}

		      if($RLECompression==1) {
					$y=$Height;
					$pocetb=0;
				
					while(true) {
						$y--;
						$prefix=self::freadbyte($f);
						$suffix=self::freadbyte($f);
						$pocetb+=2;
						$echoit=false;

						if ($echoit) {
							//echo "Prefix: $prefix Suffix: $suffix<BR>";
							if ( ($prefix==0) && ($suffix==1) ) break;
							if ( feof($f) ) break;

							while(!(($prefix==0)and($suffix==0))) {
								if($prefix==0) {
									$pocet=$suffix;
									$Data.=fread($f,$pocet);
									$pocetb+=$pocet;
									if($pocetb%2==1) {
										self::freadbyte($f); $pocetb++;
									}                     
								}
                  
								if($prefix>0) {
									$pocet=$prefix;
									for($r=0;$r<$pocet;$r++) {
										$Data.=chr($suffix);                     
									}
								}
								
							}
		            
							$prefix=self::freadbyte($f);
							$suffix=self::freadbyte($f);
							$pocetb+=2;
							//if($echoit) echo "Prefix: $prefix Suffix: $suffix<BR>";
						}

						for($x=0;$x<strlen($Data);$x++) {
							imagesetpixel($img,$x,$y,$Palette[ord($Data[$x])]);
						}
		         
						$Data="";
	
					}
				}


				if($RLECompression==2) {
					$y=$Height;
					$pocetb=0;
		      
					while(true) {                
						$y--;
						$prefix=self::freadbyte($f);
						$suffix=self::freadbyte($f);
						$pocetb+=2;
						$echoit=false;

						//if ($echoit) echo "Prefix: $prefix Suffix: $suffix<BR>";
						if ( ($prefix==0) and ($suffix==1) ) break;
						if ( feof($f) ) break;
	
						while(!(($prefix==0)and($suffix==0))) {
							if($prefix==0) {
								$pocet=$suffix;
								$CurrentBit=0;
								for($h=0;$h<$pocet;$h++) {
									$Data.=chr(self::freadbits($f,4));
								}
		                     
								if ($CurrentBit!=0) self::freadbits($f,4);
		               
								$pocetb+=ceil(($pocet/2));
		               
								if($pocetb%2==1) {
								   self::freadbyte($f);
								   $pocetb++;
								}
		                 
							}
		            
							if($prefix>0) {
								$pocet=$prefix;
								$i=0;
		               
								for($r=0;$r<$pocet;$r++) {
								   if($i%2==0) {
								      $Data.=chr($suffix%16);
								   }
								   else {
								      $Data.=chr(floor($suffix/16));
								   }
		                  $i++;
								}
							}
               
							$prefix=self::freadbyte($f);
							$suffix=self::freadbyte($f);
							$pocetb+=2;
							//if ($echoit) echo "Prefix: $prefix Suffix: $suffix<BR>";
						}
	
						for($x=0;$x<strlen($Data);$x++) {
						   imagesetpixel($img,$x,$y,$Palette[ord($Data[$x])]);
						}
		             
						$Data="";
					}
				}

				if($biBitCount==24) {
					$img=imagecreatetruecolor($Width,$Height);
					$Zbytek=$Width%4;
	
					for($y=$Height-1;$y>=0;$y--) {
					   for($x=0;$x<$Width;$x++) {
					      $B=self::freadbyte($f);
						   $G=self::freadbyte($f);
					      $R=self::freadbyte($f);
					      $color=imagecolorexact($img,$R,$G,$B);
					      
					      if($color==-1) $color=imagecolorallocate($img,$R,$G,$B);
					      
					      imagesetpixel($img,$x,$y,$color);
					   }
			      
					   for($z=0;$z<$Zbytek;$z++) {
					      self::freadbyte($f);
					   }
					}
				}
			
				fclose($f);   
				return $img;
			}
			fclose($f);		
		}
		
		private static function freaddword($f) {
			$b1=self::freadword($f);
		   $b2=self::freadword($f);
		   return $b2*65536+$b1;
		}

		private static function freadword($f) {
		   $b1=self::freadbyte($f);
		   $b2=self::freadbyte($f);
		   return $b2*256+$b1;
		}

		private static function freadbyte($f) {
		    return ord(fread($f,1));
		}		
		
		private static function freadbits($f,$count) {
			$Byte=freadbyte($f);
			$LastCBit = self::$CurrentBit;
			
			self::$CurrentBit += $count;
			if (self::$CurrentBit==8) {
				self::$CurrentBit=0;
			}
			else {
				fseek($f,ftell($f)-1);
			}
			return RetBits($Byte,$LastCBit,$count);
		}

		private static function RetBits($byte,$start,$len) {
			$bin=decbin8($byte);
			$r=bindec(substr($bin,$start,$len));
			return $r;
		}
		
	}
	
	



	interface iUmiDirectory {
		public function getPath();
		public function getName();

		public function getIsBroken();
		public function getFSObjects($objectType = 0, $mask = "", $onlyReadable = false);
		public function getFiles($mask = "", $onlyReadable = false);
		public function getDirectories($mask = "", $onlyReadable = false);

		public function getAllFiles($i_obj_type=0, $s_mask="", $b_only_readable=false);

		public function delete($recursion = true);

		public static function requireFolder($folder, $basedir = "");
	};




/**
	* Предоставляет интерфейс для работы с директориями
	* Использует итератор umiDirectoryIterator
*/

class umiDirectory implements iUmiDirectory, IteratorAggregate {
	protected $s_dir_path = "";
	protected $is_broken = false;
	protected $arr_files = array();
	protected $arr_dirs = array();
	protected $arr_objs = array();
	protected $is_readed = false;

	/**
		* Конструктор
		* @param String $s_dir_path путь к директории
	*/
	public function __construct($s_dir_path) {

		while (substr($s_dir_path, -1)=="/") $s_dir_path=substr($s_dir_path, 0, (strlen($s_dir_path)-1));

		if(is_dir($s_dir_path)) {
			$this->s_dir_path = $s_dir_path;
		} else {
			$this->is_broken = true;
			return false;
		}
	}

	/**
		* Возвращает путь к директории
		* @param String $s_dir_path путь к директории
		* @return String путь к директории
	*/
	public function getPath() {
		return $this->s_dir_path;
	}

	/**
		* Возвращает имя директории
		* @return String имя директории
	*/
	public function getName() {
		$arrDirPath = explode("/", $this->s_dir_path);
		return array_pop($arrDirPath);
	}

	public function getIterator() {
		$this->read();
		return new umiDirectoryIterator($this->arr_objs);
	}

	private function read() {
		if($this->is_readed) {
			return false;
		} else {
			$this->is_readed = true;
		}

		$this->arr_files = array();
		$this->arr_dirs = array();

		if($cache = self::cache($this->s_dir_path)) {
			list($this->arr_files, $this->arr_dirs, $this->arr_objs) = $cache;
			return;
		}

		if (is_dir($this->s_dir_path) && is_readable($this->s_dir_path)) {
			if ($rs_dir = opendir($this->s_dir_path)) {
				$s_next_file = "";
				while (($s_next_obj = readdir($rs_dir)) !== false) {
					if(defined("CURRENT_VERSION_LINE")) {
						if(CURRENT_VERSION_LINE == "demo") {
							if($s_next_obj == "demo") continue;
						}
					}
					$s_obj_path = $this->s_dir_path."/".$s_next_obj;
					if (is_file($s_obj_path)) {
						$this->arr_files[$s_next_obj] = $s_obj_path;
						$this->arr_objs[] = $s_obj_path;
					} elseif (is_dir($s_obj_path) && $s_next_obj != ".." && $s_next_obj != ".") {
						$this->arr_dirs[$s_next_obj] = $s_obj_path;
						$this->arr_objs[] = $s_obj_path;
					}
				}

				if(isset($s_dir)) {
					closedir($s_dir);
				}
			}
		}

		self::cache($this->s_dir_path, Array($this->arr_files, $this->arr_dirs, $this->arr_objs));
	}


	/**
		* Проверяет существует ли директория
		* @return Boolean true, если директория не существует
	*/
	public function getIsBroken() {
		return (bool) $this->is_broken;
	}

	/**
		* Читает директорию и возвращает массив объектов файловой системы
		* @param Integer $i_obj_type тип, который хотим получить: 1 - real files, 2 - directories, 0 - files & directories
		* @param String $s_mask="" маска по которой выбирать объекты
		* @param Boolean $b_only_readable=false сделать проверку на чтение и вернуть только объекты, доступные на чтение
		* @return Array массив объектов файловой системы. Ключ массива - имя объекта, значение - полный путь к нему
	*/
	public function getFSObjects($i_obj_type=0, $s_mask="", $b_only_readable=false) {
		$this->read();

		$arr_result =array();
		$arr_objs = array();

		switch ($i_obj_type) {
			case 1:									//1: real files
					$arr_objs = $this->arr_files;
				break;
			case 2:									//2: directories
					$arr_objs = $this->arr_dirs;
				break;
			default:
					$arr_objs = array_merge($this->arr_dirs, $this->arr_files);
		}

		foreach ($arr_objs as $s_obj_name => $s_obj_path) {
			if ((!$b_only_readable || is_readable($s_obj_path)) && (!strlen($s_mask)) || preg_match("/".$s_mask."/i", $s_obj_name)) {
				$arr_result[$s_obj_name] = $s_obj_path;
			}
		}

		ksort ($arr_result);
		return $arr_result;
	}

	/**
		* Читает директорию и возвращает массив файлов в директории
		* @param String $s_mask="" маска по которой выбирать файлы
		* @param Boolean $b_only_readable=false сделать проверку на чтение и вернуть только файлы, доступные на чтение
		* @return Array массив файлов. Ключ массива - имя файла, значение - полный путь к нему
	*/
	public function getFiles($s_mask="", $b_only_readable=false) {
		return $this->getFSObjects(1, $s_mask, $b_only_readable);
	}

	/**
		* Читает директорию и возвращает массив поддиректорий
		* @param String $s_mask="" маска по которой выбирать директории
		* @param Boolean $b_only_readable=false сделать проверку на чтение и вернуть только файлы, доступные на чтение
		* @return Array массив директорий. Ключ массива - имя директории, значение - полный путь к ней
	*/
	public function getDirectories($s_mask="", $b_only_readable=false) {
		return $this->getFSObjects(2, $s_mask, $b_only_readable);
	}

	/**
		* Читает директорию и возвращает массив всех вложенных файлов и директорий на всю глубину
		* @param Integer $i_obj_type тип, который хотим получить: 1 - real files, 2 - directories, 0 - files & directories
		* @param String $s_mask="" маска по которой выбирать объекты
		* @param Boolean $b_only_readable=false сделать проверку на чтение и вернуть только объекты, доступные на чтение
		* @return Array массив объектов файловой системы. Ключ массива - полный путь к нему объекта, значение - имя
	*/
	public function getAllFiles($i_obj_type=0, $s_mask="", $b_only_readable=false) {
		$files = $this->getFSObjects($i_obj_type, $s_mask, $b_only_readable);
		$result = array_flip($files);

		$dirs = $this->getFSObjects(2, $s_mask, $b_only_readable);
		foreach ($dirs as $dir) {
			$dir = new umiDirectory($dir);
			$dirFiles = $dir->getAllFiles($i_obj_type, $s_mask="", $b_only_readable);
			$result = array_merge($result, $dirFiles);
		}
		return $result;
	}

	/**
		* Удалить директорию
		* @param Boolean $recursion = false удалить рекурсивно вместе со всем содержанием
	*/
	public function delete($recursion = false) {
		if(is_writable($this->s_dir_path)) {
			if($recursion) {
				foreach($this as $item) {
					if($item instanceof umiDirectory) {
						$item->delete(true);
					} else if ($item instanceof umiFile) {
						$item->delete();
					}
				}
			}
			return @rmdir($this->s_dir_path);
		} else {
			return false;
		}
	}

	/**
	    * Убедиться, что директория $folder существует, если нет, то создать ее
	    * @param String $folder проверяемая директория
	    * @param String $basedir = "" родительский кактог, который должен содержать проверяемую директорию
	    * @return Boolean true, если директория существует, либо успешно создана
	*/
	public static function requireFolder($folder, $basedir = "") {
	    if(!$folder) return false;

	    if(is_dir($folder) == false) {
	        mkdir($folder, 0777, true);
	    }

	    $realpath = realpath($folder);
	    $basedir = realpath($basedir);
	    return (substr($realpath, 0, strlen($basedir)) == $basedir);

	}

	public function __toString() {
		return "umiDirectory::{$this->s_dir_path}";
	}

	protected static function cache($key, $value = NULL) {
		static $cache = Array();

		if($value) {
			return $cache[$key] = $value;
		}

		if(isset($cache[$key])) {
			return $cache[$key];
		} else {
			return NULL;
		}
	}
}


class umiDirectoryIterator implements Iterator {

	private $arr_objs = array();


	public function __construct($arr_objs) {
		if (is_array($arr_objs)) {
			$this->arr_objs = $arr_objs;
		}
	}

	public function rewind() {
		reset($this->arr_objs);
	}

	public function current() {
		$oResult = null;
		$s_obj_path = current($this->arr_objs);
		if (is_file($s_obj_path)) {
			if (umiImageFile::getIsImage($s_obj_path)) {
				$oResult = new umiImageFile($s_obj_path);
			} else {
				$oResult = new umiFile($s_obj_path);
			}
		} elseif (is_dir($s_obj_path)) {
			$oResult = new umiDirectory($s_obj_path);
		}

		return $oResult;
	}

	public function key() {
		return current($this->arr_objs);
	}

	public function next() {
		$oResult = null;
		$s_obj_path = next($this->arr_objs);
		if (is_file($s_obj_path)) {
			if (umiImageFile::getIsImage($s_obj_path)) {
				$oResult = new umiImageFile($s_obj_path);
			} else {
				$oResult = new umiFile($s_obj_path);
			}
		} elseif (is_dir($s_obj_path)) {
			$oResult = new umiDirectory($s_obj_path);
		}

		return $oResult;
	}

	public function valid() {
		return !is_null($this->current());
	}
}



/**
	* Предоставляет досуп к свойствам языка. Язык в системе в основном обозначает языковую версию.
*/
	class lang extends umiEntinty implements iUmiEntinty, iLang {
		private $prefix, $is_default, $title;
		protected $store_type = "lang";

		/**
			* Загрузить информацию о свойствах языка из БД
			* @return Boolean true, если не возникло никаких ошибок
		*/
		protected function loadInfo($row = false) {
			if($row === false) {
				$sql = "SELECT id, prefix, is_default, title FROM cms3_langs WHERE id = '{$this->id}'";
				$result = l_mysql_query($sql);
				
				$row = mysql_fetch_row($result);
			}

			if(list($id, $prefix, $is_default, $title) = $row) {
				$this->prefix = $prefix;
				$this->title = $title;
				$this->is_default = (bool) $is_default;

				return true;
			} else {
				return false;
			}
		}

		/**
			* Получить название языка
			* @return String название языка
		*/
		public function getTitle() {
			return $this->title;
		}

		/**
			* Получить префикс языка (его 2х или 3х символьный код)
			* @return String префикс языка
		*/
		public function getPrefix() {
			return $this->prefix;
		}

		/**
			* Узнать, является ли этот язык языком по умолчанию (больше не используется)
		*/
		public function getIsDefault() {
			return $this->is_default;
		}

		/**
			* Установить новое название языка
			* @param String $title название языка
		*/
		public function setTitle($title) {
			$this->title = $title;
			$this->setIsUpdated();
		}

		/**
			* Установить новый префикс для языка
			* @param $prefix префикс языка
		*/
		public function setPrefix($prefix) {
			$this->prefix = $prefix;
			$this->setIsUpdated();
		}

		/**
			* Установить флаг "по умолчанию" (больше не используется)
			* @param Boolean $is_default флаг "по умолчанию"
		*/
		public function setIsDefault($is_default) {
			$this->is_default = (bool) $is_default;
			$this->setIsUpdated();
		}

		/**
			* Сохранить изменения в БД
			* @return Boolean true, если не произошло ошибок
		*/
		protected function save() {
			$title = self::filterInputString($this->title);
			$prefix = self::filterInputString($this->prefix);
			$prefix = $this->filterPrefix($prefix);
			$is_default = (int) $this->is_default;

			$sql = "UPDATE cms3_langs SET prefix = '{$prefix}', is_default = '{$is_default}', title = '{$title}' WHERE id = '{$this->id}'";
			l_mysql_query($sql);
			return true;
		}
		
		/**
			* Убрать символы, недопустимые в префиксе языка
			* @param String $prefix префикс языка
			* @return String отфильтрованный результат
		*/
		protected function filterPrefix($prefix) {
			return preg_replace("/[^A-z0-9_\-]+/", "", $prefix);
		}
	}


/**
	* Используется для управления языками (класс lang), которые функционально представляют языковыми версиями сайта.
	* Класс является синглтоном, получить экземпляр класса можно через статический метод getInstance().
*/
	class langsCollection extends singleton implements iSingleton, iLangsCollection {
		private $langs = Array(),
			$def_lang;

		/**
			* Конструктор, подгружает список языков
		*/
		protected function __construct() {
			$this->loadLangs();
		}

		/**
			* Получить экземпляр коллекции
			* @return langsCollection экземпляр класса langsCollection
		*/
		public static function getInstance($c = NULL) {
			return parent::getInstance(__CLASS__);
		}

		/**
			* Загрузить список языков из БД
		*/
		private function loadLangs() {
			$cacheFrontend = cacheFrontend::getInstance();

			$langIds = $cacheFrontend->loadData('langs_list');
			if(!is_array($langIds)) {
				$sql = "SELECT id, prefix, is_default, title FROM cms3_langs ORDER BY id";
				$result = l_mysql_query($sql);
				$langIds = array();
				while(list($lang_id) = $row = mysql_fetch_row($result)) {
					$langIds[$lang_id] = $row;
				}
				$cacheFrontend->saveData('langs_list', $langIds, 3600);
			} else $row = false;

			foreach($langIds as $lang_id => $row) {
				$lang = $cacheFrontend->load($lang_id, 'lang');
				if($lang instanceof lang == false) {
					try {
						$lang = new lang($lang_id, $row);
					} catch (privateException $e) { continue; }

					$cacheFrontend->save($lang, 'lang');
				}

				$this->langs[$lang_id] = $lang;
				if($this->langs[$lang_id]->getIsDefault()) {
					$this->def_lang = $this->langs[$lang_id];
				}
			}
		}

		/**
			* Получить id языка (класс lang) по его префиксу
			* @param String $prefix префикс языка (его 2х-3х символьный код)
			* @return lang язык, либо false если языка с таким префиксом не существует
		*/
		public function getLangId($prefix) {
			foreach($this->langs as $lang) {
				if($lang->getPrefix() == $prefix) {
					return $lang->getId();
				}
			}
			return false;
		}

		/**
			* Создать новый язык
			* @param String $prefix префикс языка
			* @param String $title название языка
			* @param Boolean $is_default=false сделать языком по умолчанию (на данный момент не должно возникнуть необходимости ставить в true)
			* @return Integer id созданного языка, либо false
		*/
		public function addLang($prefix, $title, $is_default = false) {
			$this->disableCache();
			cacheFrontend::getInstance()->flush();

			if($lang_id = $this->getLangId($prefix)) {
				return $lang_id;
			}

			$sql = "INSERT INTO cms3_langs VALUES()";
			l_mysql_query($sql);
			$lang_id = l_mysql_insert_id();

			$lang = new lang($lang_id);

			$lang->setPrefix($prefix);
			$lang->setTitle($title);
			$lang->setIsDefault($is_default);

			$lang->commit();

			$this->langs[$lang_id] = &$lang;

			return $lang_id;
		}

		/**
			* Удалить язык с id $lang_id
			* @param id $lang_id языка, который необходимо удалить
			* @return Boolean true, если удаление прошло успешно
		*/
		public function delLang($lang_id) {
			$this->disableCache();
			cacheFrontend::getInstance()->flush();

			$lang_id = (int) $lang_id;

			if(!$this->isExists($lang_id)) return false;

			$sql = "DELETE FROM cms3_langs WHERE id = '{$lang_id}'";
			l_mysql_query($sql);
			unset($this->langs[$lang_id]);
		}

		/**
			* Получить язык (экземпляр касса lang) по его id
			* @param Integer $lang_id id языка
			* @return lang язык (экземпляр касса lang), либо false
		*/
		public function getLang($lang_id) {
			$lang_id = (int) $lang_id;
			return ($this->isExists($lang_id)) ? $this->langs[$lang_id] : false;
		}

		/**
			* Узнать, существует ли в системе язык с id $lang_id
			* @param Integer $lang_id id языка
			* @return Boolean true, если язык существует
		*/
		public function isExists($lang_id) {
			return (bool) @array_key_exists($lang_id, $this->langs);
		}

		/**
			* Получить список всех языков в системе
			* @return Array массив, значением которого являются экземпляры класса lang
		*/
		public function getList() {
			return $this->langs;
		}

		/**
			* Установить язык по умолчанию
			* @param Integer $lang_id id языка
		*/
		public function setDefault($lang_id) {
			if(!$this->isExists($lang_id)) return false;

			if($this->def_lang) {
				$this->def_lang->setIsDefault(false);
				$this->def_lang->commit();
			}

			$this->def_lang = $this->getLang($lang_id);
			$this->def_lang->setIsDefault(true);
			$this->def_lang->commit();
		}

		/**
			* Получить язык по умолчанию
			* @return lang экземпляр класса lang, либо false в случае неудачи
		*/
		public function getDefaultLang() {
			return ($this->def_lang) ? $this->def_lang : false;
		}

		/**
			* Получить список всех языков в системе в виде ассоциотивного массива
			* @return Array массив, где ключ это id языка, а значение - его название
		*/
		public function getAssocArray() {
			$res = array();

			foreach($this->langs as $lang) {
				$res[$lang->getId()] = $lang->getTitle();
			}

			return $res;
		}

		public function clearCache() {
			$keys = array_keys($this->langs);
			foreach($keys as $key) unset($this->langs[$key]);
			$this->langs = array();
			$this->loadLangs();
		}
	}


/**
	* Предоставляет доступ к свойствам зеркала для домена (класс domain). Зеркало домена используется для создания алиасов.
	* ps. да, мы знаем про опечатку :(
*/
	class domainMirrow extends umiEntinty implements iUmiEntinty, iDomainMirrow {
		private $host;

		/**
			* Изменить хост (адрес) зеркала
			* @param String $host адрес домена
		*/
		public function setHost($host) {
			$this->host = domain::filterHostName($host);
			$this->setIsUpdated();
		}

		/**
			* Получить хост (адрес) зеркала
			* @return String адрес домена
		*/
		public function getHost() {
			return $this->host;
		}

		/**
			* Загрузить информацию о зеркале из БД
			* @return Boolean true, если не произошло никаких ошибок
		*/
		protected function loadInfo($row = false) {
			if($row === false) {
				$sql = "SELECT id, host FROM cms3_domain_mirrows WHERE id = '{$this->id}'";
				$result = l_mysql_query($sql);
				
				$row = mysql_fetch_row($result);
			}

			if(list($id, $host) = $row) {
				$this->host = $host;
				return true;
			} else return false;
		}

		/**
			* Сохранить внесенные изменения в БД
			* @return Boolean true, если не произошло никаких ошибок
		*/
		protected function save() {
			$host = self::filterInputString($this->host);

			$sql = "UPDATE cms3_domain_mirrows SET host = '{$host}' WHERE id = '{$this->id}'";
			$result = l_mysql_query($sql);
			return true;
		}
	};


/**
	* Предоставляет доступ свойствам домена и зеркалам доменов в системе
*/
	class domain extends umiEntinty implements iUmiEntinty, iDomainMirrow, iDomain {
		private	$host, $default_lang_id, $mirrows = Array();
		protected $store_type = "domain";

		/**
			* Загружает свойства домена из БД
			* @return Boolean true, если все прошло нормально
		*/
		protected function loadInfo($row = false) {
			if($row === false) {
				$sql = "SELECT id, host, is_default, default_lang_id FROM cms3_domains WHERE id = '{$this->id}'";
				$result = l_mysql_query($sql);

				$row = mysql_fetch_row($result);
			}

			if(list($id, $host, $is_default, $default_lang_id) = $row) {
				$this->host = $host;
				$this->is_default = (bool) $is_default;
				$this->default_lang_id = (int) $default_lang_id;

				return $this->loadMirrows();
			} else {
				return false;
			}
		}

		/**
			* Получить адрес домена (хост)
			* @return String адрес домена
		*/
		public function getHost() {
			return $this->host;
		}

		/**
			* Узнать, является ли этот домен доменом по умолчанию
			* @return Boolean true, если установлен флаг "по умолчанию"
		*/
		public function getIsDefault() {
			return $this->is_default;
		}

		/**
			* Изменить хост (адрес) домена
			* @param String $host адрес домена
		*/
		public function setHost($host) {
			$this->host = $this->filterHostName($host);
			$this->setIsUpdated();
		}

		/**
			* Установить флаг домена "по умолчанию".
			* Используется системой, в пользовательском коде нужно воспользоваться методом domainsCollection::setDefaultDomain()
			* @param Boolean $is_default флаг "по умолчанию"
		*/
		public function setIsDefault($is_default) {
			$this->is_default = (bool) $is_default;
			$this->setIsUpdated();
		}

		/**
			* Получить id языка (класс lang), который используется по умолчанию для этого домена
			* @return Integer id языка
		*/
		public function getDefaultLangId() {
			return $this->default_lang_id;
		}

		/**
			* Установить для домена язык по умолчанию
			* @param Integer $lang_id id языка (класс lang) по умолчанию
			* @return Boolean true, если операция прошла успешно
		*/
		public function setDefaultLangId($lang_id) {
			if(langsCollection::getInstance()->isExists($lang_id)) {
				$this->default_lang_id = $lang_id;
				$this->setIsUpdated();

				return true;
			} else throw new coreException("Language #{$lang_id} doesn't exists");
		}

		/**
			* Добавить зеркало (класс domainMirrow) для домена
			* @param String $mirrow_host хост (адрес) зеркала
			* @return Integer id созданного зеркала
		*/
		public function addMirrow($mirrow_host) {
			if($mirrow_id = $this->getMirrowId($mirrow_host)) {
				return $mirrow_id;
			} else {
				$this->setIsUpdated();

				$sql = "INSERT INTO cms3_domain_mirrows (rel) VALUES('{$this->id}')";
				l_mysql_query($sql);

				$mirrow_id = l_mysql_insert_id();

				$mirrow = new domainMirrow($mirrow_id);
				$mirrow->setHost($mirrow_host);
				$mirrow->commit();

				$this->mirrows[$mirrow_id] = $mirrow;

				return $mirrow_id;
			}
		}

		/**
			* Удалить зеркало домена, используея его id
			* @param Integer $mirrow_id id зеркала
			* @return Boolean true, если удаление прошло успешно
		*/
		public function delMirrow($mirrow_id) {
			if($this->isMirrowExists($mirrow_id)) {
				$this->setIsUpdated();

				$sql = "DELETE FROM cms3_domain_mirrows WHERE id = '{$mirrow_id}'";
				l_mysql_query($sql);

				unset($this->mirrows[$mirrow_id]);
				return true;
			} else return false;
		}

		/**
			* Удалить все зеркала домена
			* @return Boolean true, если удаление прошло без ошибок
		*/
		public function delAllMirrows() {
			$this->setIsUpdated();

			$sql = "DELETE FROM cms3_domain_mirrows WHERE rel = '{$this->id}'";
			l_mysql_query($sql);

			return true;
		}

		/**
			* Определить id зеркала домена по его хосту (адресу)
			* @param String $mirrow_host хост (адрес)
			* @return domainMirrow экземпляр класса domainMirrow, либо false, если зеркало не найдено
		*/
		public function getMirrowId($mirrow_host) {
			foreach($this->mirrows as $mirrow) {
				if($mirrow->getHost() == $mirrow_host) {
					return $mirrow->getId();
				}
			}
			return false;
		}

		/**
			* Получить зеркало домена (экземпляр класса domainMirrow) по его id
			* @param Integer $mirrow_id id зеркала домена
			* @return domainMirrow, либо false
		*/
		public function getMirrow($mirrow_id) {
			if($this->isMirrowExists($mirrow_id)) {
				return $this->mirrows[$mirrow_id];
			} else {
				return false;
			}
		}

		/**
			* Проверить, существует ли у домена зеркало с id $mirrow_id
			* @param $mirrow_id
			* @return Boolean true если существует
		*/
		public function isMirrowExists($mirrow_id) {
			return (bool) array_key_exists($mirrow_id, $this->mirrows);
		}

		/**
			* Получить список всех зеркал домена
			* @return Array массив, состоящий их экземпляров класса domainMirrow
		*/
		public function getMirrowsList() {
			return $this->mirrows;
		}

		/**
			* Загрузить все зеркала из БД
		*/
		private function loadMirrows() {
			$sql = "SELECT id, host FROM cms3_domain_mirrows WHERE rel = '{$this->id}'";
			$result = l_mysql_query($sql);

			while(list($mirrow_id) = $row = mysql_fetch_row($result)) {
				try {
					$this->mirrows[$mirrow_id] = new domainMirrow($mirrow_id, $row);
				} catch(privateException $e) {
					continue;
				}
			}

			return true;
		}

		/**
			* Сохранить изменения, сделанные с этим доменом
		*/
		protected function save() {
			$host = self::filterInputString($this->host);
			$is_default = (int) $this->is_default;
			$default_lang_id = (int) $this->default_lang_id;

			$sql = "UPDATE cms3_domains SET host = '{$host}', is_default = '{$is_default}', default_lang_id = '{$default_lang_id}' WHERE id = '{$this->id}'";
			l_mysql_query($sql);
			return true;
		}

		public static function filterHostName($host) {
			return preg_replace("/([^A-z0-9\-А-яёЁ\.:]+)|[\^_\\\\]/u", "", $host);
		}
	};


/**
	* Служит для управления доменами (класс domain) в системе. Синглтон, экземпляр коллекции можно получить через статический метод getInstance.
	* Участвует в роутинге урлов в условиях мультидоменности.
*/
	class domainsCollection extends singleton implements iSingleton, iDomainsCollection {
		private $domains = Array(), $def_domain;

		/**
			* Конструктор, подгружает список доменов
		*/
		protected function __construct() {
			$this->loadDomains();
		}

		/**
			* Получить экземпляр коллекции
			* @return domainsCollection экземпляр коллекции
		*/
		public static function getInstance($c = NULL) {
			return parent::getInstance(__CLASS__);
		}

		/**
			* Добавить в систему новый домен
			* @param String $host адрес домен (хост)
			* @param Integer $lang_id id языка (класс lang) по умолчанию для этого домена
			* @param Boolean $is_default=false если true, то этот домен станет основным. Будтье осторожны, при этом может испортиться лицензия
			* @return Integer id созданного домена
		*/
		public function addDomain($host, $lang_id, $is_default = false) {
			if($domain_id = $this->getDomainId($host)) {
				return $domain_id;
			} else {
				cacheFrontend::getInstance()->flush();

				$sql = "INSERT INTO cms3_domains VALUES()";
				l_mysql_query($sql);

				$domain_id = l_mysql_insert_id();

				$this->domains[$domain_id] = $domain = new domain($domain_id);
				$domain->setHost($host);
				$domain->setIsDefault($is_default);
				$domain->setDefaultLangId($lang_id);
				if($is_default) $this->setDefaultDomain($domain_id);
				$domain->commit();

				return $domain_id;
			}
		}

		/**
			* Установить домен по умолчанию
			* @param Integer $domain_id id домена, который нужно сделать доменом по умолчанию
		*/
		public function setDefaultDomain($domain_id) {
			if($this->isExists($domain_id)) {
				cacheFrontend::getInstance()->flush();

				$sql = "UPDATE cms3_domains SET is_default = '0' WHERE is_default = '1'";
				l_mysql_query($sql);

				if($def_domain = $this->getDefaultDomain()) {
					$def_domain->setIsDefault(false);
					$def_domain->commit();
				}

				$this->def_domain = $this->getDomain($domain_id);
				$this->def_domain->setIsDefault(true);
				$this->def_domain->commit();
			} else return false;
		}

		/**
			* Удалить домен из системы
			* @param Integer $domain_id id домена, который необходимо удалить
			* @return Boolean true, если удалось удалить домен
		*/
		public function delDomain($domain_id) {
			if($this->isExists($domain_id)) {
				$domain = $this->getDomain($domain_id);
				$domain->delAllMirrows();
				cacheFrontend::getInstance()->flush();

				if($domain->getIsDefault()) {
					$this->def_domain = false;
				}

				unset($domain);
				unset($this->domains[$domain_id]);


				$sql = "DELETE FROM cms3_hierarchy WHERE domain_id = '{$domain_id}'";
				l_mysql_query($sql);

				$sql = "DELETE FROM cms3_domains WHERE id = '{$domain_id}'";
				l_mysql_query($sql);

				return true;
			} else throw new coreException("Domain #{$domain_id} doesn't exists.");
		}

		/**
			* Получить экземпляр домена (класс domain)
			* @param Integer $domain_id id домена, который необходимо получить
			* @return domain экземпляр домен или false в случае неудачи
		*/
		public function getDomain($domain_id) {
			return $this->isExists($domain_id) ? $this->domains[$domain_id] : false;
		}

		/**
			* Получить домен по умолчанию
			* @return domain экземпляр класса domain или false
		*/
		public function getDefaultDomain() {
			return ($this->def_domain) ? $this->def_domain : false;
		}

		/**
			* Получить список доменов в системе
			* @return Array массив, состоящий из экземпляров класса domain
		*/
		public function getList() {
			return $this->domains;
		}

		/**
			* Проверить, существует ли домен $domain_id в системе
			* @param id $domain_id домена
			* @return Boolean true, если домен существует
		*/
		public function isExists($domain_id) {
			return (bool) @array_key_exists($domain_id, $this->domains);
		}

		/**
			* Получть id домена по его хосту (адресу домена)
			* @param String $host адрес домена
			* @param Boolean $user_mirrow=true если параметр равен true, то поиск будет осуществляться в т.ч. и во всех зеркалах домена
			* @return Integer id домена, либо false если домен с таким хостом не найден
		*/
		public function getDomainId($host, $use_mirrows = true) {
			foreach($this->domains as $domain) {
				if($domain->getHost() == $host) {
					return $domain->getId();
				} else {
					if($use_mirrows) {
						$mirrows = $domain->getMirrowsList();
						foreach($mirrows as $domainMirrow) {
							if($domainMirrow->getHost() == $host) {
								return $domain->getId();
							}
						}
					}
				}
			}
			return false;
		}

		/**
			* Загружает список доменов из БД в коллекцию
			* @return Boolean true, если операция прошла успешно
		*/
		private function loadDomains() {
			$cacheFrontend = cacheFrontend::getInstance();

			$domainIds = $cacheFrontend->loadData('domains_list');
			if(!is_array($domainIds)) {
				$sql = "SELECT id, host, is_default, default_lang_id FROM cms3_domains";
				$result = l_mysql_query($sql);

				$domainIds = array();
				while(list($domain_id) = $row = mysql_fetch_row($result)) {
				    $domainIds[$domain_id] = $row;
				}
				$cacheFrontend->saveData('domains_list', $domainIds, 3600);
			} else $row = false;

			foreach($domainIds as $domain_id => $row) {
				$domain = $cacheFrontend->load($domain_id, 'domain');
				if($domain instanceof domain == false) {
					try {
						$domain = new domain($domain_id, $row);
					} catch(privateException $e) {
						continue;
					}

					$cacheFrontend->save($domain, 'domain');
				}
				$this->domains[$domain_id] = $domain;

				if($domain->getIsDefault()) {
					$this->def_domain = $domain;
				}
			}

			return true;
		}

		public function clearCache() {
			$keys = array_keys($this->domains);
			foreach($keys as $key) unset($this->domains[$key]);
			$this->domains = array();
			$this->loadDomains();
		}
	}


	/**
	 * Предоставляет доступ к свойствам шаблона дизайна
	 */
	class template extends umiEntinty implements iUmiEntinty, iTemplate {
		private $name, $filename, $type, $title, $domain_id, $lang_id, $is_default;
		protected $store_type = "template";


		private $resourcesDirectory, $templatesDirectory, $filePath, $fileDir;
		/**
		 * Получить название шаблона дизайна
		 * @return String название шаблона дизайна
		 */
		public function getName() {
			return $this->name;
		}

		/**
		 * Получить название файла шаблона дизайна
		 * @return String название файла шаблона дизайна
		 */
		public function getFilename() {
			return $this->filename;
		}

		/**
		 * Получить корневую директорию с ресурсами для шаблонов
		 * @param bool $httpMode
		 * @return string
		 */
		public function getResourcesDirectory($httpMode = false) {
			if ($httpMode) {
				return $this->resourcesDirectory ? '/templates/' . $this->name . "/" : "/";
			} else {
				return $this->resourcesDirectory;
			}
		}

		/**
		 * Получить корневую директорию с шаблонами
		 * @return string
		 */
		public function getTemplatesDirectory() {
			return $this->templatesDirectory;
		}

		/**
		 * Получть полный путь к шаблону дизайна
		 * @return string
		 */
		public function getFilePath() {
			return $this->filePath;
		}


		/**
		 * Получить тип шаблона дизайна
		 * @return String тип шаблона дизайна
		 */
		public function getType() {
			return $this->type;
		}

		/**
		 * Получить название шаблона дизайна
		 * @return String название шаблона дизайна
		 */
		public function getTitle() {
			return $this->title;
		}

		/**
		 * Получить id домена, к которому привязан шаблон
		 * @return Integer id домена (класс domain)
		 */
		public function getDomainId() {
			return $this->domain_id;
		}

		/**
		 * Получить id языка, к которому привязан шаблон
		 * @return Integer id язык (класс lang)
		 */
		public function getLangId() {
			return $this->lang_id;
		}

		/**
		 * Узнать, является ли данный шаблон шаблоном по умолчанию
		 * @return Boolean true, если шаблон является шаболоном по умолчанию
		 */
		public function getIsDefault() {
			return $this->is_default;
		}

		/**
		 * Изменить название шаблона
		 * @param String $name название шаблона
		 */
		public function setName($name) {
			$this->name = $name;
			$this->setIsUpdated();
		}

		/**
		 * Изменить название файла шаблона
		 * @param String $filename название файла шаблона
		 */
		public function setFilename($filename) {
			$this->filename = $filename;
			$this->setIsUpdated();
		}

		/**
		 * Изменить название шаблона дизайна
		 * @param String $title название шаблона
		 */
		public function setTitle($title) {
			$this->title = $title;
			$this->setIsUpdated();
		}

		/**
		 * Изменить тип шаблона
		 * @param String $filename тип шаблона
		 */
		public function setType($type) {
			$this->type = $type;
			$this->setIsUpdated();
		}

		/**
		 * Изменить домен, к которому привязан шаблон дизайна
		 * @param Integer $domain_id id домена (класс domain)
		 * @return Boolean true в случае успеха
		 */
		public function setDomainId($domain_id) {
			$domains = domainsCollection::getInstance();
			if($domains->isExists($domain_id)) {
				$this->domain_id = (int) $domain_id;
				$this->setIsUpdated();

				return true;
			} else {
				return false;
			}
		}

		/**
		 * Изменить язык, к которому привязан шаблон
		 * @param Integer $lang_id id языка (класс lang)
		 * @return Boolean true в случае успеха
		 */
		public function setLangId($lang_id) {
			$langs = langsCollection::getInstance();
			if($langs->isExists($lang_id)) {
				$this->lang_id = (int) $lang_id;
				$this->setIsUpdated();

				return true;
			} else {
				return false;
			}
		}

		/**
		 * Изменить флаг "по умолчанию"
		 * @param Boolean $is_default значение флага "по умолчанию"
		 */
		public function setIsDefault($is_default) {
			$this->is_default = (bool) $is_default;
			$this->setIsUpdated();
		}

		/**
		 * Получить список страниц, которые используют этот шаблон
		 * @return Array массив, в котором каждое значение тоже массив, где 0 индекс - id страницы (класс umiHierarchyElement), 1 индекс - название страницы
		 */
		public function getUsedPages() {
			$sql = "SELECT h.id, o.name FROM cms3_hierarchy h, cms3_objects o WHERE h.tpl_id = '{$this->id}' AND o.id = h.obj_id AND h.is_deleted = '0' AND h.domain_id = '{$this->domain_id}'";
			$result = l_mysql_query($sql);

			$res = array();
			while(list($id, $name) = mysql_fetch_row($result)) {
				$res[] = Array($id, $name);
			}
			return $res;
		}

		/**
		 * Привязать страницы сайта к шаблону
		 * @param Array $pages массив, в котором каждое значение тоже массив, где 0 индекс - id страницы (класс umiHierarchyElement), 1 индекс - название страницы
		 * @return Boolean true в случае, если не возникло ошибок
		 */
		public function setUsedPages($pages) {
			if(is_null($pages)) return false;

			$default_tpl_id = templatesCollection::getInstance()->getDefaultTemplate($this->domain_id, $this->lang_id)->getId();

			$sql = "UPDATE cms3_hierarchy SET tpl_id = '{$default_tpl_id}' WHERE tpl_id = '{$this->id}' AND is_deleted = '0' AND domain_id = '{$this->domain_id}'";
			l_mysql_query($sql);

			$cacheFrontend = cacheFrontend::getInstance();
			$cacheFrontend->flush();

			$hierarchy = umiHierarchy::getInstance();

			if(!is_array($pages)) return false;

			if(is_array($pages)&&!empty($pages)) {
				foreach($pages as $element_id) {
					$page = $hierarchy->getElement($element_id);
					if($page instanceof iUmiHierarchyElement) {
						$page->setTplId($this->id);
						$page->commit();
						unset($page);
						$hierarchy->unloadElement($element_id);
					}
				}
			}
			return true;
		}

		/**
		 * Загрузить информацию о шаблоне из БД
		 * @return Boolean true, если не произошло ошибки
		 */
		protected function loadInfo($row = false) {
			$config = mainConfiguration::getInstance();
			if($row === false) {
				$sql = "SELECT id, name, filename, type, title, domain_id, lang_id, is_default FROM cms3_templates WHERE id = '{$this->id}'";
				$result = l_mysql_query($sql);
				$row = mysql_fetch_row($result);
			}

			if(list($id, $name, $filename, $type, $title, $domain_id, $lang_id, $is_default) = $row) {
				$this->name = $name;
				$this->filename = $filename;
				$this->type = $type;
				$this->title = $title;
				$this->domain_id = (int) $domain_id;
				$this->lang_id = (int) $lang_id;
				$this->is_default = (bool) $is_default;

				if (!empty($this->filename)) {
					// определяем полный путь к шаблону, а так же путь к директории с ресурсами
					$templateExt = pathinfo($this->filename, PATHINFO_EXTENSION);

					if (!strlen($this->type)) {
						if (strtolower($templateExt) == 'xsl') {
							$this->type = 'xslt';
						} elseif (strtolower($templateExt) == 'tpl') {
							$this->type = 'tpls';
						} else {
							$this->type = strlen($templateExt) ? $templateExt : 'xslt';
						}
					}

					// TODO: refactoring
					if ($this->type == 'xslt') {
						$this->templatesDirectory = $templateDir = $config->includeParam('templates.xsl');
					} elseif ($this->type == 'tpls') {
						$this->templatesDirectory = $config->includeParam('templates.tpl');
						$templateDir = $this->templatesDirectory . "content/";
					} else {
						$this->templatesDirectory = $templateDir = $config->includeParam('templates.' . $this->type) . "/";
					}

					if (strlen($this->name)) {
						$this->resourcesDirectory = CURRENT_WORKING_DIR . '/templates/' . $this->name . '/';
						$templateDir =  $this->templatesDirectory = $this->resourcesDirectory . $this->type . '/';
						if ($this->type == 'tpls') {
							$templateDir = $this->templatesDirectory . "content/";
						}
					}

					// mobile mode template
					if (system_is_mobile() && is_file($templateDir . 'mobile/' . $this->filename)) {
						$this->filePath = $templateDir . 'mobile/' . $this->filename;
					} else {
						// standart mode template
						$this->filePath = $templateDir . $this->filename;
					}
				}


				return true;
			} else return false;
		}

		/**
		 * Сохранить изменения в БД
		 * @return Boolean true, если не возникло ошибки
		 */
		protected function save() {
			$name = self::filterInputString($this->name);
			$filename = self::filterInputString($this->filename);
			$type = self::filterInputString($this->type);
			$title = self::filterInputString($this->title);
			$domain_id = (int) $this->domain_id;
			$lang_id =  (int) $this->lang_id;
			$is_default = (int) $this->is_default;

			$sql = "UPDATE cms3_templates SET name = '{$name}', filename = '{$filename}', type = '{$type}', title = '{$title}', domain_id = '{$domain_id}', lang_id = '{$lang_id}', is_default = '{$is_default}' WHERE id = '{$this->id}'";
			$result = l_mysql_query($sql);
			return true;
		}
	}


/**
	* Управляет шаблонами дизайна (класс template) в системе.
	* Синглтон, экземпляр коллекции можно получить через статический метод getInstance()
*/
	class templatesCollection extends singleton implements iSingleton, iTemplatesCollection {
		private $templates = Array(), $def_template;

		/**
			* Конструктор, при вызове загружает список шаблонов
		*/
		protected function __construct() {
			$this->loadTemplates();
		}

		/**
			* Получить экземпляр коллекции
			* @return templatesCollection экземпляр класса templatesCollection
		*/
		public static function getInstance($c = NULL) {
			return parent::getInstance(__CLASS__);
		}

		/**
			* Добавить новый шаблон дизайна (класс template)
			* @param String $filename название файла, который содержит шаблон дизайна
			* @param String $title название шаблона
			* @param Integer $domain_id=false id домена (класс domain), для которого создается шаблон. Если не указан, используется домен по умолчанию
			* @param Integer $lang_id=false id языка (класс lang), для которого создается шаблон. Если не указан, используется язык по умолчанию
			* @param Boolean $is_default=false если true, то шаблон станет шаблоном по умолчанию для комбинации домена /языка $domain_id/$lang_id
			* @return Integer id созданного шаблона
		*/
		public function addTemplate($filename, $title, $domain_id = false, $lang_id = false, $is_default = false) {
			$this->disableCache();
			cacheFrontend::getInstance()->flush();

			$domains = domainsCollection::getInstance();
			$langs = langsCollection::getInstance();

			if(!$domains->isExists($domain_id)) {
				if($domains->getDefaultDomain()) {
					$domain_id = $domains->getDefaultDomain()->getId();
				} else {
					return false;
				}
			}

			if(!$langs->isExists($lang_id)) {
				if($langs->getDefaultLang()) {
					$lang_id = $langs->getDefaultLang()->getId();
				} else {
					return false;
				}
			}

			$sql = "INSERT INTO cms3_templates VALUES()";
			$result = l_mysql_query($sql);

			$template_id = l_mysql_insert_id();

			$template = new template($template_id);
			$template->setFilename($filename);
			$template->setTitle($title);
			$template->setDomainId($domain_id);
			$template->setLangId($lang_id);
			$template->setIsDefault($is_default);

			if($is_default) {
				$this->setDefaultTemplate($template_id);
			}
			$template->commit();
			$template->update();


			$this->templates[$template_id] = $template;

			return $template_id;
		}

		/**
			* Установить шаблон шаблоном по умолчанию для комбинации домена/языка
			* @param Integer $domain_id=false id домена (класс domain)
			* @param Integer $lang_id=false id языка (класс lang)
			* @return Boolean true, если не возникло ошибок
		*/
		public function setDefaultTemplate($template_id, $domain_id = false, $lang_id = false) {
			if($domain_id == false) $domain_id = domainsCollection::getInstance()->getDefaultDomain()->getId();
			if($lang_id ==false) $lang_id = cmsController::getInstance()->getCurrentLang()->getId();

			if(!$this->isExists($template_id)) {
				return false;
			}

			$templates = $this->getTemplatesList($domain_id,$lang_id);
			foreach ($templates as $template) {
				if($template_id == $template->getId()) {
					$template->setIsDefault(true);
				}
				else {
					$template->setIsDefault(false);
				}
				$template->commit();
			}
			return true;

			if(!($template = $this->getTemplate($templateId))) {
				return false;
			}

			if($this->def_template) {
				$this->def_template->setIsDefault(false);
				$this->def_template->commit();
			}

			$this->def_template = $template;
			$this->def_template->setIsDefault(true);
			$this->def_template->commit();

			return true;
		}

		/**
			* Удалить шаблон дизайна
			* @param Integer $template_id id шаблона дизайна
			* @return Boolean true, если удаление прошло успешно
		*/
		public function delTemplate($template_id) {
			$this->disableCache();
			cacheFrontend::getInstance()->flush();

			if($this->isExists($template_id)) {
				if($this->templates[$template_id]->getIsDefault()) {
					unset($this->def_template);
				}
				unset($this->templates[$template_id]);

				$o_deftpl = $this->getDefaultTemplate();
				if (!$o_deftpl || $o_deftpl->getId() == $template_id) return false;

				$upd_qry = "UPDATE cms3_hierarchy SET tpl_id = '".$o_deftpl->getId()."' WHERE tpl_id='{$template_id}'";
				l_mysql_query($upd_qry);

				$sql = "DELETE FROM cms3_templates WHERE id = '{$template_id}'";
				l_mysql_query($sql);

				return true;

			} else return false;
		}

		/**
			* Получить список всех шаблонов дизайна для комбинации домен/язык
			* @param Integer $domain_id id домена
			* @param Integer $lang_id id  языка
			* @return Array массив, состоящий из экземпляров класса template
		*/
		public function getTemplatesList($domain_id, $lang_id) {
			$res = array();

			foreach($this->templates as $template) {
				if($template->getDomainId() == $domain_id && $template->getLangId() == $lang_id) {
					$res[] = $template;
				}
			}

			return $res;
		}

		/**
			* Получить шаблон дизайна по умолчанию для комбинации домен/язык
			* @param Integer $domain_id=false id домена. Если не указан, берется домен по умолчанию.
			* @param Integer $lang_id=false id языка. Если не указан, берется язык по умолчанию.
			* @return template экземпляр класса template, либо false если шаблон дизайна не найден.
		*/
		public function getDefaultTemplate($domain_id = false, $lang_id = false) {
			if($domain_id == false) $domain_id = cmsController::getInstance()->getCurrentDomain()->getId();
			if($lang_id == false) $lang_id = cmsController::getInstance()->getCurrentLang()->getId();

			$templates = $this->getTemplatesList($domain_id, $lang_id);
			foreach($templates as $template) {
				if($template->getIsDefault() == true) {
					return $template;
				}
			}

			//We have no default template, but something must be shown
			if(sizeof($templates)) {
				$first_template = $templates[0];
				$this->setDefaultTemplate($first_template->getId(), $domain_id, $lang_id);
				return $first_template;
			}
			return false;
		}

		public function getCurrentTemplate() {
			$controller = cmsController::getInstance();
			if ($element = umiHierarchy::getInstance()->getElement($controller->getCurrentElementId(), true)) {
				$template = $this->getTemplate($element->getTplId());
			}
			elseif ($methodTemplateId = $this->getHierarchyTypeTemplate($controller->getCurrentModule(), $controller->getCurrentMethod())) {
				$template = $this->getTemplate($methodTemplateId);
			}
			else $template = $this->getDefaultTemplate();

			return $template;
		}



		public function getHierarchyTypeTemplate($module, $method) {
			$config = mainConfiguration::getInstance();
			$id = $config->get("templates", "{$module}.{$method}");
			return $this->isExists($id) ? $id : false;
		}

		/**
			* Получить шаблон дизайна по его id
			* @param Integer $template_id id шаблона дизайна
			* @return template шаблон дизайна, экземпляр класса template, либо false если не существует шаблона с id $template_id
		*/
		public function getTemplate($template_id) {
			return ($this->isExists($template_id)) ? $this->templates[$template_id] : false;
		}

		/**
			* Проверить, существует ли шаблон дизайна с id $template_id
			* @param Integer $template_id id шаблона дизайна
			* @return Boolean true, если шаблон существует
		*/
		public function isExists($template_id) {
			return (bool) @array_key_exists($template_id, $this->templates);
		}

		/**
			* Загрузить список всех шаблонов дизайна в системе из БД
			* @return Boolean false, если возникла ошибка
		*/
		private function loadTemplates() {
			$cacheFrontend = cacheFrontend::getInstance();

			$templateIds = $cacheFrontend->loadData('templates_list');
			if(!is_array($templateIds)) {
				$sql = "SELECT id, name, filename, type, title, domain_id, lang_id, is_default FROM cms3_templates";
				$result = l_mysql_query($sql);
				$templateIds = array();
				while(list($template_id) = $row = mysql_fetch_row($result)) {
					$templateIds[$template_id] = $row;
				}
				$cacheFrontend->saveData('templates_list', $templateIds, 3600);
			} else $row = false;

			foreach($templateIds as $template_id => $row) {
				 $template = $cacheFrontend->load($template_id, "template");
				if($template instanceof template == false) {
					try {
						$template = new template($template_id, $row);
					} catch (privateException $e) { continue; }

					$cacheFrontend->save($template, "template");
				}
				$this->templates[$template_id] = $template;

				if($template->getIsDefault()) {
					$this->def_template = $template;
				}
			}
			return true;
		}

		public function clearCache() {
			$keys = array_keys($this->templates);
			foreach($keys as $key) unset($this->templates[$key]);
			$this->templates = array();
			$this->loadTemplates();
		}
	}


/**
	* Базовый тип, используется:
	* 1. Для связывание страниц с соответствующим обработчиком (модуль/метод)
	* 2. Для категоризации типов данных
	* В новой терминологии getName()/getExt() значило бы getModule()/getMethod() соответственно
*/
	class umiHierarchyType extends umiEntinty implements iUmiEntinty, iUmiHierarchyType {
		private $name, $title, $ext;
		protected $store_type = "element_type";

		/**
			* Получить название модуля, отвечающего за этот базовый тип
			* @return String название модуля
		*/
		public function getName() {
			return $this->name;
		}

		/**
			* Получить название базового типа
			* @return String название типа
		*/
		public function getTitle() {
			return $this->translateLabel($this->title);
		}
		
		public function getModule() {
			return $this->getName();
		}
		
		public function getMethod() {
			return $this->getExt();
		}

		/**
			* Получить название метода, отвечающего за этот базовый тип
			* @return String название метода
		*/
		public function getExt() {
			return $this->ext;
		}

		/**
			* Изменить название модуля, отвечающего за этот базовый тип
			* @param String $name название модуля
		*/
		public function setName($name) {
			$this->name = $name;
			$this->setIsUpdated();
		}

		/**
			* Изменить название базового типа
			* @param String $title название типа
		*/
		public function setTitle($title) {
			$title = $this->translateI18n($title, "hierarchy-type-");
			$this->title = $title;
			$this->setIsUpdated();
		}

		/**
			* Изменить название метода, отвечающего за этот базовый тип
			* @param String $ext название метода
		*/
		public function setExt($ext) {
			$this->ext = $ext;
			$this->setIsUpdated();
		}

		/**
			* Загрузить информацию о базовом типа из БД
		*/
		protected function loadInfo($row = false) {
			if($row === false) {
				$sql = "SELECT id, name, title, ext FROM cms3_hierarchy_types WHERE id = '{$this->id}'";
				$result = l_mysql_query($sql);
				
				$row = mysql_fetch_row($result);
			}

			if(list($id, $name, $title, $ext) = $row) {
				$this->name = $name;
				$this->title = $title;
				$this->ext = $ext;

				return true;
			} else {
				return false;
			}
		}

		/**
			* Сохранить внесенные изменения в БД
		*/
		protected function save() {
			$name = self::filterInputString($this->name);
			$title = self::filterInputString($this->title);
			$ext = self::filterInputString($this->ext);

			$sql = "UPDATE cms3_hierarchy_types SET name = '{$name}', title = '{$title}', ext = '{$ext}' WHERE id = '{$this->id}'";
			l_mysql_query($sql);

			return true;
		}
	}


/**
 * Класс-коллекция, который обеспечивает управление иерархическими типами
*/
	class umiHierarchyTypesCollection extends singleton implements iSingleton, iUmiHierarchyTypesCollection {
		private $types = array();

		protected function __construct() {
			$this->loadTypes();
		}

		/**
			* Получить экземпляр коллекции
			* @return umiHierarchyTypesCollection экземпляр коллекции
		*/
		public static function getInstance($c = NULL) {
			return parent::getInstance(__CLASS__);
		}

		/**
			* Получить тип поего id
			* @param Integer $type_id id типа
			* @return umiHierarchyType иерархический тип (класс umiHierarchyType), либо false
		*/
		public function getType($type_id) {
			if($this->isExists($type_id)) {
				return $this->types[$type_id];
			} else {
				return false;
			}
		}

		/**
			* Получить иерархический тип по его модулю/методу
			* @param String $name модуль типа
			* @param String $ext = false метод типа
			* @return umiHierarchyType иерархический тип (класс umiHierarchyType), либо false
		*/
		public function getTypeByName($name, $ext = false) {
			if($name == 'content' and $ext == 'page') $ext = false;
			foreach($this->types as $type) {
				if($type->getName() == $name && $ext === false) return $type;
				if($type->getName() == $name && $type->getExt() == $ext && $ext !== false ) return $type;
			}
			return false;
		}

		/**
			* Добавить новый иерархический тип
			* @param String $name модуль типа
			* @param String $title название типа
			* @param String $ext метод типа
			* @return Integer id иерархического типа (класс umiHierarchyType)
		*/
		public function addType($name, $title, $ext = "") {
			$this->disableCache();
			cacheFrontend::getInstance()->flush();

			if($hierarchy_type  = $this->getTypeByName($name, $ext)) {
				$hierarchy_type->setTitle($title);
				return $hierarchy_type->getId();
			}

			$nameTemp = l_mysql_real_escape_string($name);
			$sql = "INSERT INTO cms3_hierarchy_types (name) VALUES('{$nameTemp}')";
			l_mysql_query($sql);

			$type_id = l_mysql_insert_id();

			$type = new umiHierarchyType($type_id);
			$type->setName($name);
			$type->setTitle($title);
			$type->setExt($ext);
			$type->commit();

			$this->types[$type_id] = $type;


			return $type_id;
		}

		/**
			* Удалить тип
			* @param Integer $type_id id иерархического типа, который нужно удалить
			* @return Boolean true, если тип удален успешно
		*/
		public function delType($type_id) {
			$this->disableCache();
			cacheFrontend::getInstance()->flush();

			if($this->isExists($type_id)) {
				unset($this->types[$type_id]);

				$type_id = (int) $type_id;
				$sql = "DELETE FROM cms3_hierarchy_types WHERE id = '{$type_id}'";
				l_mysql_query($sql);
				return true;
			} else {
				return false;
			}
		}

		/**
			* Проверить, существует ли иерархический тип с таким id
			* @param Integer $typeId id типа
			* @return Boolean true если тип существует
		*/
		public function isExists($typeId) {
			if($typeId === false) return false;
			return (bool) array_key_exists($typeId, $this->types);
		}


		private function loadTypes() {
			$cacheFrontend = cacheFrontend::getInstance();

			$hierarchyTypeIds = $cacheFrontend->loadData('hierarchy_types');
			if(!is_array($hierarchyTypeIds)) {
				$sql = "SELECT  `id`, `name`, `title`, `ext` FROM `cms3_hierarchy_types` ORDER BY `name`, `ext`";
				$result = l_mysql_query($sql);
				$hierarchyTypeIds = array();
				while(list($id) = $row = mysql_fetch_row($result)) {
					$hierarchyTypeIds[$id] = $row;
				}
				$cacheFrontend->saveData('hierarchy_types', $hierarchyTypeIds, 3600);
			}

			foreach($hierarchyTypeIds as $id => $row) {
				$type = $cacheFrontend->load($id, 'element_type');
				if($type instanceof iUmiHierarchyType == false) {
					try {
						$type = new umiHierarchyType($id, $row);
					} catch (privateException $e) { continue; }

					$cacheFrontend->save($type, 'element_type');
				}
				$this->types[$id] = $type;
			}

			return true;
		}

		/**
			* Получить список всех иерархических типов
			* @return Array массив, где ключ это id типа, а значение экземпляр класса umiHierarchyType
		*/
		public function getTypesList() {
			return $this->types;
		}

		public function clearCache() {
			$keys = array_keys($this->types);
			foreach($keys as $key) unset($this->types[$key]);
			$this->types = array();
			$this->loadTypes();
		}
	}


	/**
	* Реализует доступ и управление свойствами страниц. Страницы это то, что в системе фигурирует в структуре сайта.
	 */
	class umiHierarchyElement extends umiEntinty implements iUmiEntinty, iUmiHierarchyElement {
		private	$rel, $alt_name, $ord, $object_id,
			$type_id, $domain_id, $lang_id, $tpl_id,
			$is_deleted = false, $is_active = true, $is_visible = true, $is_default = false, $name,
			$update_time,
			$object,
			$is_broken = false;

		protected $store_type = "element";

		/**
			* Узнать, удалена ли страница в корзину или нет
			* @return Boolean true, если страница помещена в мусорную корзину, либо false если нет
		*/
		public function getIsDeleted() {
			return $this->is_deleted;
		}

		/**
			* Узнать, активна страница или нет
			* @return Boolean true если активна
		*/
		public function getIsActive() {
			return $this->is_active;
		}

		/**
			* Узнать, видима ли страница в меню или нет
			* @return Boolean true если страница может отображаться в меню сайта
		*/
		public function getIsVisible() {
			return $this->is_visible;
		}

		/**
			* Получить id языка (класс lang), к которому привязана страница
			* @return Integer id языка
		*/
		public function getLangId() {
			return $this->lang_id;
		}

		/**
			* Получить id домена (класс domain), к которому привязана страница
			* @return Integer id домена
		*/
		public function getDomainId() {
			return $this->domain_id;
		}

		/**
			* Получить id шаблона дизайана (класс template), по которому отображаеся страница
			* @return Integer id шаблона дизайна (класс template)
		*/
		public function getTplId() {
			return $this->tpl_id;
		}

		/**
			* Получить id базового типа (класс umiHierarchyType), который определяет поведение страницы на сайте
			* @return Integer id базового типа (класс umiHierarchyType)
		*/
		public function getTypeId() {
			return $this->type_id;
		}

		/**
			* Получить время последней модификации страницы
			* @return Integer дата в формате UNIX TIMESTAMP
		*/
		public function getUpdateTime() {
			return $this->update_time;
		}

		/**
			* Получить порядок страницы отосительно соседних страниц
			* @return Integer порядок страницы ()
		*/
		public function getOrd() {
			return $this->ord;
		}

		/**
			* Получить id родительской страницы. Deprecated: используйте метод umiHierarchyElement::getParentId()
			* @return Integer id страницы
		*/
		public function getRel() {
			return $this->rel;
		}

		/**
			* Получить псевдостатический адрес страницы, по которому строится ее адрес
			* @return String псевдостатический адрес
		*/
		public function getAltName() {
			return $this->alt_name;
		}

		/**
			* Получить флаг "по умолчанию" у страницы
			* @return Boolean флаг "по умолчанию"
		*/
		public function getIsDefault() {
			return $this->is_default;
		}

		/**
			* Получить объект (класс umiObject), который является источником данных для страницы
			* @return umiObject объект страницы (ее источник данных)
		*/
		public function getObject() {
			if(isset($this->object) && $this->object) {
				return $this->object;
			} else if(isset($this->object_id)) {
				$this->object = umiObjectsCollection::getInstance()->getObject($this->object_id);
				return $this->object;
			} else {
				return null;
			}
		}

		/**
			* Получить id родительской страницы.
			* @return Integer id страницы
		*/
		public function getParentId() {
			return $this->rel;
		}

		/**
			* Получить название страницы
			* @return String название страницы
		*/
		public function getName() {
			return $this->translateLabel($this->name);
		}

		/**
			* Изменить название страницы
			* @param String $name новое название страницы
		*/
		public function setName($name) {
			$res = $this->getObject()->setName($name);
			$this->name = $this->object->getName(true);
			$this->setIsUpdated(true);
			return $res;
		}

		/**
			* Получить значение свойства $prop_name
			* @param String $prop_name строковой идентификатор свойства, значение которого нужно получить
			* @param Array $params = NULL дополнительные параметры (обычно не используется)
			* @return Mixed значение свойства. Тип возвращаемого значения зависит от типа поля
		*/
		public function getValue($prop_name, $params = NULL) {
			$object = $this->getObject();
			return $object ? $object->getValue($prop_name, $params) : false;
		}

		/**
			* Изменить значение свойства $prop_name на $prop_value
			* @param String $prop_name строковой идентификатор свойства, значение которого нужно изменить
			* @param Mixed $prop_value новое значение свойства. Тип аргумента зависит от типа поля
			* @return Boolean true, если не произошло ошибок
		*/
		public function setValue($prop_name, $prop_value) {
			if($object = $this->getObject()) {
				$result = $object->setValue($prop_name, $prop_value);
				$this->setIsUpdated(true);
				return $result;
			} else {
				return false;
			}
		}

		/**
			* Утановить флаг, означающий, что страница может быть видима в меню
			* @param Boolean $is_visible=true новое значение флага видимости
		*/
		public function setIsVisible($is_visible = true) {
			if ($this->is_visible !== ((bool)$is_visible)) {
				$this->is_visible = (bool) $is_visible;
				$this->setIsUpdated();
			}
		}

		/**
			* Установить флаг активности
			* @param Boolean $is_active=true значение флага активности
		*/
		public function setIsActive($is_active = true) {
			if ($this->is_active !== ((bool)$is_active)) {
				$this->is_active = (bool) $is_active;
				$this->setIsUpdated();
			}
		}

		/**
			* Установить флаг "удален", который сигнализирует о том, что страница помещена в корзину
			* @param Boolean $is_deleted=false значение флага удаленности
		*/
		public function setIsDeleted($is_deleted = false) {
			if ($this->is_deleted !== ((bool)$is_deleted)) {
				$this->is_deleted = (bool) $is_deleted;
				$this->setIsUpdated();
			}
		}

		/**
			* Изменить id базового типа (класс umiHierarchyType), который определяет поведение страницы на сайте
			* @param Integer $type_id id базового типа (класс umiHierarchyType)
		*/
		public function setTypeId($type_id) {
			if ($this->type_id !== ((int)$type_id)) {
				$this->type_id = (int) $type_id;
				$this->setIsUpdated();
			}
		}

		/**
			* Изменить id языка (класс lang), к которому привязана страница
			* @param Integer $lang_id id языка
		*/
		public function setLangId($lang_id) {
			if ($this->lang_id !== ((int)$lang_id)) {
				$this->lang_id = (int) $lang_id;
				$this->setIsUpdated();
			}
		}

		/**
			* Изменить шаблон дизайна, по которому отображается страница на сайте
			* @param Integer $tpl_id id шаблона дизайна (класс template)
		*/
		public function setTplId($tpl_id) {
			if ($this->tpl_id !== ((int)$tpl_id)) {
				$this->tpl_id = (int) $tpl_id;
				$this->setIsUpdated();
			}
		}

		/**
			* Изменить домен (класс domain), к которому привязана страница
			* @param Integer $domain_id id домена (класс domain)
		*/
		public function setDomainId($domain_id) {
			$hierarchy = umiHierarchy::getInstance();
			$childs = $hierarchy->getChilds($this->id, true, true);

			foreach($childs as $child_id => $nl) {
				$child = $hierarchy->getElement($child_id, true, true);
				$child->setDomainId($domain_id);
				$hierarchy->unloadElement($child_id);
				unset($child);
			}

			if ($this->domain_id !== ((int)$domain_id)) {
				$this->domain_id = (int) $domain_id;
				$this->setIsUpdated();
			}
		}

		/**
			* Изменить время последней модификации страницы
			* @param Integer $update_time=0 время последнего изменения страницы в формате UNIX TIMESTAMP. Если аргумент не передан, берется текущее время.
		*/
		public function setUpdateTime($update_time = 0) {
			if($update_time == 0) {
				$update_time = umiHierarchy::getTimeStamp();
			}
			if ($this->update_time !== ((int)$update_time)) {
				$this->update_time = (int) $update_time;
				$this->setIsUpdated();
			}
		}

		/**
			* Изменить номер порядка следования страницы в структуре относительно других страниц
			* @param Integer $ord порядковый номер
		*/
		public function setOrd($ord) {
			if ($this->ord !== ((int)$ord)) {
				$this->ord = (int) $ord;
				$this->setIsUpdated();
			}
		}

		/**
			* Изменить родителя страницы
			* @param Integer $rel id родительской страницы
		*/
		public function setRel($rel) {
			if ($this->rel !== ((int)$rel)) {
				$this->rel = (int) $rel;
				$this->setIsUpdated();
			}
		}

		/**
			* Изменить объект-источник данных страницы
			* @param umiObject $object экземпляр класса umiObject
			* @param $bNeedSetUpdated=true если true, то на объекте $object будет выполнен метод setIsUpdated() без параметров
		*/
		public function setObject(umiObject $object, $bNeedSetUpdated = true) {
			$this->object = $object;
			$this->object_id = $object->getId();
			if ($bNeedSetUpdated) $this->setIsUpdated();
		}

		/**
			* Изменить псевдостатический адрес, который участвует в формировании адреса страницы
			* @param $alt_name новый псевдостатический адрес
			* @param Boolean $auto_convert не указывайте этот параметр
		*/
		public function setAltName($alt_name, $auto_convert = true) {
			if(!$alt_name) {
				$alt_name = $this->getName();
			}

			if($auto_convert) {
				$alt_name = umiHierarchy::convertAltName($alt_name);
				if(!$alt_name) $alt_name = "_";
			}

			$sPrevAltname = $this->alt_name;

			$this->alt_name = $this->getRightAltName(umiObjectProperty::filterInputString($alt_name));
			if(!$this->alt_name) {
				$this->alt_name = $alt_name;
			}

			$sNewAltname = $this->alt_name;
			if ($sNewAltname !== $sPrevAltname) $this->setIsUpdated();
		}

		/**
			* При выгрузке страницы нужно выгружать связанный объект.
			* Вся память там.
		*/
		public function __destruct() {
			$objectId = $this->object_id;
			parent::__destruct();
			unset($this->object_id);
			unset($this->object);
			umiObjectsCollection::getInstance()->unloadObject($objectId);
		}

		/**
			* Разрешить коллизии в псевдостатическом адресе страницы
			* @param String $alt_name псевдостатический адрес страницы
			* @return String откорректированный результат
		*/
		private function getRightAltName($alt_name, $b_fill_cavities = false) {
			/*
				Не совсем предсказуемо для оператора
				работает с адресами-цифрами.
				При правках необходимо учитывать возможность наличия
				цифр в адресе (в частности - в его начале)
			*/
			if (empty($alt_name)) $alt_name = '1';

			if ($this->getRel() == 0 && !IGNORE_MODULE_NAMES_OVERWRITE) {
				// если элемент непосредственно под корнем и снята галка в настройках -
				// корректировать совпадение с именами модулей и языков
				$modules_keys = regedit::getInstance()->getList("//modules");
				foreach($modules_keys as $module_name) {
					if ($alt_name == $module_name[0]) {
							$alt_name .= '1';
							break;
					}
				}
				if (langsCollection::getInstance()->getLangId($alt_name)) {
					$alt_name .= '1';
				}
			}

			$exists_alt_names =  array();

			preg_match("/^([a-z0-9_.-]*)(\d*?)$/U", $alt_name, $regs);
			$alt_digit = isset($regs[2]) ? $regs[2] : NULL;
			$alt_string = isset($regs[1]) ? $regs[1] : NULL;

			$lang_id = $this->getLangId();
			$domain_id = $this->getDomainId();

			$sql = "SELECT alt_name FROM cms3_hierarchy WHERE rel={$this->getRel()} AND id <> {$this->getId()} AND is_deleted = '0' AND lang_id = '{$lang_id}' AND domain_id = '{$domain_id}' AND alt_name LIKE '{$alt_string}%';";
			$result = l_mysql_query($sql);

			while(list($item) = mysql_fetch_row($result)) $exists_alt_names[] = $item;
			if (!empty($exists_alt_names) and in_array($alt_name,$exists_alt_names)){
				foreach($exists_alt_names as $next_alt_name){
					preg_match("/^([a-z0-9_.-]*)(\d*?)$/U", $next_alt_name, $regs);
					if (!empty($regs[2])) $alt_digit = max($alt_digit,$regs[2]);
				}
				++$alt_digit;
				//
				if ($b_fill_cavities) {
					$j = 0;
					for ($j = 1; $j<$alt_digit; $j++) {
						if (!in_array($alt_string . $j, $exists_alt_names)) {
							$alt_digit = $j;
							break;
						}
					}
				}
			}
			return $alt_string . $alt_digit;
		}

		/**
			* Изменить значение флаг "по умолчанию"
			* @param Boolean $is_default=true значение флага "по умолчанию"
		*/
		public function setIsDefault($is_default = true) {
			if ($this->is_default !== ((int)$is_default)) {
				umiHierarchy::getInstance()->clearDefaultElementCache();
				cacheFrontend::getInstance()->flush();

				$this->is_default = (int) $is_default;
				$this->setIsUpdated();
			}
		}

		/**
			* Получить id поля по его строковому идентификатору
			* @param String $field_name строковой идентификатор поля
			* @return Integer id поля, либо false
		*/
		public function getFieldId($field_name) { //TODO: дезинтегрировать следующую строчку (c) lyxsus
			return umiObjectTypesCollection::getInstance()->getType($this->getObject()->getTypeId())->getFieldId($field_name);
		}

		/**
			* Загрузить информацию о страницы из БД
			* @return Boolean true если не возникло ошибок
		*/
		protected function loadInfo($row = false) {
			if($row === false) {
				$sql = "SELECT h.rel, h.type_id, h.lang_id, h.domain_id, h.tpl_id, h.obj_id, h.ord, h.alt_name, h.is_active, h.is_visible, h.is_deleted, h.updatetime, h.is_default, o.name FROM cms3_hierarchy h, cms3_objects o WHERE h.id = '{$this->id}' AND o.id = h.obj_id";
				$result = l_mysql_query($sql, true);
				$row = mysql_fetch_row($result);
			}

			if(list($rel, $type_id, $lang_id, $domain_id, $tpl_id, $obj_id, $ord, $alt_name, $is_active, $is_visible, $is_deleted, $updatetime, $is_default, $name) = $row) {
				if(!$obj_id) {	//Really bad, foregin check didn't worked out :(, let's delete it itself
					umiHierarchy::getInstance()->delElement($this->id);
					$this->is_broken = true;
					return false;
				}

				$this->rel = (int) $rel;
				$this->type_id = (int) $type_id;
				$this->lang_id = (int) $lang_id;
				$this->domain_id = (int) $domain_id;
				$this->tpl_id = (int) $tpl_id;
				$this->object_id = (int) $obj_id;
				$this->ord = (int) $ord;
				$this->alt_name = $alt_name;
				$this->is_active = (bool) $is_active;
				$this->is_visible = (bool) $is_visible;
				$this->is_deleted = (bool) $is_deleted;
				$this->is_default = (bool) $is_default;

				$this->name = $name;	//read-only

				if (!$updatetime) {
					$updatetime = umiHierarchy::getTimeStamp();
				}
				$this->update_time = (int)$updatetime;

				return true;
			} else {
				$this->is_broken = true;
				return false;
			}
		}

		/**
			* Сохранить изменения в БД
			* @return Boolean true в случае успеха
		*/
		protected function save() {
			$rel = (int) $this->rel;
			$type_id = (int) $this->type_id;
			$lang_id = (int) $this->lang_id;
			$domain_id = (int) $this->domain_id;
			$tpl_id = (int) $this->tpl_id;
			$object_id = (int) $this->object_id;
			$ord = (int) $this->ord;
			$alt_name = self::filterInputString($this->alt_name);
			$is_active = (int) $this->is_active;
			$is_visible = (int) $this->is_visible;
			$is_deleted = (int) $this->is_deleted;
			$update_time = (int) $this->update_time;
			$is_default = (int) $this->is_default;


			if($is_default) {
				$sql ="UPDATE cms3_hierarchy SET is_default = '0' WHERE is_default = '1' AND lang_id = '{$lang_id}' AND domain_id = '{$domain_id}'";
				l_mysql_query($sql);
			}

			$sql = "UPDATE cms3_hierarchy SET rel = '{$rel}', type_id = '{$type_id}', lang_id = '{$lang_id}', domain_id = '{$domain_id}', tpl_id = '{$tpl_id}', obj_id = '{$object_id}', ord = '{$ord}', alt_name = '{$alt_name}', is_active = '{$is_active}', is_visible = '{$is_visible}', is_deleted = '{$is_deleted}', updatetime = '{$update_time}', is_default = '{$is_default}' WHERE id = '{$this->id}'";
			l_mysql_query($sql);

			if ($this->is_updated) {
				$search = searchModel::getInstance();
				if(PAGES_AUTO_INDEX) {
					if($this->getIsActive() && $this->getIsDeleted() == false) {
						$search->index_item($this->id);
					} else {
						$search->unindex_items($this->id);
					}
				}
			}

			if (!umiHierarchy::$ignoreSiteMap) $this->updateSiteMap(true);
			try {
				$this->updateYML();
			} catch (Exception $e) {}

			return true;
		}

		/**
		 * @deprecated
		 * TODO: Вынести из umiHierarchyElement
		 */
		public function updateYML() {
			
			$dirName = CURRENT_WORKING_DIR . "/sys-temp/yml/";

			$dirName = CURRENT_WORKING_DIR . "/sys-temp/yml/";

			$hierarchyTypes = umiHierarchyTypesCollection::getInstance();
			$hierarchyCatalogObjectType = $hierarchyTypes->getTypeByName("catalog", "object");
			$hierarchyCatalogCategoryType = $hierarchyTypes->getTypeByName("catalog", "category");
			$hierarchy = umiHierarchy::getInstance();

			if (!$hierarchyCatalogObjectType || !$hierarchyCatalogCategoryType) return false;

			if ($this->getHierarchyType()->getId() == $hierarchyCatalogCategoryType->getId()) {
				$this->checkYMLinclude();

				if (!$this->is_active || $this->is_deleted) {
					$childsIds = $hierarchy->getChildIds($this->getId(), false);
					foreach($childsIds as $childId) {
						$xml = $dirName . $childId . ".txt";
						if(file_exists($xml)) unlink($xml);
					}
				}

				return true;
			}

			if ($this->getHierarchyType()->getId() != $hierarchyCatalogObjectType->getId()) return false;


			if (!is_dir($dirName)) mkdir($dirName, 0777, true);
			$xml = $dirName . "{$this->id}.txt";
			if(file_exists($xml)) unlink($xml);

			if ($this->is_active && !$this->is_deleted) {

				$matches = $this->checkYMLinclude();
				if (!count($matches)) return false;

				$parentId = $this->getParentId();
				if ($parentId) {
					$parent = umiHierarchy::getInstance()->getElement($parentId, true, true);
					if ($parent->getHierarchyType()->getId() != $hierarchyCatalogCategoryType->getId()) {
						$parentId = false;
						$parents = $hierarchy->getAllParents($this->id, true, true);
						for ($i = count($parents)-1; $i>=0 ; $i--) {
							$newParentId = $parents[$i];
							$newParent = $hierarchy->getElement($newParentId, true);
							if ($newParent instanceof umiHierarchyElement && $newParent->getHierarchyType()->getId() == $hierarchyCatalogCategoryType->getId()) {
								$parentId = $newParentId;
								break;
					}
						}
					}
				}
				if (!$parentId) {
					throw new publicAdminException(getLabel('error-update-yml'));
				}

				$exporter = new xmlExporter('yml');
				$exporter->addElements(array($this->id));
				$exporter->setIgnoreRelations();
				$umiDump = $exporter->execute();

				$style_file = CURRENT_WORKING_DIR . '/xsl/export/YML.xsl';
				if (!is_file($style_file)) {
					throw new publicException("Can't load exporter {$style_file}");
				}

				$doc = new DOMDocument("1.0", "utf-8");
				$doc->formatOutput = XML_FORMAT_OUTPUT;
				$doc->loadXML($umiDump->saveXML());

				$templater = umiTemplater::create('XSLT', $style_file);
				$result = $templater->parse($doc);

				$dom = new DOMDocument();
				$dom->loadXML($result);
				$offer = $dom->getElementsByTagName('offer')->item(0);
				if ($offer) {
					$category = $offer->getElementsByTagName('categoryId')->item(0);
					if ($category) $category->nodeValue = $parentId;
					$content = iconv("UTF-8", "CP1251//IGNORE", $dom->saveXML($offer));
					file_put_contents($xml, $content);
				}

				$currencies = $dom->getElementsByTagName('currencies')->item(0);
				$curr = iconv("UTF-8", "CP1251//IGNORE", $dom->saveXML($currencies));
				file_put_contents($dirName . 'currencies', $curr);

				$shopName = $dom->getElementsByTagName('name')->item(0);
				$name = $shopName->nodeValue;
				$company = $dom->getElementsByTagName('company')->item(0);
				$companyName = $company->nodeValue;

				foreach ($matches as $exportId) {
					file_put_contents($dirName . 'shop' . $exportId, '<name>' . iconv("UTF-8", "CP1251//IGNORE", $name) . '</name><company>' . iconv("UTF-8", "CP1251", $companyName) . '</company><url>http://' . domainsCollection::getInstance()->getDomain($this->getDomainId())->getHost() . '</url>');
				}
			}
		}

		/**
		 * @deprecated
		 * TODO: Вынести из umiHierarchyElement
		 */
		protected function checkYMLinclude() {
			$dirName = CURRENT_WORKING_DIR . "/sys-temp/yml/";
			if (!is_dir($dirName)) return false;
			$dir = dir($dirName);

			$matches = array();
			$hierarchy = umiHierarchy::getInstance();
			$parents = $hierarchy->getAllParents($this->id, true, true);

			while (false !== ($file = $dir->read())) {
				if(strpos($file, "cat")) {
					$id = trim($file, 'cat');
					$parentsArray = unserialize(file_get_contents($dirName . $file));
					$childsArray = unserialize(file_get_contents($dirName . $id . "el"));
					$intersect = array_keys(array_intersect($parents, $parentsArray));
					$exportId = trim($file, 'cat');
					$categories = array();
					if (file_exists($dirName . 'categories' . $exportId)) {
						$categories = unserialize(file_get_contents($dirName . 'categories' . $exportId));
					}
					
					if (count($intersect)) {

						$firstParentKey = $intersect[0];
						if ($parents[$firstParentKey] == $this->getId() && $this->getHierarchyType()->getMethod() == 'object') {
							if (isset($parents[$firstParentKey-1])) $firstParentKey--;
						}

						for ($i = $firstParentKey; $i < count($parents); $i++) {

							$parentId = $parents[$i];
							$parent = $hierarchy->getElement($parentId);
							if (!$parent instanceof umiHierarchyElement) continue;
							if (!$parent->getIsActive() || $parent->getIsDeleted()) {
								if ($this->getHierarchyType()->getMethod() == 'object') return $matches;
							}
							if ($parent->getHierarchyType()->getMethod() != 'category') continue;

							if ($parent->getIsActive() && !$parent->getIsDeleted()) {

								$categoryName = $parent->getName();
								$categoryName = iconv("UTF-8", "CP1251//IGNORE", $categoryName);
								$categoryName = strtr($categoryName, array("&" => "&amp;", "<" => "&lt;", ">" => "&gt;"));

								$parentCategoryId = $parent->getParentId();
								if ($parentCategoryId && isset($categories[$parentCategoryId])) {
									$categories[$parentId] = '<category id="' . $parentId . '" parentId="' . $parentCategoryId . '">' . $categoryName . '</category>';
								} else {
									$categories[$parentId] = '<category id="' . $parentId . '">' . $categoryName . '</category>';
								}

							} else {
								if(isset($categories[$parentId])) unset($categories[$parentId]);
							}
						}
						
						if(!in_array($this->id, $childsArray) && $this->getHierarchyType()->getMethod() == 'object') {
							$childsArray[] = $this->id;
							file_put_contents($dirName . $id . "el", serialize($childsArray));
						}
						$matches[] = $exportId;
								
						

					} elseif($this->getHierarchyType()->getMethod() == 'category' &&(!$this->getIsActive() || $this->getIsDeleted())) {
						
						$childs = $hierarchy->getChildIds($this->getId(), false, true);
						$intersect = array_intersect($childs, $parentsArray);
						if (count($intersect)) {
							foreach($childs as $key => $childId) {
								if(isset($categories[$childId])) unset($categories[$childId]);
							}
						}
						
					} else {
						if($key =  array_search($this->id, $childsArray) && $this->getHierarchyType()->getMethod() == 'object') {
							unset($childsArray[$key]);
							sort($childsArray);
							file_put_contents($dirName . $id . "el", serialize($childsArray));
						}
					}
					file_put_contents($dirName . 'categories' . $exportId, serialize($categories));
				}
			}
			$dir->close();
			return $matches;
		}

		public function updateSiteMap($ignoreChilds = false) {

			$hierarchy = umiHierarchy::getInstance();

			if(!$ignoreChilds) {
				$childs = $hierarchy->getChilds($this->id, true, true, 1);

				if (is_array($childs)){
					foreach ($childs as $childId => $value) {
						$child = $hierarchy->getElement($childId)->updateSiteMap($ignoreChilds);
					}
				}
			}

			$oldForce = $hierarchy->forceAbsolutePath();
			$link = $hierarchy->getPathById($this->id, false, false, true);

			$update_time = date('c', $this->update_time);

			$sql = "SELECT level FROM cms3_hierarchy_relations WHERE (rel_id = '' or rel_id is null) and child_id={$this->id}";
			$result = l_mysql_query($sql);

			$pagePriority = 0.5;
			while(list($level) = mysql_fetch_row($result)) {
				$pagePriority = round(1 / ($level + 1), 1);
				if($pagePriority < 0.1) $pagePriority = 0.1;
			}

			$dirName = CURRENT_WORKING_DIR . "/sys-temp/sitemap/{$this->domain_id}/";
			if (!is_dir($dirName)) mkdir($dirName, 0777, true);
			$xml = $dirName . "{$this->id}.xml";
			if(file_exists($xml)) unlink($xml);

			if ($this->is_active && !$this->robots_deny && !$this->is_deleted) {
				$dom = new DOMDocument();
				$url = $dom->createElement('url');
				$loc = $dom->createElement('loc', $link);
				$priority = $dom->createElement('priority', $pagePriority);

				$lastmod = $dom->createElement('lastmod', $update_time);
				$dom->appendChild($url);
				$url->appendChild($loc);
				$url->appendChild($lastmod);
				$url->appendChild($priority);

				file_put_contents($xml, $dom->saveXML($url));
			}

			$hierarchy->forceAbsolutePath($oldForce);

		}

		/**
			* Изменить флаг измененности. Если экземпляр не помечен как измененный, метод commit() блокируется.
			* @param Boolean $is_updated=true значение флага измененности
		*/
		public function setIsUpdated($is_updated = true) {
			parent::setIsUpdated($is_updated);
			$this->update_time = time();
			umiHierarchy::getInstance()->addUpdatedElementId($this->id);
			if($this->rel) {
				umiHierarchy::getInstance()->addUpdatedElementId($this->rel);
			}
		}

		/**
			* Узнать, все ли впорядке с этим экземпляром
			* @return Boolean true, если все в порядке
		*/
		public function getIsBroken() {
			return $this->is_broken;
		}

		/**
			* Применить все изменения сделанные с этой страницей
		*/
		public function commit() {
			$object = $this->getObject();
			if($object instanceof umiObject) {
				$object->commit();

				$objectId = $object->getId();
				$hierarchy = umiHierarchy::getInstance();
				cacheFrontend::getInstance()->del($objectId, "object");

				$virtuals = $hierarchy->getObjectInstances($objectId, true, true);
				foreach($virtuals as $virtualElementId) {
					cacheFrontend::getInstance()->del($virtualElementId, "element");
				}
			}
			parent::commit();
		}

		/**
			* Получить id типа данных (класс umiObjectType), к которому относится объект (класс umiObject) источник данных.
			* @return Integer id типа данных (класс umiObjectType)
		*/
		public function getObjectTypeId() {
			return $this->getObject()->getTypeId();
		}

		/**
			* Получить базовый тип, к которому относится страница
			* @return umiHierarchyType базовый тип страницы
		*/
		public function getHierarchyType() {
			return umiHierarchyTypesCollection::getInstance()->getType($this->type_id);
		}

		/**
			* Получить id объекта (класс umiObject), который служит источником данных для страницы
			* @return Integer id объекта (класс umiObject)
		*/
		public function getObjectId() {
			return $this->object_id;
		}

		/**
			* Синоним метода getHierarchyType(). Этот метод является устаревшим.
			* @return umiHierarchyType
		*/
		protected function getType() {
			$hierarchyTypesCollection = umiHierarchyTypesCollection::getInstance();
			return $hierarchyTypesCollection->getType($this->getTypeId());
		}

		/**
			* Получить название модуля базового типа страницы
			* @return String название модуля
		*/
		public function getModule() {
			return $this->getType()->getName();
		}

		/**
			* Получить название метода базового типа страницы
			* @return String название метода
		*/
		public function getMethod() {
			return $this->getType()->getExt();
		}

		/**
			* Удалить страницу
		*/
		public function delete() {
			umiHierarchy::getInstance()->delElement($this->id);
		}

		public function __sleep() {
			$vars = get_class_vars(get_class($this));
			$vars['object'] = NULL;
			return array_keys($vars);
		}


		public function __get($varName) {
			switch($varName) {
				case "id":			return $this->id;
				case "objectId":	return $this->object_id;
				case "name":		return $this->getName();
				case "altName":		return $this->getAltName();
				case "isActive":	return $this->getIsActive();
				case "isVisible":	return $this->getIsVisible();
				case "isDeleted":	return $this->getIsDeleted();
				case "xlink":		return 'upage://' . $this->id;
				case "link": {
					$hierarchy = umiHierarchy::getInstance();
					return $hierarchy->getPathById($this->id);
				}

				default:			return $this->getValue($varName);
			}
		}

		public function __set($varName, $value) {
			switch($varName) {
				case "id":			throw new coreException("Object id could not be changed");
				case "name":		return $this->setName($value);
				case "altName":		return $this->setAltName($value);
				case "isActive":	return $this->setIsActive($value);
				case "isVisible":	return $this->setIsVisible($value);
				case "isDeleted":	return $this->setIsDeleted($value);

				default:			return $this->setValue($varName, $value);
			}
		}

		public function beforeSerialize($reget = false) {
			static $object = null;
			if($reget && !is_null($object)) {
				$this->object = $object;
			}
			else {
				$object = $this->object;
				$this->object = null;
			}
		}

		public function afterSerialize() {
			$this->beforeSerialize(true);
		}

		public function afterUnSerialize() {
			$this->getObject();
		}
	};


/**
	* Предоставляет доступ к страницам сайта (класс umiHierarchyElement) и методы для управления структурой сайта.
	* Синглтон, экземпляр коллекции можно получить через статический метод getInstance()
*/
	class umiHierarchy extends singleton implements iSingleton, iUmiHierarchy {
		private $elements = array(),
			$objects, $langs, $domains, $templates;

		private $updatedElements = Array();
		private $autocorrectionDisabled = false;
		private $elementsLastUpdateTime = 0;
		private $bForceAbsolutePath = false;
		private $symlinks = Array();
		private $misc_elements = Array();
		private $pathCache = array();
		private $pathPiecesCache = array();
		private $defaultCache = array();
		private $parentsCache = array();
		private $idByPathCache = array();

		public static $ignoreSiteMap = false;

		/**
			* Конструктор
		*/
		protected function __construct() {
            showWorkTime("umihierarchy construct start");
			$this->objects		=	umiObjectsCollection::getInstance();
            showWorkTime("umihierarchy umiObjectsCollection init");
			$this->langs		=	langsCollection::getInstance();
            showWorkTime("umihierarchy langsCollection init");
			$this->domains		=	domainsCollection::getInstance();
            showWorkTime("umihierarchy domainsCollection init");
			$this->templates	=	templatesCollection::getInstance();
            showWorkTime("umihierarchy templatesCollection init");

			if(regedit::getInstance()->getVal("//settings/disable_url_autocorrection")) {
				$this->autocorrectionDisabled = true;
			}
		}

		/**
			* Получить экземпляр коллекции
			* @return umiHierarchy экземпляр класса umiHierarchy
		*/
		public static function getInstance($c = NULL) {
			return parent::getInstance(__CLASS__);
		}

		/**
			* Проверяет, существует ли страница (класс umiHierarchyElement) с id $element_id
			* @param Integer $element_id id странциы
			* @return Boolean true если существует
		*/
		public function isExists($element_id) {
			if($this->isLoaded($element_id)) {
				return true;
			} else {
				$element_id = (int) $element_id;

				$sql = "SELECT id FROM cms3_hierarchy WHERE id = '{$element_id}'";
				$result = l_mysql_query($sql);

				list($count) = mysql_fetch_row($result);
				return (bool) $count;
			}
		}

		/**
			* Проверяет, загружена ли в память страница (класс umiHierarchyElement) с id $element_id
			* @param Integer $element_id id странциы
			* @return Boolean true если экземпляр класса umiHierarchyElement с id $element_id уже загружен в память
		*/
		public function isLoaded($element_id) {
			if($element_id === false) {
				return false;
			}

			if(is_array($element_id)) {
				$is_loaded = true;

				foreach($element_id as $celement_id) {
					if(!array_key_exists($celement_id, $this->elements)) {
						$is_loaded = false;
						break;
					}
				}

				return $is_loaded;
			} else {
				return (bool) array_key_exists($element_id, $this->elements);
			}
		}

		/**
			* Получить экземпляр страницы (класс umiHierarchyElement) с id $element_id
			* @param Integer $element_id id страницы
			* @param Boolean $ignorePermissions=false игнорировать права доступа при получении экземпляра страницы
			* @param Boolean $ignoreDeleted=false игнорировать состояние удаленности (т.е. возможность получить удаленную страницу)
			* @return umiHierarchyElement экземпляр страницы, либо false если нельзя получить экземпляр
		*/
		public function getElement($element_id, $ignorePermissions = false, $ignoreDeleted = false, $row = false) {
			if(!$element_id) {
				return false;
			}
			if($row === false && !$ignorePermissions && !$this->isAllowed($element_id)) return false;
			$cacheFrontend = cacheFrontend::getInstance();

			if($this->isLoaded($element_id)) {
				return $this->elements[$element_id];
			} else {
				$element = $cacheFrontend->load($element_id, "element");
				if($element instanceof iUmiHierarchyElement == false) {
					try {
						$element = new umiHierarchyElement($element_id, $row);

						$cacheFrontend->save($element, "element");
					} catch (privateException $e) {
						return false;
					}
				}
				$this->misc_elements[] = $element_id;


				if(is_object($element)) {

					if($element->getIsBroken()) return false;
					if($element->getIsDeleted() && !$ignoreDeleted) return false;

					$this->pushElementsLastUpdateTime($element->getUpdateTime());
					$this->elements[$element_id] = $element;
					return $this->elements[$element_id];
				} else return false;
			}
		}

		/**
			* Удалить страницу с id $element_id
			* @param Integer $element_id id страницы
			* @return Boolean true, если удалось удалить страницу
		*/
		public function delElement($element_id) {
			$this->disableCache();
			$cacheFrontend = cacheFrontend::getInstance();
			$permissions = permissionsCollection::getInstance();

			$this->addUpdatedElementId($element_id);
			$this->forceCacheCleanup();

			if(!$permissions->isAllowedObject($permissions->getUserId(), $element_id)) return false;

			if($element = $this->getElement($element_id)) {
				$sql = "SELECT id FROM cms3_hierarchy FORCE INDEX(rel) WHERE rel = '{$element_id}'";
				$result = l_mysql_query($sql);

				while(list($child_id) = mysql_fetch_row($result)) {
					$child_element = $this->getElement($child_id, true, true);
					$this->delElement($child_id);
					$cacheFrontend->del($child_id, "element");
				}


				$element->setIsDeleted(true);
				$element->commit();
				unset($this->elements[$element_id]);

				$cacheFrontend->del($element_id, "element");
				return true;
			} else {
				return false;
			}
		}

		/**
			* Создать виртуальную копию (подобие symlink в файловых системах) страницы $element_id
			* @param Integer $element_id id страницы, которую необходимо скопировать
			* @param Integer $rel_id id страницы, которая будет являться родителем созданной копии
			* @param Boolean $copySubPages=false если у копируемой страницы есть потомки, то если true они будут скопированы рекурсивно
			* @return Integer id новой виртуальной копии страницы, либо false
		*/
		public function copyElement($element_id, $rel_id, $copySubPages = false) {
			$this->disableCache();
			cacheFrontend::getInstance()->flush();

			$this->misc_elements[] = $rel_id;
			$this->misc_elements[] = $element_id;

			$this->forceCacheCleanup();

			if($this->isExists($element_id) && ($this->isExists($rel_id) || $rel_id === 0)) {
				$rel_id = (int) $rel_id;
				$timestamp = self::getTimeStamp();

				if($element = $this->getElement($element_id)) {
					$this->misc_elements[] = $element->getParentId();
				}

				$res = mysql_fetch_array(l_mysql_query('SELECT MAX(ord) FROM cms3_hierarchy', true));
				$ord = $res[0]+1;
				$sql = <<<SQL

INSERT INTO cms3_hierarchy
	(rel, type_id, lang_id, domain_id, tpl_id, obj_id, alt_name, is_active, is_visible, is_deleted, updatetime, ord)
		SELECT '{$rel_id}', type_id, lang_id, domain_id, tpl_id, obj_id, alt_name, is_active, is_visible, is_deleted, '{$timestamp}', '{$ord}'
				FROM cms3_hierarchy WHERE id = '{$element_id}' LIMIT 1
SQL;
				l_mysql_query($sql);

				$old_element_id = $element_id;
				$element_id = l_mysql_insert_id();

				//Copy permissions

				$sql = <<<SQL

INSERT INTO cms3_permissions
	(level, owner_id, rel_id)
		SELECT level, owner_id, '{$element_id}' FROM cms3_permissions WHERE rel_id = '{$old_element_id}'

SQL;
				l_mysql_query($sql);


				if($element = $this->getElement($element_id)) {
					$element->setAltName($element->getAltName());
					$element->commit();

					$this->buildRelationNewNodes($element_id);

					if($copySubPages) {
						$domain_id = $element->getDomainId();

						$childs = $this->getChilds($old_element_id, true, true, 0, false, $domain_id);
						foreach($childs as $child_id => $nl) {
							$this->copyElement($child_id, $element_id, true);
						}
					}

					$this->misc_elements[] = $element_id;

					return $element_id;
				} else return false;
			} else return false;
		}


		/**
			* Создать копию страницы $element_id вместе со всеми данными
			* @param Integer $element_id id страницы, которую необходимо скопировать
			* @param Integer $rel_id id страницы, которая будет являться родителем созданной копии
			* @param Boolean $copySubPages=false если у копируемой страницы есть потомки, то если true они будут скопированы рекурсивно
			* @return Integer id новой копии страницы, либо false
		*/
		public function cloneElement($element_id, $rel_id, $copySubPages = false) {
			$this->disableCache();
			cacheFrontend::getInstance()->flush();

			$this->misc_elements[] = $rel_id;
			$this->misc_elements[] = $element_id;

			$this->forceCacheCleanup();

			if($this->isExists($element_id) && ($this->isExists($rel_id) || $rel_id === 0)) {
				if($element = $this->getElement($element_id)) {
					$ord = (int) $element->getOrd();
				}



				$this->misc_elements[] = $element->getParentId();

				$res = mysql_fetch_array(l_mysql_query('SELECT MAX(ord) FROM cms3_hierarchy', true));
				$ord = $res[0] + 1;

				$object_id = $element->getObject()->getId();

				$sql = <<<SQL
INSERT INTO cms3_objects
	(name, is_locked, type_id, owner_id)
		SELECT name, is_locked, type_id, owner_id
			FROM cms3_objects
				WHERE id = '{$object_id}'
SQL;
				l_mysql_query($sql);

				$new_object_id = l_mysql_insert_id();

				$object_type = umiObjectsCollection::getInstance()->getObject($object_id)->getTypeId();
				$table_content = umiBranch::getBranchedTableByTypeId($object_type);

				$sql = <<<SQL
INSERT INTO {$table_content}
	(field_id, int_val, varchar_val, text_val, rel_val, float_val, tree_val, obj_id)
		SELECT field_id, int_val, varchar_val, text_val, rel_val, float_val, tree_val, '{$new_object_id}'
			FROM {$table_content}
				WHERE obj_id = '{$object_id}'
SQL;
				l_mysql_query($sql);

				$timestamp = self::getTimeStamp();

				$sql = <<<SQL

INSERT INTO cms3_hierarchy
	(rel, type_id, lang_id, domain_id, tpl_id, obj_id, alt_name, is_active, is_visible, is_deleted, updatetime, ord)
		SELECT '{$rel_id}', type_id, lang_id, domain_id, tpl_id, '{$new_object_id}', alt_name, is_active, is_visible, is_deleted, '{$timestamp}', '{$ord}'
				FROM cms3_hierarchy WHERE id = '{$element_id}' LIMIT 1
SQL;
				l_mysql_query($sql);


				$old_element_id = $element_id;

				$element_id = l_mysql_insert_id();


				//Copy permissions
				$sql = <<<SQL

INSERT INTO cms3_permissions
	(level, owner_id, rel_id)
		SELECT level, owner_id, '{$element_id}' FROM cms3_permissions WHERE rel_id = '{$old_element_id}'

SQL;
				l_mysql_query($sql);

				if($element = $this->getElement($element_id)) {
					$element->setAltName($element->getAltName());
					$element->commit();

					$this->buildRelationNewNodes($element_id);

					if($copySubPages) {
						$domain_id = $element->getDomainId();

						$childs = $this->getChilds($old_element_id, true, true, 0, false, $domain_id);
						foreach($childs as $child_id => $nl) {
							$this->cloneElement($child_id, $element_id, true);
						}
					}

					$this->misc_elements[] = $element_id;

					return $element_id;
				} else  return false;
			}
		}

		/**
			* Получить список удаленных страниц (страниц в корзине)
			* @return Array массив, состоящий из id удаленных страниц
		*/
		public function getDeletedList() {

			$res = array();
			$tmp = array();

			$sql = <<<SQL
SELECT id, rel FROM cms3_hierarchy WHERE is_deleted = '1' ORDER BY updatetime DESC
SQL;
			$result = l_mysql_query($sql);

			while(list($id, $rel) = mysql_fetch_row($result)) {

				$tmp[$id] = $rel;

				$keys = array_keys($tmp, $id);
				if (count($keys)) {
					foreach ($keys as $key) {
						if (array_key_exists($key, $res)) {
							unset($res[$key]);
						}
					}
				}

				if(array_key_exists($rel, $tmp)) {
					continue;
				}

				$res[$id] = $id;

			}

			return array_values($res);
		}

		/**
			* Восстановить страницу из корзины
			* @param id $element_id страницы, которую необходимо восстановить из корзины
			* @return Boolean true, если удалось
		*/
		public function restoreElement($element_id) {
			$this->disableCache();

			if($element = $this->getElement($element_id, false, true)) {
				$element->setIsDeleted(false);
				$element->setAltName($element->getAltName());
				$element->commit();

				$sql = "SELECT id FROM cms3_hierarchy WHERE rel = '{$element_id}'";
				$result = l_mysql_query($sql);

				while(list($child_id) = mysql_fetch_row($result)) {
					$child_element = $this->getElement($child_id, true, true);
					$this->restoreElement($child_id);
				}
				return true;
			} else return false;
		}

		/**
			* Удалить из корзины страницу $element_id (и из БД)
			* @param Integer $element_id id страницы, которую будем удалять
			* @return Boolean true в случае успеха
		*/
		public function removeDeletedElement($element_id, &$deleted_count = 0) {
			$this->disableCache();

			if($element = $this->getElement($element_id, true, true)) {
				if($element->getIsDeleted()) {
					$element_id = (int) $element_id;
					$object_id = $element->getObjectId();
					$objects = umiObjectsCollection::getInstance();

					$sql = "SELECT id FROM cms3_hierarchy WHERE rel = '{$element_id}'";
					$result = l_mysql_query($sql);

					while(list($child_id) = mysql_fetch_row($result)) {
						$child_element = $this->getElement($child_id, true, true);
						$child_element->setIsDeleted(true);
						$child_element->commit();
						$this->removeDeletedElement($child_id, $deleted_count);
					}

					$sql = "DELETE FROM cms3_hierarchy WHERE id = '{$element_id}' LIMIT 1";
					l_mysql_query($sql);

					unset($element);
					unset($this->elements[$element_id]);

					//TODO: Make object delete here, if no hierarchy links exist.
					$sql = "SELECT COUNT(*) FROM cms3_hierarchy WHERE obj_id = '{$object_id}'";
					$result = l_mysql_query($sql, true);

					if(list($c) = mysql_fetch_row($result)) {
						if($c == 0) {
							$objects->delObject($object_id);
						}
					}

					$this->earseRelationNodes($element_id);

					$deleted_count ++;

					return true;
				} else return false;
			} else return false;
		}

		/**
			* Удалить страницы из корзины (т.е. и из БД)
			* @return Boolean true в случае успеха
		*/
		public function removeDeletedAll() {
			$this->disableCache();

			l_mysql_query("START TRANSACTION /* umiHierarchy::removeDeletedAll() */");

			$sql = "SELECT id FROM cms3_hierarchy WHERE is_deleted = '1'";
			$result = l_mysql_query($sql);

			while(list($element_id) = mysql_fetch_row($result)) {
				$this->removeDeletedElement($element_id);
			}

			l_mysql_query("COMMIT");

			return true;
		}


		/**
			* Удалить страницы из корзины (т.е. и из БД). Аналог removeDeletedAll, но с ограничением $limit
			* @return Int количество элементов вместе с детьми
		*/
		public function removeDeletedWithLimit($limit = false) {
			if(empty($limit)) {
				$limit = 100;
			}

			$this->disableCache();

			l_mysql_query("START TRANSACTION /* umiHierarchy::removeDeletedWithLimit() */");

			$sql = "SELECT id FROM cms3_hierarchy WHERE is_deleted = '1' LIMIT ".$limit;
			$result = l_mysql_query($sql);

			$deleted_count = 0;
			while(list($element_id) = mysql_fetch_row($result)) {
				$this->removeDeletedElement($element_id, $deleted_count);
			}

			l_mysql_query("COMMIT");

			return $deleted_count;
		}

		/**
			* Получить id родительской страницы для $element_id
			* @param Integer $element_id id страницы
			* @return Integer id родительской страницы, либо false
		*/
		public function getParent($element_id) {
			$element_id = (int) $element_id;

			$sql = "SELECT rel FROM cms3_hierarchy WHERE id = '{$element_id}'";
			$result = l_mysql_query($sql, true);

			if(mysql_num_rows($result)) {
				list($parent_id) = mysql_fetch_row($result);

				$this->misc_elements[] = $parent_id;
				mysql_freeresult($result);
				return (int) $parent_id;
			} else {
				mysql_freeresult($result);
				return false;
			}
		}

		/**
			* Получить список всех родительских страниц
			* @param Integer $element_id id страницы, родителей которой необходимо получить
			* @param Boolean $include_self=false включить в результат саму страницу $element_id
			* @param Boolean $ignoreCache = false не использовать микрокеширование
			* @return Array массив, состоящий из id родиткельских страниц
		*/
		public function getAllParents($element_id, $include_self = false, $ignoreCache = false) {
			$cacheFrontend = cacheFrontend::getInstance();
			$element_id = (int) $element_id;
			$parents = array();

			$cacheData = $cacheFrontend->loadSql('hierarchy_parents');
			if(is_array($cacheData) && sizeof($cacheData)) {
				$this->parentsCache = $cacheData;
			}

			if(!$ignoreCache && isset($this->parentsCache[$element_id])) {
				$parents = $this->parentsCache[$element_id];
			} else {
				$sql = "SELECT rel_id FROM cms3_hierarchy_relations WHERE child_id = '{$element_id}' ORDER BY id";
				$result = l_mysql_query($sql);

				while(list($parent_id) = mysql_fetch_row($result)) {
					$parents[] = (int) $parent_id;
				}
				$this->parentsCache[$element_id] = $parents;
				$cacheFrontend->saveSql('hierarchy_parents', $this->parentsCache, 120);
			}
			if($include_self) {
				$parents[] = (int) $element_id;
			}
			return $parents;
		}

		/**
			* Получить список дочерних страниц по отношению к $element_id
			* @param Integer $element_id id страницы, у которой нужно взять всех потомков
			* @param Boolean $allow_unactive=true если true, то в результат будут включены неактивные страницы
			* @param Boolean $allow_unvisible=true если true, то в результат будут включены невидимые в меню страницы
			* @param Integer $depth=0 глубина поиска
			* @param Boolean $hierarchy_type_id=false включить в результат только страницы с указанным id базового типа (umiHierarchyType)
			* @param Integer $domainId=false указать id домена (актуально если ишем от корня: $element_id = 0)
			* @param Integer $langId=false указать id языка (актуально если ишем в домене от корня: $element_id = 0)
			* @return Array рекурсивный ассоциотивный массив, где ключ это id страницы, значение - массив детей
		*/
		public function getChilds($element_id, $allow_unactive = true, $allow_unvisible = true, $depth = 0, $hierarchy_type_id = false, $domainId = false, $langId = false) {
			$cacheFrontend = cacheFrontend::getInstance();
			$cmsController = cmsController::getInstance();

			$element_id = (int) $element_id;
			$allow_unactive = (int) $allow_unactive;
			$allow_unvisible = (int) $allow_unvisible;
			$hierarchy_type_id = (int) $hierarchy_type_id;

			if (!$langId) $langId = $cmsController->getCurrentLang()->getId();
			
			$domain_id = ($domainId) ? $domainId : $cmsController->getCurrentDomain()->getId();
			$domain_cond = ($element_id > 0) ? "" : " AND h.domain_id = '{$domain_id}'";

			$permissions = permissionsCollection::getInstance();
			$userId = $permissions->getUserId();
			$isUserSuperVisor = $permissions->isSv($userId);
			$permissionsSql = $permissions->makeSqlWhere($userId);

			$res = array();

			$s_element_id = ($element_id) ? "= '{$element_id}'" : "IS NULL";
			$sql = "SELECT hr.child_id, h.rel, cp.level FROM cms3_hierarchy_relations hr, cms3_permissions cp, cms3_hierarchy h WHERE hr.rel_id {$s_element_id} AND h.id = hr.child_id {$domain_cond} AND h.lang_id = '{$langId}' AND h.is_deleted = '0'";
			if($isUserSuperVisor) {
				$sql = "SELECT hr.child_id, h.rel, 2 FROM cms3_hierarchy_relations hr, cms3_hierarchy h WHERE hr.rel_id {$s_element_id} AND h.id = hr.child_id {$domain_cond} AND h.lang_id = '{$langId}' AND h.is_deleted = '0'";
			}


			if(!$allow_unactive)	$sql .= " AND h.is_active = '1'";
			if(!$allow_unvisible)	$sql .= " AND h.is_visible = '1'";
			if($hierarchy_type_id) $sql .= " AND h.type_id = '{$hierarchy_type_id}'";

			if(!$isUserSuperVisor) {
				$sql .= " AND (cp.rel_id = h.id AND {$permissionsSql} AND cp.level > 0)";
			}

			if($depth) {
				if($element_id) {
					$result = l_mysql_query("SELECT level FROM cms3_hierarchy_relations WHERE child_id = {$element_id}");
					if(mysql_num_rows($result)) {
						list($level) = mysql_fetch_row($result);
						$level += $depth;
					} else {
						return false;
					}
				} else {
					$level = $depth;
				}
				$sql .= " AND hr.level <= '{$level}'";
			}

			$sql .= " ORDER BY hr.level, h.ord";

			if($res = $cacheFrontend->loadSql($sql)) {
				foreach($res[1] as $elementId => $level) {
					$permissions->pushElementPermissions($elementId, $level);
				}
				return $res[0];
			}

			$result = l_mysql_query($sql);

			$flat_childs = $perms_list = $res = array();
			while(list($child_id, $rel_id, $level) = mysql_fetch_row($result)) {
				$permissions->pushElementPermissions($child_id, $level);

				$flat_childs[$child_id] = array();
				if($rel_id == $element_id) {
					$res[$child_id] = &$flat_childs[$child_id];
				}
				if(isset($flat_childs[$rel_id])) {
					$flat_childs[$rel_id][$child_id] = &$flat_childs[$child_id];
				}
				$perms_list[$child_id] = $level;
			}

			$cacheFrontend->saveSql($sql, array($res, $perms_list), 60);
			return $res;
		}

		/**
			* Получить список id потомков по отношению к $element_id на всю глубину
			* @param Integer $element_id id страницы, у которой нужно взять всех потомков
			* @param Boolean $allow_unactive=true если true, то в результат будут включены неактивные страницы
			* @param Boolean $allow_unvisible=true если true, то в результат будут включены невидимые в меню страницы
			* @param Boolean $hierarchy_type_id=false включить в результат только страницы с указанным id базового типа (umiHierarchyType)
			* @param Integer $domainId=false указать id домена (актуально если ишем от корня: $element_id = 0)
			* @param Boolean $include_self=false включить в результат $element_id
			* @param Integer $langId=false указать id языка (актуально если ишем от корня: $element_id = 0)
			* @return Array массив id потомков
		*/
		public function getChildIds($element_id, $allow_unactive = true, $allow_unvisible = true, $hierarchy_type_id = false, $domainId = false, $include_self = false, $langId = false) {

			$childIds = array();
			if($include_self) $childIds[] = $element_id;
			$childs = $this->getChilds($element_id, $allow_unactive, $allow_unvisible, 1, $hierarchy_type_id, $domainId, $langId);
			if ($childs === false) return $childIds;
			foreach ($childs as $childId => $value) {
				$childIds = array_merge($childIds, $this->getChildIds($childId, $allow_unactive, $allow_unvisible, $hierarchy_type_id, $domainId, true, $langId));
			}
			$childIds = array_unique($childIds);
			return $childIds;

		}

		/**
			* Получить количество дочерних страниц по отношению к $element_id
			* @param Integer $element_id id страницы, у которой нужно взять всех потомков
			* @param Boolean $allow_unactive=true если true, то в результат будут включены неактивные страницы
			* @param Boolean $allow_unvisible=true если true, то в результат будут включены невидимые в меню страницы
			* @param Integer $depth=0 глубина поиска
			* @param Boolean $hierarchy_type_id=false включить в результат только страницы с указанным id базового типа (umiHierarchyType)
			* @param Integer $domainId=false указать id домена (актуально если ишем от корня: $element_id = 0)
			* @return Integer количество детей
		*/
		public function getChildsCount($element_id, $allow_unactive = true, $allow_unvisible = true, $depth = 0, $hierarchy_type_id = false, $domainId = false) {
			$element_id = (int) $element_id;
			$allow_unactive = (int) $allow_unactive;
			$allow_unvisible = (int) $allow_unvisible;
			$hierarchy_type_id = (int) $hierarchy_type_id;

			$lang_id = cmsController::getInstance()->getCurrentLang()->getId();
			$domain_id = ($domainId) ? $domainId : cmsController::getInstance()->getCurrentDomain()->getId();
			if($element_id) {
				$element = $this->getElement($element_id, true);
				if($element instanceof umiHierarchyElement) {
					$lang_id = $element->getLangId();
					$domain_id = $element->getDomainId();
				}
			}
			$domain_cond = ($element_id > 0) ? "" : " AND h.domain_id = '{$domain_id}'";

			$res = array();

			$s_element_id = ($element_id) ? "= '{$element_id}'" : "IS NULL";
			$sql = "SELECT COUNT(hr.child_id) FROM cms3_hierarchy_relations hr, cms3_hierarchy h WHERE hr.rel_id {$s_element_id} AND h.id = hr.child_id {$domain_cond} AND h.lang_id = '{$lang_id}' AND h.is_deleted = '0'";
			if(!$allow_unactive)	$sql .= " AND h.is_active = '1'";
			if(!$allow_unvisible)	$sql .= " AND h.is_visible = '1'";
			if($hierarchy_type_id) $sql .= " AND h.type_id = '{$hierarchy_type_id}'";
			if($depth) {
				if($element_id) {
					list($level) = mysql_fetch_row(l_mysql_query("SELECT level FROM cms3_hierarchy_relations WHERE child_id = '{$element_id}'"));
					$level = $depth + $level;
				} else {
					$level = 1;
				}
				$sql .= " AND hr.level <= '{$level}'";
			}

			$sql .= " ORDER BY hr.level, h.ord";

			$result = l_mysql_query($sql);

			if(mysql_num_rows($result)) {
				list($count) = mysql_fetch_row($result);
				return $count;
			} else {
				return false;
			}
		}


		/**
			* Переключить режим генерации урлов между относительным и полным (влючать адрес домена даже если он совпадает с текущим доменом)
			* @param Boolean $bIsForced=true true - режим полных урлов, false - обычный режим
			* @return Boolean предыдущее значение
		*/
		public function forceAbsolutePath($bIsForced = true) {
			$bOldValue = $this->bForceAbsolutePath;
			$this->bForceAbsolutePath = (bool) $bIsForced;
			return $bOldValue;
		}

		/**
			* Получить адрес страницы по ее id
			* @param id $element_id страницы, путь которой нужно получить
			* @param Boolean $ignoreLang=false не подставлять языковой префикс к адресу страницы
			* @param Boolean $ignoreIsDefaultStatus=false игнорировать статус страницы "по умолчанию" и сформировать для не полный путь
			* @param Boolean $ignoreCache игнорировать кеш
			* @return String адрес страницы
		*/
		public function getPathById($element_id, $ignoreLang = false, $ignoreIsDefaultStatus = false, $ignoreCache = false) {
			$element_id = (int) $element_id;

			if(!$ignoreCache && isset($this->pathCache[$element_id . $ignoreLang . $this->bForceAbsolutePath])) return $this->pathCache[$element_id . $ignoreLang . $this->bForceAbsolutePath];
			$cmsController = cmsController::getInstance();
			$hierarchy = umiHierarchy::getInstance();
			$cacheFrontend = cacheFrontend::getInstance();
			$domains = domainsCollection::getInstance();
			$langs = langsCollection::getInstance();

			$pre_lang = $cmsController->pre_lang;

			$url_prefix = $cmsController->getUrlPrefix();

			if($element = $hierarchy->getElement($element_id, true)) {
				$current_domain = $cmsController->getCurrentDomain();
				$element_domain_id = $element->getDomainId();

				if(!$this->bForceAbsolutePath && $current_domain->getId() == $element_domain_id) {
					$domain_str = "";
				} else {
					$domain_str = "http://" . $domains->getDomain($element_domain_id)->getHost();
				}

				$element_lang_id = intval($element->getLangId());
				$element_lang = $langs->getLang($element_lang_id);

				$b_lang_default = ($element_lang_id === intval($cmsController->getCurrentDomain()->getDefaultLangId()));

				if(!$element_lang || $b_lang_default || $ignoreLang == true) {
					$lang_str = "";
				} else {
					$lang_str = "/" . $element_lang->getPrefix();
				}

				if($element->getIsDefault() && !$ignoreIsDefaultStatus) {
					return $this->pathCache[$element_id . $ignoreLang . $this->bForceAbsolutePath] = $domain_str . $lang_str . $url_prefix . '/';
				}
			} else {
				return $this->pathCache[$element_id . $ignoreLang . $this->bForceAbsolutePath] = "";
			}

			if($parents = $this->getAllParents($element_id, false, $ignoreCache)) {
				$path = $domain_str . $lang_str.$url_prefix;

				$parents[] = $element_id;

				$toLoad = array();

				foreach($parents as $parentId) {
					if($parentId == 0) continue;
					if(isset($this->pathPiecesCache[$parentId])) continue;
					if($this->isLoaded($parentId) && $parent = $this->getElement($parentId, true)) {
						$this->pathPiecesCache[$parentId] = $parent->getAltName();
					} else {
						$toLoad[] = $parentId;
					}
				}

				if(count($toLoad)) {
					$sql = "SELECT id, alt_name FROM cms3_hierarchy WHERE id IN (" . implode(", ", $toLoad) . ")";

					$altNames = !$ignoreCache ? $cacheFrontend->loadSql($sql) : null;
					if(!is_array($altNames)) {
						$result = l_mysql_query($sql);

						$altNames = array();
						while(list($id, $altName) = mysql_fetch_row($result)) {
							$altNames[$id] = $altName;
							$this->pathPiecesCache[$id] = $altName;
						}
						$cacheFrontend->saveSql($sql, $altNames, 600);
					}
					else {
						$this->pathPiecesCache = $this->pathPiecesCache + $altNames;
				}
				}

				$sz = sizeof($parents);
				for($i = 0; $i < $sz; $i++) {
					if(!$parents[$i]) continue;

					if(isset($this->pathPiecesCache[$parents[$i]])) {
						$path .= "/" . $this->pathPiecesCache[$parents[$i]];
					}
				}
				$path .= "/";

				return $this->pathCache[$element_id . $ignoreLang . $this->bForceAbsolutePath] = $path;
			} else {
				return $this->pathCache[$element_id . $ignoreLang . $this->bForceAbsolutePath] = false;
			}

		}

		/**
			* Получить id страницы по ее адресу
			* @param String $element_path
			* @param Boolean $show_disabled = false
			* @param Integer $errors_count = 0 ссылка на переменную, в которую записывается количество несовпадений при разборе адреса
			* @param Integer $domain_id = false идентификатор домена
			* @param Integer $lang_id = false идентификатор языка
			* @return Integer id страницы, либо false
		*/
		public function getIdByPath($element_path, $show_disabled = false, &$errors_count = 0, $domain_id = false, $lang_id = false) {
			$lang_id = (int) $lang_id;
			$domain_id = (int) $domain_id;
			$element_path = trim($element_path, "\/ \n");

			$cmsController = cmsController::getInstance();
			if(empty($lang_id)) {
				$lang_id = $cmsController->getCurrentLang()->getId();
			}

			if(empty( $domain_id)) {
				$domain_id = $cmsController->getCurrentDomain()->getId();
			}

			$element_hash = md5( $domain_id.":".$lang_id.":".$element_path );

			if(isset($this->idByPathCache[$element_hash])) {
				return $this->idByPathCache[$element_hash];
			}

			$cacheFrontend = cacheFrontend::getInstance();
			if($id = $cacheFrontend->loadSql($element_hash . "_path")) {
				return $id;
			}

			if($element_path == "") {
				return $this->idByPathCache[$element_hash] = $this->getDefaultElementId($lang_id, $domain_id);
			}

			$domains = domainsCollection::getInstance();
			$paths = explode("/", $element_path);
			$sz = sizeof($paths);
			$id = 0;
			for($i = 0; $i < $sz; $i++) {
				$alt_name = $paths[$i];
				$alt_name = l_mysql_real_escape_string($alt_name);

				if($i == 0) {
					if($element_domain_id = $domains->getDomainId($alt_name)) {
						$domain_id = $element_domain_id;
						continue;
					}
				}


				if($show_disabled) {
					$sql = "SELECT id FROM cms3_hierarchy WHERE rel = '{$id}' AND alt_name = '{$alt_name}' AND lang_id = '{$lang_id}' AND domain_id = '{$domain_id}'";
				} else {
					$sql = "SELECT id FROM cms3_hierarchy WHERE rel = '{$id}' AND alt_name = '{$alt_name}' AND is_active='1' AND is_deleted = '0' AND lang_id = '{$lang_id}' AND domain_id = '{$domain_id}'";
				}

				$result = l_mysql_query($sql);

				if(!mysql_num_rows($result)) {
					if($show_disabled) {
						$sql = "SELECT id, alt_name FROM cms3_hierarchy WHERE rel = '{$id}' AND lang_id = '{$lang_id}' AND domain_id = '{$domain_id}'";
					} else {
						$sql = "SELECT id, alt_name FROM cms3_hierarchy WHERE rel = '{$id}' AND is_active = '1' AND is_deleted = '0' AND lang_id = '{$lang_id}' AND domain_id = '{$domain_id}'";
					}
					$result = l_mysql_query($sql);

					$max = 0;
					$temp_id = 0;
					$res_id = 0;
					while(list($temp_id, $cstr) = mysql_fetch_row($result)) {
						if($this->autocorrectionDisabled) {
							if($alt_name == $cstr) {
								$res_id = $temp_id;
							}
						} else {
							$temp = umiHierarchy::compareStrings($alt_name, $cstr);
							if($temp > $max) {
								$max = $temp;
								$res_id = $temp_id;

								++$errors_count;
							}
						}
					}

					if($max > 75) {
						$id = $res_id;
					} else {
						return $this->idByPathCache[$element_hash] = false;
					}
				} else {
					if(!(list($id) = mysql_fetch_row($result))) {
						return $this->idByPathCache[$element_hash] = false;
					}
				}
			}

			$cacheFrontend->saveSql($element_hash . "_path", $id, 3600);

			return $this->idByPathCache[$element_hash] = $id;
		}

		/**
			* Добавить новую страницу
			* @param Interget $rel_id id родительской страницы
			* @param Integer $hierarchy_type_id id иерархического типа (umiHierarchyType)
			* @param String $name название старницы
			* @param String $alt_name псевдостатический адрес (если не передан, то будет вычислен из $name)
			* @param Integer $type_Id = false id типа данных (если не передан, то будет вычислен из $hierarchy_type_id)
			* @param Integer $domain_id = false id домена (имеет смысл только если $rel_id = 0)
			* @param Integer $lang_id = false id языковой версии (имеет смысл только если $rel_id = 0)
			* @param Integer $tpl_id = false id шаблона, по которому будет выводится страница
			* @return Integer id созданной страницы, либо false
		*/
		public function addElement($rel_id, $hierarchy_type_id, $name, $alt_name, $type_id = false, $domain_id = false, $lang_id = false, $tpl_id = false) {
			$this->disableCache();

			if($type_id === false) {
				if($hierarchy_type = umiHierarchyTypesCollection::getInstance()->getType($hierarchy_type_id)) {
					$type_id = umiObjectTypesCollection::getInstance()->getBaseType($hierarchy_type->getName(), $hierarchy_type->getExt());

					if(!$type_id) {
						throw new coreException("There is no base object type for hierarchy type #{$hierarchy_type_id}");
						return false;
					}
				} else {
					throw new coreException("Wrong hierarchy type id given");
					return false;
				}
			} else {
				$object_type = umiObjectTypesCollection::getInstance()->getType($type_id);
				if (!$object_type) {
					throw new coreException("Wrong object type id given");
					return false;
				}
				$hierarchy_type_id = $object_type->getHierarchyTypeId();
				$hierarchy_type = umiHierarchyTypesCollection::getInstance()->getType($hierarchy_type_id);
			}

			$parent = null;

			if($domain_id === false) {
				if($rel_id == 0) {
					$domain_id = cmsController::getInstance()->getCurrentDomain()->getId();
				} else {
					$parent = $this->getElement($rel_id, true, true);
					$domain_id = $parent->getDomainId();
				}
			}

			if($lang_id === false) {
				if($rel_id == 0) {
					$lang_id = cmsController::getInstance()->getCurrentLang()->getId();
				} else {
					if(!$parent) $parent = $this->getElement($rel_id, true, true);
					$lang_id = $parent->getLangId();
				}
			}

			if($tpl_id === false) {
				$tpl_id = templatesCollection::getInstance()->getHierarchyTypeTemplate($hierarchy_type->getName(), $hierarchy_type->getExt());
				if($tpl_id === false) {
					$tpl_id = $this->getDominantTplId($rel_id);
					if(!$tpl_id) {
						$tpl = templatesCollection::getInstance()->getDefaultTemplate($domain_id, $lang_id);
						if (!$tpl instanceof template) throw new coreException("Failed to detect default template");
						$tpl_id = $tpl->getId();

					}
				}
			}

			if($rel_id) {
				$this->addUpdatedElementId($rel_id);
			} else {
				$this->addUpdatedElementId($this->getDefaultElementId());
			}

			if($object_id = $this->objects->addObject($name, $type_id)) {


				$sql = "INSERT INTO cms3_hierarchy (rel, type_id, domain_id, lang_id, tpl_id, obj_id) VALUES('{$rel_id}', '{$hierarchy_type_id}', '{$domain_id}', '{$lang_id}', '{$tpl_id}', '{$object_id}')";
				l_mysql_query($sql);

				$element_id = l_mysql_insert_id();

				$element = $this->getElement($element_id, true);

				$element->setAltName($alt_name);

				$sql = "SELECT MAX(ord) FROM cms3_hierarchy WHERE rel = '{$rel_id}'";
				$result = l_mysql_query($sql);

				if(list($ord) = mysql_fetch_row($result)) {
					$element->setOrd( ($ord + 1) );
				}

				$element->commit();

				$this->elements[$element_id] = $element;

				$this->addUpdatedElementId($rel_id);
				$this->addUpdatedElementId($element_id);

				if($rel_id) {

					$parent_element = $this->getElement($rel_id);
					if($parent_element instanceof umiHierarchyElement) {
						$object_instances = $this->getObjectInstances($parent_element->getObject()->getId());

						if(sizeof($object_instances) > 1) {
							foreach($object_instances as $symlink_element_id) {
								if($symlink_element_id == $rel_id) continue;
								$this->symlinks[] = array($element_id, $symlink_element_id);
							}
						}
					}
				}
				$this->misc_elements[] = $element_id;

				$this->buildRelationNewNodes($element_id);
				return $element_id;
			} else {
				throw new coreException("Failed to create new object for hierarchy element");
				return false;
			}
		}


		/**
			* Получить идентификатор страницы со статусом "по умолчан0ию" (главная страница) для указанного домена и языка
			* @param Integer $lang_id = false id языковой версии, если не указан, берется текущий язык
			* @param Integer $domain_id = false id домена, если не указан, берется текущий домен
			* @return Integer id страницы по умолчанию, либо false
		*/

		public function getDefaultElementId($lang_id = false, $domain_id = false) {
			$cacheFrontend = cacheFrontend::getInstance();
			$cmsController = cmsController::getInstance();

			if(empty($this->defaultCache)) {
				$cacheData = $cacheFrontend->loadData('default_pages');
				if(is_array($cacheData)) {
					$this->defaultCache = $cacheData;
				}
			}

			if($lang_id === false) $lang_id = $cmsController->getCurrentLang()->getId();
			if($domain_id === false) $domain_id = $cmsController->getCurrentDomain()->getId();

			if(isset($this->defaultCache[$lang_id][$domain_id])) {
				return $this->defaultCache[$lang_id][$domain_id];
			}

			$sql = "SELECT id FROM cms3_hierarchy WHERE is_default = '1' AND is_deleted='0' AND is_active='1' AND lang_id = '{$lang_id}' AND domain_id = '{$domain_id}'";
			$result = l_mysql_query($sql);

			if(list($element_id) = mysql_fetch_row($result)) {
				$this->defaultCache[$lang_id][$domain_id] = $element_id;

				$cacheFrontend->saveData('default_pages', $this->defaultCache, 3600);

				return $this->defaultCache[$lang_id][$domain_id];
			} else {
				return false;
			}
		}


		public static function compareStrings($str1, $str2) {
			return	100 * (
				similar_text($str1, $str2) / (
					(strlen($str1) + strlen($str2))
				/ 2)
			);
		}

		/**
			* Конвертирует псевдостатический адрес в транслит и убирает недопостимые символы
			* @param String $alt_name псевдостатический url
			* @return String результат транслитерации
		*/
		public static function convertAltName($alt_name, $separator = false) {
			$config = mainConfiguration::getInstance();
			if (!$separator) $separator = $config->get('seo', 'alt-name-separator') ? $config->get('seo', 'alt-name-separator') : "_";
			$alt_name = translit::convert($alt_name, $separator);
			$alt_name = preg_replace("/[\?\\\\&=]+/", "_", $alt_name);
			$alt_name = preg_replace("/[_\/]+/", "_", $alt_name);
			return $alt_name;
		}

		/**
			* Получить текущий UNIX TIMESTAMP
			* @return Integer текущий unix timestamp
		*/
		public static function getTimeStamp() {
			return time();
		}


		/**
			* Переместить страницу $element_id в страницу $rel_id перед страницей $before_id
			* @param Integer $element_id id перемещаемой страницы
			* @param Integer $rel_id id новой родительской страницы
			* @param Integer $before_id = false id страницы, перед которой нужно разместить страницу $element_id. Если false, поместить страницу в конец списка
			* @return Boolean true, если успешно
		*/
		public function moveBefore($element_id, $rel_id, $before_id = false) {
			$this->disableCache();

			if(!$this->isExists($element_id)) return false;

			$element = umiHierarchy::getInstance()->getElement($element_id);

			$lang_id = $element->getLangId();
			$domain_id = $element->getDomainId();
			$oldElementParentId = $element->getRel();

			$element_id = (int) $element_id;
			$rel_id = (int) $rel_id;

			$element->setRel($rel_id);
			$element->commit();

			// apply default template if need for all descendants
			$iCurrTplId = $element->getTplId();
			$arrTpls = templatesCollection::getInstance()->getTemplatesList($domain_id, $lang_id);
			$bNeedChangeTpl = true;
			foreach($arrTpls as $oTpl) {
				if ($oTpl->getId() == $iCurrTplId) {
					$bNeedChangeTpl = false;
					break;
				}
			}

			if ($bNeedChangeTpl) {
				$oDefaultTpl = templatesCollection::getInstance()->getDefaultTemplate($domain_id, $lang_id);
				if ($oDefaultTpl) {
					$iDefaultTplId = $oDefaultTpl->getId();

					// get all descendants id's
					$oSel = new umiSelection;
					$oSel->addHierarchyFilter($element_id, 100);

					$arrDescendantsIds = umiSelectionsParser::runSelection($oSel);
					$arrDescendantsIds[] = $element_id;
					$sDIds = implode(",", $arrDescendantsIds);

					$sql = "UPDATE cms3_hierarchy SET tpl_id = '{$iDefaultTplId}' WHERE id IN (".$sDIds.")";
				}
			}

			if($before_id) {
				$before_id = (int) $before_id;

				$sql = "SELECT ord FROM cms3_hierarchy WHERE id = '{$before_id}'";
				$result = l_mysql_query($sql, true);

				if(list($ord) = mysql_fetch_row($result)) {
					$ord = (int) $ord;
					$sql = "UPDATE cms3_hierarchy SET ord = (ord + 1) WHERE rel = '{$rel_id}' AND lang_id = '{$lang_id}' AND domain_id = '{$domain_id}' AND ord >= {$ord}";
					l_mysql_query($sql);

					$sql = "UPDATE cms3_hierarchy SET ord = '{$ord}', rel = '{$rel_id}' WHERE id = '{$element_id}'";
					l_mysql_query($sql);

					$this->rewriteElementAltName($element_id);
					$this->rebuildRelationNodes($element_id);

					$this->addUpdatedElementId($element_id);

					return true;
				} else return false;
			} else {
				$sql = "SELECT MAX(ord) FROM cms3_hierarchy WHERE rel = '{$rel_id}' AND lang_id = '{$lang_id}' AND domain_id = '{$domain_id}'";
				$result = l_mysql_query($sql);

				if(list($ord) = mysql_fetch_row($result)) {
					++$ord;
				} else {
					$ord = 1;
				}

				$sql = "UPDATE cms3_hierarchy SET ord = '{$ord}', rel = '{$rel_id}' WHERE id = '{$element_id}'";
				l_mysql_query($sql);

				$this->rewriteElementAltName($element_id);
				$this->rebuildRelationNodes($element_id);

				$this->addUpdatedElementId($element_id);

				return true;
			}

		}


		/**
			* Переместить страницу $element_id под страницу с $rel_id в начало списка детей
			* @param Integer $element_id id перемещаемой страницы
			* @param Integer $rel_id id новой родительской страницы
			* @return Boolean true в случае успеха
		*/
		public function moveFirst($element_id, $rel_id) {
			$this->disableCache();

			$element_id = (int) $element_id;
			$rel_id = (int) $rel_id;

			$sql = "SELECT id FROM cms3_hierarchy WHERE rel = '{$rel_id}' ORDER BY ord ASC";
			$result = l_mysql_query($sql, true);

			list($before_id) = mysql_fetch_row($result);
			return $this->moveBefore($element_id, $rel_id, $before_id);
		}

		/**
			* Проверить, есть ли права на чтение страницы $elementId для текущего пользователя
			* @param Integer $element_id id страницы, которую нужно проверить
			* @return Boolean true если есть доступ на чтение, false если доступа нету
		*/
		protected function isAllowed($elementId) {
			$permissions = permissionsCollection::getInstance();
			list($r) = $permissions->isAllowedObject($permissions->getUserId(), $elementId);
			return $r;
		}

		/**
			* Определить id типа данных, которому принадлежат больше всего страниц под $element_id
			* @param Integer $element_id id страницы
			* @param Integer $hierarchy_type_id = null
			* @return Integer id типа данных (класс umiObjectType)
		*/
		public function getDominantTypeId($element_id, $depth = 1, $hierarchy_type_id = null) {
			if($this->isExists($element_id) || $element_id === 0) {
				$lang_id = cmsController::getInstance()->getCurrentLang()->getId();
				$domain_id = cmsController::getInstance()->getCurrentDomain()->getId();

				$element_id = (int) $element_id;
				$depth      = (int) $depth;

				if($hierarchy_type_id) {
					$htype_cond = " AND h.type_id = '" . ((int) $hierarchy_type_id) . "'";
				} else {
					$htype_cond = '';
				}

				if($depth > 1) {
					$sql = <<<SQL
SELECT o.type_id, COUNT(*) AS c
	FROM cms3_hierarchy h, cms3_objects o, cms3_hierarchy_relations hr
		WHERE hr.rel_id = '{$element_id}' AND h.id=hr.child_id AND h.is_deleted = '0' AND o.id = h.obj_id AND h.lang_id = '{$lang_id}' AND h.domain_id = '{$domain_id}'
			{$htype_cond}
			GROUP BY o.type_id
				ORDER BY c DESC
					LIMIT 1
SQL;
				} else {
					$sql = <<<SQL
SELECT o.type_id, COUNT(*) AS c
	FROM cms3_hierarchy h, cms3_objects o
		WHERE h.rel = '{$element_id}' AND h.is_deleted = '0' AND o.id = h.obj_id AND h.lang_id = '{$lang_id}' AND h.domain_id = '{$domain_id}'
		{$htype_cond}
			GROUP BY o.type_id
				ORDER BY c DESC
					LIMIT 1
SQL;
				}

				if($type_id = (int) cacheFrontend::getInstance()->loadSql($sql)) {
					return $type_id;
				}

				$result = l_mysql_query($sql);

				if(mysql_num_rows($result)) {
					list($type_id) = mysql_fetch_row($result);
					$type_id = (int) $type_id;

					cacheFrontend::getInstance()->saveSql($sql, $type_id);

					return $type_id;
				} else {
					return NULL;
				}
			} else {
				return false;
			}
		}

		/**
			* Пометить страницу с id $element_id как измененную в рамках текущей сессии. Используется самой системой
			* @param id $element_id страницы
		*/
		public function addUpdatedElementId($element_id) {
			if(!in_array($element_id, $this->updatedElements)) {
				$this->updatedElements[] = $element_id;
			}
		}

		/**
			* Получать список страниц, измененных в рамках текущей сессии
			* @return Array массив, состоящий из id страниц
		*/
		public function getUpdatedElements() {
			return $this->updatedElements;
		}

		/**
			* Запустить очистку кеша по измененным страницам
		*/
		protected function forceCacheCleanup() {
			if(sizeof($this->updatedElements)) {
				$enabled = (bool) mainConfiguration::getInstance()->get('cache', 'static.enabled');
				if ($enabled) {
					require_once CURRENT_WORKING_DIR . '/libs/cacheControl.php';
					$staticCache = new staticCache;
					$staticCache->cleanup();
				}

				if(function_exists("deleteElementsRelatedPages")) {
					deleteElementsRelatedPages();
				}
			}
		}

		/**
			* Деструктор
		*/
		public function __destruct() {
			if(defined('SMU_PROCESS') && SMU_PROCESS) {
				return;
			}

			$this->forceCacheCleanup();

			if(sizeof($this->symlinks)) {
				foreach($this->symlinks as $i => $arr) {
					list($element_id, $symlink_id) = $arr;
					$this->copyElement($element_id, $symlink_id);
					unset($this->symlinks[$i]);
				}
				$this->symlinks = Array();
			}
		}

		/**
			* Получить список страниц, которые были запрошены в текущей сессии
			* @return Array массив, состоящий из id страниц
		*/
		public function getCollectedElements() {
			return array_merge(array_keys($this->elements), $this->misc_elements);
		}

		/**
			* Выгрузить экземпляр страницы $element_id из памяти коллекции
			* @param Integer $element_id id страницы
		*/
		public function unloadElement($element_id) {
			static $pid;

			if($pid === NULL) {
				$pid = cmsController::getInstance()->getCurrentElementId();
			}

			if($pid == $element_id) return false;

			if(array_key_exists($element_id, $this->elements)) {
				unset($this->elements[$element_id]);
			} else {
				return false;
			}
		}

		/**
			* Выгрузить все экземпляры страниц из памяти коллекции
		*/
		public function unloadAllElements() {
			static $pid;
			if($pid === NULL) {
				$pid = cmsController::getInstance()->getCurrentElementId();
			}
			foreach($this->elements as $element_id=>$v) {
				if($pid == $element_id) {
					continue;
				}
				unset($this->elements[$element_id]);
			}
		}

		/**
			* Deprecated: устаревший метод
		*/
		public function getElementsCount($module, $method = "") {
			$hierarchy_type_id = umiHierarchyTypesCollection::getInstance()->getTypeByName($module, $method)->getId();

			$sql = "SELECT COUNT(*) FROM cms3_hierarchy WHERE type_id = '{$hierarchy_type_id}'";
			$result = l_mysql_query($sql);

			if(list($count) = mysql_fetch_row($result)) {
				return $count;
			} else {
				return false;
			}
		}

		/**
			* Добавить время последней модификации страницы максимальное для текущей сессии
			* @param Integer $update_time=0 время в формате UNIX TIMESTAMP
		*/
		private function pushElementsLastUpdateTime($update_time = 0) {
			if($update_time > $this->elementsLastUpdateTime) {
				$this->elementsLastUpdateTime = $update_time;
			}
		}

		/**
			* Получить максимальное значениея атрибута "дата последней модификации" для всех страниц, загруженных в текущей сессии
			* @return Integer дата в формате UNIX TIMESTAMP
		*/
		public function getElementsLastUpdateTime() {
			return $this->elementsLastUpdateTime;
		}

		/**
			* Получить все страницы, использующие объект (класс umiObject) в качестве источника данных
			* @param Integer $object_id id объекта
			* @param Boolean $bIgnoreDomain искать независимо от домена
			* @param Boolean $bIgnoreLang искать независимо от языковой версии
			* @param Boolean $bIgnoreDeleted игнорировать страницы в корзине
			* @return Array массив, состоящий из id страниц
		*/
		public function getObjectInstances($object_id, $bIgnoreDomain = false, $bIgnoreLang = false, $bIgnoreDeleted = false) {
			$object_id = (int) $object_id;

			$sql = "SELECT id FROM cms3_hierarchy WHERE obj_id = '{$object_id}'";
			if(!$bIgnoreDomain) {
				$domain_id = cmsController::getInstance()->getCurrentDomain()->getId();
				$sql .= " AND domain_id = '{$domain_id}'";
			}
			if(!$bIgnoreLang) {
				$lang_id = cmsController::getInstance()->getCurrentLang()->getId();
				$sql .= " AND lang_id = '{$lang_id}'";
			}
			if($bIgnoreDeleted) {
				$sql .= " AND is_deleted = 0";
			}
			$result = l_mysql_query($sql);

			$res = array();
			while(list($element_id) = mysql_fetch_row($result)) {
				$res[] = $element_id;
			}

			return $res;
		}

		/**
			* Определить id шаблона, который выставлен у большинства страниц под $element_id
			* @param Integer $elementId id страницы
			* @return Integer id шаблона дизайна (класс template)
		*/
		public function getDominantTplId($elementId) {
			$elementId = (int) $elementId;

			$sql = "SELECT `tpl_id`, COUNT(*) AS `cnt` FROM cms3_hierarchy WHERE rel = '{$elementId}' AND is_deleted = '0' GROUP BY tpl_id ORDER BY `cnt` DESC";
			$result = l_mysql_query($sql);
			if($row = mysql_fetch_row($result)) {
				list($tpl_id) = $row;
				return $tpl_id;
			} else {
				$element = $this->getElement($elementId);
				if($element instanceof umiHierarchyElement) {
					return $element->getTplId();
				}
			}
		}

		/**
			* Получить список страниц, измененных с даты $timestamp
			* @param Integer $limit ограничение на количество результатов
			* @param Integer $timestamp=0 дата в формате UNIX TIMESTAMP
			* @return Array массив, состоящий из id страниц
		*/
		public function getLastUpdatedElements($limit, $timestamp = 0) {
			$limit = (int) $limit;
			$timestamp = (int) $timestamp;

			$sql = "SELECT id FROM cms3_hierarchy WHERE updatetime >= {$timestamp} LIMIT {$limit}";
			$result = l_mysql_query($sql);

			$res = Array();
			while(list($id) = mysql_fetch_row($result)) {
				$res[] = $id;
			}
			return $res;
		}

		/**
			* Проверить список страниц на предмет того, имеют ли они виртуальные копии
			* @param Integer $arr массив, где ключ это id страницы, а значение равно false(!)
			* @return Array преобразует параметр $arr таким образом, что false поменяется на количество виртуальных копий там, где они есть
		*/
		public function checkIsVirtual($arr) {
			if(sizeof($arr) == 0) return $arr;

			foreach($arr as $element_id => $nl) {
				$element = $this->getElement($element_id);
				$arr[$element_id] = (string) $element->getObjectId();
			}

			$sql = "SELECT obj_id, COUNT(*) FROM cms3_hierarchy WHERE obj_id IN (" . implode(", ", $arr) . ") AND is_deleted = '0' GROUP BY obj_id";
			$result = l_mysql_query($sql);

			while(list($obj_id, $c) = mysql_fetch_row($result)) {
				$is_virtual = ($c > 1) ? true : false;

				foreach($arr as $i => $v) {
					if($v === $obj_id) {
						$arr[$i] = $is_virtual;
					}
				}
			}

			return $arr;
		}

		/**
			* Перепроверить псевдостатичесик URL страницы $element_id на предмет коллизий
			* @param Integer $element_id id страницы
			* @return false если страница $element_id не доступна
		*/
		protected function rewriteElementAltName($element_id) {
			$element = $this->getElement($element_id, true, true);
			if($element instanceof iUmiHierarchyElement) {
				$element->setAltName($element->getAltName());
				$element->commit();

				return true;
			} else {
				return false;
			}
		}


		//Write here methods to rebuild cms3_hierarchy_relations subnodes

		/**
			* Стереть все записи, связанные со страницой $element_id из таблицы cms3_hierarchy_relations
			* @param Integer $element_id id страницы
		*/
		protected function earseRelationNodes($element_id) {
			$element_id = (int) $element_id;

			$sql = "DELETE FROM cms3_hierarchy_relations WHERE rel_id = '{$element_id}' OR child_id = '{$element_id}'";
			l_mysql_query($sql);
		}

		/**
			* Перестроить дерево зависимостей для узла $element_id
		*/
		public function rebuildRelationNodes($elementId) {		//TODO: public - временно. должен быть protected
			$elementId = (int) $elementId;

			//Earse all hierarchy relations
			$this->earseRelationNodes($elementId);

			//Put new relations data for this single element as for a new one
			$this->buildRelationNewNodes($elementId);

			//Get all childs and apply this methods to 'em
			$sql = "SELECT id FROM cms3_hierarchy WHERE rel = '{$elementId}'";
			$result = l_mysql_query($sql);

			while(list($childElementId) = mysql_fetch_row($result)) {
				$this->rebuildRelationNodes($childElementId);
			}
		}


		/**
			* Построить дерево зависимостей для $element_id относительно родителей
			* @param $element_id id страницы
		*/
		public function buildRelationNewNodes($element_id) {		//TODO: public - временно. должен быть protected
			$element_id = (int) $element_id;
			$this->earseRelationNodes($element_id);

			$sql = "SELECT rel FROM cms3_hierarchy WHERE id = '{$element_id}'";
			$result = l_mysql_query($sql, true);

			if(mysql_num_rows($result)) {
				list($parent_id) = mysql_fetch_row($result);
				$parent_id_cond = ($parent_id > 0) ? " = '{$parent_id}'" : " IS NULL";

				$sql = <<<SQL
INSERT INTO cms3_hierarchy_relations (rel_id, child_id, level)
SELECT rel_id, '{$element_id}', (level + 1) FROM cms3_hierarchy_relations WHERE child_id {$parent_id_cond}
SQL;
				l_mysql_query($sql);
				$parents = $this->getAllParents($parent_id, true, true);

				$parents = array_extract_values($parents);
				$level = sizeof($parents);


				$parent_id_val = ($parent_id > 0) ? "'{$parent_id}'" : "NULL";

				$sql = <<<SQL
INSERT INTO cms3_hierarchy_relations (rel_id, child_id, level)
VALUES ({$parent_id_val}, '{$element_id}', '{$level}')
SQL;
				l_mysql_query($sql);
				return true;
			} else return false;
		}

		/**
			* Является ли указанная страница родителем для $hierarchy
			* @param umiHierarchyElement $hierarchy
			* @param umiHierarchyElement $hierarchy_parent
			* @return Boolean true если hierarchy_parent родитель для hierarchy
		*/
		public function hasParent($hierarchy, $hierarchy_parent) {
			if( ! $hierarchy ) return false;


			if(is_numeric($hierarchy)) {
				$hierarchy = umiHierarchy::getInstance()->getElement ($hierarchy);
			}

			if(is_numeric($hierarchy_parent)) {
				$hierarchy_parent = umiHierarchy::getInstance()->getElement ($hierarchy_parent);
			}

			if( ! $hierarchy instanceof umiHierarchyElement) return false;
			if( ! $hierarchy_parent instanceof umiHierarchyElement) return false;



			if($hierarchy->getRel() == $hierarchy_parent->getId()) {
				return true;
			}

			return $this->hasParent( $hierarchy->getRel(), $hierarchy_parent);
		}

		public function clearCache() {
			$keys = array_keys($this->elements);
			foreach($keys as $key) unset($this->elements[$key]);
			$this->elements = array();
			$this->symlinks = array();
			$this->misc_elements = array();
			$this->pathCache = array();
			$this->pathPiecesCache = array();
			$this->defaultCache = array();
			$this->parentsCache = array();
			$this->idByPathCache = array();
		}

		/**
		 * Чистит внутренний кэш для дефолтных страниц
		 */
		public function clearDefaultElementCache() {
			$this->defaultCache = array();
		}

		public function getRightAltName($alt_name, $element, $b_fill_cavities = false, $ignore_cur_element = false) {

			if (empty($alt_name)) $alt_name = '1';

			if ($element->getRel() == 0 && !IGNORE_MODULE_NAMES_OVERWRITE) {
				// если элемент непосредственно под корнем и снята галка в настройках -
				// корректировать совпадение с именами модулей и языков
				$modules_keys = regedit::getInstance()->getList("//modules");
				foreach($modules_keys as $module_name) {
					if ($alt_name == $module_name[0]) {
							$alt_name .= '1';
							break;
					}
				}
				if (langsCollection::getInstance()->getLangId($alt_name)) {
					$alt_name .= '1';
				}
			}

			$exists_alt_names =  array();

			preg_match("/^([a-z0-9_.-]*)(\d*?)$/U", $alt_name, $regs);
			$alt_digit = isset($regs[2]) ? $regs[2] : NULL;
			$alt_string = isset($regs[1]) ? $regs[1] : NULL;

			$lang_id = $element->getLangId();
			$domain_id = $element->getDomainId();

			if($ignore_cur_element) {
				$sql = "SELECT alt_name FROM cms3_hierarchy WHERE rel={$element->getRel()}  AND is_deleted = '0' AND lang_id = '{$lang_id}' AND domain_id = '{$domain_id}' AND alt_name LIKE '{$alt_string}%';";
			}
			else {
				$sql = "SELECT alt_name FROM cms3_hierarchy WHERE rel={$element->getRel()} AND id <> {$element->getId()} AND is_deleted = '0' AND lang_id = '{$lang_id}' AND domain_id = '{$domain_id}' AND alt_name LIKE '{$alt_string}%';";
			}

			$result = l_mysql_query($sql);

			while(list($item) = mysql_fetch_row($result)) $exists_alt_names[] = $item;

			if (!empty($exists_alt_names) and in_array($alt_name,$exists_alt_names)){ //print_R($exists_alt_names);
				foreach($exists_alt_names as $next_alt_name){
					preg_match("/^([a-z0-9_.-]*)(\d*?)$/U", $next_alt_name, $regs);
					if (!empty($regs[2])) $alt_digit = max($alt_digit,$regs[2]);
				}
				++$alt_digit;
				//
				if ($b_fill_cavities) {
					$j = 0;
					for ($j = 1; $j<$alt_digit; $j++) {
						if (!in_array($alt_string . $j, $exists_alt_names)) {
							$alt_digit = $j;
							break;
						}
					}
				}
			}
			return $alt_string . $alt_digit;
		}

	};


	interface iUmiSelection {
		public function forceHierarchyTable($isForced = true);

		public function addObjectType($objectTypeId);
		public function addElementType($elementTypeId);

		public function addLimit($resultsPerQueryPage, $resultsPage = 0);

		public function setOrderByProperty($fieldId, $asc = true);
		public function setOrderByOrd();
		public function setOrderByRand();
		public function setOrderByName($asc = true);
		public function setOrderByObjectId($asc = true);

		public function addHierarchyFilter($elementId, $depth = 0, $ignoreIsDefault = false);

		public function addPropertyFilterBetween($fieldId, $minValue, $maxValue);
		public function addPropertyFilterEqual($fieldId, $exactValue, $caseInsencetive = true);
		public function addPropertyFilterNotEqual($fieldId, $exactValue, $caseInsencetive = true);
		public function addPropertyFilterLike($fieldId, $likeValue, $caseInsencetive = true);
		public function addPropertyFilterMore($fieldId, $val);
		public function addPropertyFilterLess($fieldId, $val);
		public function addPropertyFilterIsNull($fieldId);
		public function addActiveFilter($active);
		public function addOwnerFilter($owner);
		public function addObjectsFilter($vOids);
		public function addElementsFilter($vEids);

		public function addNameFilterEquals($exactValue);
		public function addNameFilterLike($likeValue);

		public function addPermissions($userId = false);
		public function setPermissionsLevel($level = 1);
		
		public function setDomainId($domainId = false);
		public function setLangId($langId = false);

		public function setConditionModeOR();
		
		public function setIsDomainIgnored($isDomainIgnored = false);
		public function setIsLangIgnored($isLangIgnored = false);
		
		public function resetTextSearch();
		
		public function result();
		public function count();
	}


/**
	* Класс, который предоставляет средства для создания шаблонов выборок данных из базы данных.
*/
	class umiSelection implements iUmiSelection {
		private	$order = Array(),
			$limit = Array(),
			$object_type = Array(),
			$element_type = Array(),
			$props = Array(),
			$hierarchy = Array(),
			$perms = Array(),
			$names = Array(),
			$active = Array(),
			$owner = Array(),
			$objects_ids = Array(),
			$elements_ids = Array(),

			$is_order = false,  $is_limit = false, $is_object_type = false, $is_element_type = false, $is_props = false, $is_hierarchy = false, $is_permissions = false, $is_forced = false, $is_names = false, $is_active = false,
			$condition_mode_or = false, $is_owner = false,
			$is_objects_ids = false, $is_elements_ids = false,
			$is_domain_ignored = false, $isDomainIgnored = false, $isLangIgnored = false, $langId = false, $domainId = false,
			$permissionsLevel = 1,
			$searchStrings = Array();
			
		public	$result = false, $count = false, $switchIllegalBetween = true;

		// ========

		public $optimize_root_search_query = false;
		public $sql_part__hierarchy = "";
		public $sql_part__element_type = "";
		public $sql_part__owner = "";
		public $sql_part__objects = "";
		public $sql_part__elements = "";
		public $sql_part__perms = "";
		public $sql_part__perms_tables = "";
		public $sql_part__content_tables = "";
		public $sql_part__object_type = "";
		public $sql_part__props_and_names = "";
		public $sql_part__lang_cond = "";
		public $sql_part__domain_cond = "";
		public $sql_part__unactive_cond = "";

		public $sql_cond__total_joins = 0;
		public $sql_cond__content_tables_loaded = 0;
		public $sql_cond__need_content = false;
		public $sql_cond__need_hierarchy = false;
		public $sql_cond__domain_ignored = false;
		public $sql_cond_auto_domain = false;

		public $sql_arr_for_mark_used_fields = array();
		public $sql_arr_for_and_or_part = array();

		// ==

		public $sql_kwd_distinct = "";
		public $sql_kwd_distinct_count = "";
		public $sql_kwd_straight_join = "";

		public $sql_select_expr = "";
		public $sql_table_references = "";
		public $sql_where_condition_required = "";
		public $sql_where_condition_common = "";
		public $sql_where_condition_additional = "";

		public $sql_order_by = "";
		public $sql_limit = "";
		
		public $objectTableIsRequired = false;
		public $excludeNestedPages = false;
		
		public $usedContentTables = Array();

		// ========

		public function result() { return umiSelectionsParser::runSelection($this); }
		public function count() { return umiSelectionsParser::runSelectionCounts($this); }


		/**
		* @deprecated
		* @desc Включает/выключает фильтрацию по типу объектов
		* @param Boolean $is_enabled Разрешить фильтрацию (true) или запретить (false)
		*/
		public function setObjectTypeFilter($is_enabled = true) {
			$this->is_object_type = (bool) $is_enabled;
			if (!$is_enabled) $this->object_type = Array();
		}

		/**
		* @deprecated
		* @desc Включает/выключает фильтрацию по типу елементов иерархии
		* @param Boolean $is_enabled Разрешить фильтрацию (true) или запретить (false)
		*/
		public function setElementTypeFilter($is_enabled = true) {
			$this->is_element_type = (bool) $is_enabled;
			if (!$is_enabled) $this->element_type = Array();
		}

		/**
		* @deprecated
		* @desc Включает/выключает фильтрацию по свойствам объектов
		* @param Boolean $is_enabled Разрешить фильтрацию (true) или запретить (false)
		*/
		public function setPropertyFilter($is_enabled = true) {
			$this->is_props = (bool) $is_enabled;
			if (!$is_enabled) $this->props = Array();
		}

		/**
		* @deprecated
		* @desc Включает/выключает ограничение по количество элементов
		* @param Boolean $is_enabled Разрешить ограничение (true) или запретить (false)
		*/
		public function setLimitFilter($is_enabled = true) {
			$this->is_limit = (bool) $is_enabled;
			if (!$is_enabled) $this->limit = Array();
		}

		/**
		* @deprecated
		* @desc Включает/выключает фильтрацию по id элементов иерархии
		* @param Boolean $is_enabled  Разрешить фильтрацию (true) или запретить (false) 
		*/
		public function setHierarchyFilter($is_enabled = true) {
			$this->is_hierarchy = (bool) $is_enabled;
			if (!$is_enabled) $this->hierarchy = Array();
		}

		/**
		* @deprecated
		* @desc Включает/выключает сортировку
		* @param Boolean $is_enabled Разрешить сортировку (true) или запретить (false)
		*/
		public function setOrderFilter($is_enabled = true) {
			$this->is_order = (bool) $is_enabled;
			if (!$is_enabled) $this->order = Array();
		}

		/**
		* @deprecated
		* @desc Включает/выключает фильтрацию по правам
		* @param $is_enabled Разрешить фильтрацию (true) или запретить (false)
		*/ 
		public function setPermissionsFilter($is_enabled = true) {
			

			$this->is_permissions = $is_enabled;

			$user_id = $this->getCurrentUserId();
			if(cmsController::getInstance()->getModule("users")->isSv($user_id)) {
				$this->is_permissions = false;
			}
			if (!$is_enabled) $this->perms = Array();
		}

		/**
		* @deprecated
		* @desc Включает/выключает фильтрацию по активности элемента
		* @param $is_enabled Разрешить фильтрацию (true) или запретить (false)
		*/
		public function setActiveFilter($is_enabled = true) {
			$this->is_active = (bool) $is_enabled;
			if (!$is_enabled) $this->is_active = Array();
		}

		/**
		* @deprecated
		* @desc Включает/выключает фильтрацию по владельцу
		* @param $is_enabled Разрешить фильтрацию (true) или запретить (false)
		*/
		public function setOwnerFilter($is_enabled = true) {
			$this->is_owner = (bool) $is_enabled;
			if (!$is_enabled) $this->is_owner = Array();
		}

		/**
		* @deprecated
		* @desc Включает/выключает фильтрацию по id объектов
		* @param $is_enabled Разрешить фильтрацию (true) или запретить (false)
		*/
		public function setObjectsFilter($is_enabled = true) {
			$this->is_objects_ids = (bool) $is_enabled;
			if (!$is_enabled) $this->is_objects_ids = Array();
		}
		
		/**
		* @deprecated
		* @desc 
		*/
		public function setElementsFilter($is_enabled = true) {
			$this->is_elements_ids = (bool) $is_enabled;
			if (!$is_enabled) $this->is_elements_ids = Array();
		}

		/**
		* @deprecated
		* @desc Включает/выключает фильтрацию по имени объекта
		* @param $is_enabled Разрешить фильтрацию (true) или запретить (false)
		*/
		public function setNamesFilter($is_enabled = true) {
			$this->is_names = (bool) $is_enabled;
			if (!$is_enabled) $this->names = Array();
		}

		public function forceHierarchyTable($isForced = true) {
			$this->is_forced = (bool) $isForced;
		}

		/**
		* @desc Добавляет тип объекта к критерию фильтрации
		* @param Int $object_type Id типа объекта
		*/
		public function addObjectType($object_type_id) {
			$this->setObjectTypeFilter();

			if(is_array($object_type_id)) {
				foreach($object_type_id as $sub_object_type_id) {
					if(!$this->addObjectType($sub_object_type_id)) {
						return false;
					}
				}
				return true;
			}

			if(umiObjectTypesCollection::getInstance()->isExists($object_type_id)) {
				if(in_array($object_type_id, $this->object_type) === false) {
					$this->object_type[] = $object_type_id;
					return true;
				} else {
					return false;
				}
			} else {
				return false;
			}
		}

		/**
		* @desc Добавляет тип элемента к критерию фильтрации
		* @param Int $object_type Id типа элемента
		*/
		public function addElementType($element_type_id) {
			/*
			Не принимает массив !!! вызывайте несколько раз (TODO: переписать)
			*/
			$this->setElementTypeFilter();
		
			if(umiHierarchyTypesCollection::getInstance()->isExists($element_type_id)) {
				if(in_array($element_type_id, $this->element_type) === false) {
					$this->element_type[] = $element_type_id;
					return true;
				} else {
					return false;
				}
			} else {
				return false;
			}
		}

		/**
		* @desc Устанавливает количественные ограничения на выборку
		* @param Int $per_page	Количество объектов на странице
		* @param Int $page 		Номер выбираемой страницы
		*/
		public function addLimit($per_page, $page = 0) {
			$this->setLimitFilter();
		
			$per_page = (int) $per_page;
			$page = (int) $page;

			if($page < 0) {
				$page = 0;
			}
			
			$this->limit = Array($per_page, $page);
		}

		/**
		* @desc Устанавливает признак активности елемента
		* @param Boolean $active True - выбрать активные алементы, False - выбрать неактивные элементы
		*/
		public function addActiveFilter($active) {
			$this->setActiveFilter();
			$this->active = Array($active);
		}

		/**
		* @desc Устанавливает владельцев объекта/элемента
		* @param Array $vOwners Возможные id владельцев
		*/
		public function addOwnerFilter($vOwners) {
			$this->setOwnerFilter();
			$this->owner = $this->toIntsArray($vOwners);
		}

		/**
		* @desc Устанавливает возможные id объектов
		* @param Array $vOids возможные id объектов
		*/
		public function addObjectsFilter($vOids) {
			$this->setObjectsFilter();
			$this->objects_ids = $this->toIntsArray($vOids);
		}

		/**
		* @desc Устанавливает возможные id елементов иерархии
		* @param Array $vOids возможные id елементов иерархии
		*/
		public function addElementsFilter($vEids) {
			$this->setElementsFilter();
			$this->elements_ids = $this->toIntsArray($vEids);
		}

		/**
		* @desc Устанавливает поле и вид сортировки
		* @param Int 		$field_id 	id поля, по которому будет произведена сортировка
		* @param Boolean 	$asc 		порядок сортировки: true - прямой, false - обратный
		*/
		public function setOrderByProperty($field_id, $asc = true) {
			if(!$field_id) return false;
			$this->setOrderFilter();
		
			$data_type = $this->getDataByFieldId($field_id);

			$filter = Array("field_id" => $field_id, "asc" => $asc, "type" => $data_type, "native_field" => false);

			if(in_array($filter, $this->order) === false) {
				$this->order[] = $filter;
				return true;
			} else {
				return false;
			}
		}

		/**
		* @desc Устанавливает сортировку по расположению в иерархии
		* @param Boolean $asc порядок сортировки: true - прямой, false - обратный
		*/
		public function setOrderByOrd($asc = true) {
			$this->setOrderFilter();

			$filter = Array("type" => "native", "native_field" => "ord", "asc" => $asc);

			if(in_array($filter, $this->order) === false) {
				$this->order[] = $filter;
				return true;
			} else {
				return false;
			}
		}
		
		/**
		* @desc Устанавливает выборку случайных ID
		*/
		public function setOrderByRand() {
			$this->setOrderFilter();
		
			$filter = Array("type" => "native", "native_field" => "rand", "asc" => true);

			if(in_array($filter, $this->order) === false) {
				$this->order[] = $filter;
				return true;
			} else {
				return false;
			}
		}

		/**
		* @desc Устанавливает сортировку по имени
		* @param Boolean $asc порядок сортировки: true - прямой, false - обратный
		*/
		public function setOrderByName($asc = true) {
			$this->setOrderFilter();
		
			$filter = Array("type" => "native", "native_field" => "name", "asc" => $asc);

			if(in_array($filter, $this->order) === false) {
				$this->order[] = $filter;
				return true;
			} else {
				return false;
			}
		}
		
		/**
		* @desc Устанавливает сортировку по id объекта
		* @param Boolean $asc порядок сортировки: true - прямой, false - обратный
		*/
		public function setOrderByObjectId($asc = true) {
			$this->setOrderFilter();

			$filter = Array("type" => "native", "native_field" => "object_id", "asc" => $asc);
			
			if(in_array($filter, $this->order) === false) {
				$this->order[] = $filter;
				return true;
			} else {
				return false;
			}
		}

        /**
        * @desc Устанавливает параметры выбора элементов иерархии
        * @param Int 	 	$element_id 		Id корня выборки
        * @param Int 	 	$depth				Глубина выборки элементов от корня
        * @param Boolean	$ignoreIsDefault	игнорировать элемент по-умолчанию
        */
		public function addHierarchyFilter($element_id, $depth = 0, $ignoreIsDefault = true) {
			$this->setHierarchyFilter();
			
			if(is_array($element_id)) {
				foreach($element_id as $id) {
					$this->addHierarchyFilter($id, $depth);
				}
				return;
			}

			if(umiHierarchy::getInstance()->isExists($element_id) || (is_numeric($element_id) && $element_id == 0)) {
				if($element_id == umiHierarchy::getInstance()->getDefaultElementId() && $ignoreIsDefault == false) {
					$element_id = Array(0, 0);
				}
			
				if(in_array($element_id, $this->hierarchy) === false || $element_id == 0) {
					$this->hierarchy[] = Array((int) $element_id, $depth);
				}

				if($depth > 0) {
					$this->hierarchy[] = Array($element_id, $depth);
				}
			} else {
				return false;
			}
		}

        /**
        * @desc Устанавливает проверку попадания значения поля в интервал
        * @param Int 	$field_id 	Id поля
        * @param Mixed 	$min 		Минимальное значение
        * @param Mixed	$max		Максимальное значение
        */
		public function addPropertyFilterBetween($field_id, $min, $max) {
			if(!$field_id) return false;
			$this->setPropertyFilter();
			
			$data_type = $this->getDataByFieldId($field_id);
			
			if($this->switchIllegalBetween && $min > $max) {
				$tmp = $min;
				$min = $max;
				$max = $tmp;
				unset($tmp);
			}

			$filter = Array("type" => $data_type, "field_id" => $field_id, "filter_type" => "between", "min" => $min, "max" => $max);
			$this->props[] = $filter;
		}

		/**
		* @desc Устанавливает проверку значения поля на равенство
		* @param Int		$field_id			Id поля
		* @param Mixed		$value				Значение для сравнения
		* @param Boolean 	$case_insencetive   True - не учитывать регистр, false - учитывать регистр
		*/
		public function addPropertyFilterEqual($field_id, $value, $case_insencetive = true) {
			if(!$field_id || !sizeof($value)) return false;
			$this->setPropertyFilter();
		
			$data_type = $this->getDataByFieldId($field_id);

			$filter = Array("type" => $data_type, "field_id" => $field_id, "filter_type" => "equal", "value" => $value, "case_insencetive" => $case_insencetive);
			$this->props[] = $filter;
		}

		/**
		* @desc Устанавливает проверку значения поля на неравенство
		* @param Int		$field_id			Id поля
		* @param Mixed		$value				Значение для сравнения
		* @param Boolean 	$case_insencetive   True - не учитывать регистр, false - учитывать регистр 
		*/
		public function addPropertyFilterNotEqual($field_id, $value, $case_insencetive = true) {
			if(!$field_id) return false;
			$this->setPropertyFilter();
		
			$data_type = $this->getDataByFieldId($field_id);

			$filter = Array("type" => $data_type, "field_id" => $field_id, "filter_type" => "not_equal", "value" => $value, "case_insencetive" => $case_insencetive);
			$this->props[] = $filter;
		}

        /**
		* @desc Устанавливает проверку значения поля на включение поисковой строки
		* @param Int		$field_id			Id поля
		* @param Mixed		$value				Значение для поиска
		* @param Boolean 	$case_insencetive   True - не учитывать регистр, false - учитывать регистр 
		*/
		public function addPropertyFilterLike($field_id, $value, $case_insencetive = true) {
			if(!$field_id) return false;
			$this->setPropertyFilter();
		
			$data_type = $this->getDataByFieldId($field_id);

			$filter = Array("type" => $data_type, "field_id" => $field_id, "filter_type" => "like", "value" => $value, "case_insencetive" => $case_insencetive);
			$this->props[] = $filter;
		}

		/**
		* @desc Устанавливает проверку значения поля на "больше"
		* @param Int		$field_id			Id поля
		* @param Mixed		$value				Значение для сравнения		
		*/
		public function addPropertyFilterMore($field_id, $value) {
			if(!$field_id) return false;
			$this->setPropertyFilter();
		
			$data_type = $this->getDataByFieldId($field_id);

			$filter = Array("type" => $data_type, "field_id" => $field_id, "filter_type" => "more", "value" => $value);
			$this->props[] = $filter;
		}

		/**
		* @desc Устанавливает проверку значения поля на "меньше"
		* @param Int		$field_id			Id поля
		* @param Mixed		$value				Значение для сравнения		
		*/
		public function addPropertyFilterLess($field_id, $value) {
			if(!$field_id) return false;
			$this->setPropertyFilter();
		
			$data_type = $this->getDataByFieldId($field_id);

			$filter = Array("type" => $data_type, "field_id" => $field_id, "filter_type" => "less", "value" => $value);
			$this->props[] = $filter;
		}

		/**
		* @desc Устанавливает проверку значения поля на отсутствие значения
		* @param Int		$field_id			Id поля		
		*/
		public function addPropertyFilterIsNull($field_id) {
			if(!$field_id) return false;
			$this->setPropertyFilter();
		
			$data_type = $this->getDataByFieldId($field_id);

			$filter = Array("type" => $data_type, "field_id" => $field_id, "filter_type" => "null");
			$this->props[] = $filter;
		}

		/**
		* @desc Устанавливает проверку значения поля на отсутствие значения
		* @param Int		$field_id			Id поля		
		*/
		public function addPropertyFilterIsNotNull($field_id) {
			if(!$field_id) return false;
			$this->setPropertyFilter();
		
			$data_type = $this->getDataByFieldId($field_id);

			$filter = Array("type" => $data_type, "field_id" => $field_id, "filter_type" => "notnull");
			$this->props[] = $filter;
		}

        /**
        * @desc Устанавливает пользователя или группу для проверки прав на элемент
        * @param Int $user_id ID пользователя или группы
        */
		public function addPermissions($user_id = false) {
			$this->setPermissionsFilter();
		
			if($user_id === false) {
				$permissions = permissionsCollection::getInstance();
				if($permissions->isSv()) return;
				$user_id = $permissions->getUserId();
				
			}
			$owners = $this->getOwnersByUser($user_id);
			$this->perms = $owners;
		}
		
		/**
			* Устанавливает уровень прав, который должен быть у искомых страниц
		*/
		public function setPermissionsLevel($level = 1) {
			$this->permissionsLevel = (int) $level;
		}

		/**
		* @desc Устанавливает значение для проверки имени поля на равенство
		* @param Mixed $value Значение для проверки
		*/
		public function addNameFilterEquals($value) {
			$this->setNamesFilter();
		
			$value = Array("value" => $value, "type" => "exact");

			if(!in_array($value, $this->names)) {
				$this->names[] = $value;
			}
		}
		
		/**
		* @desc Устанавливает значение для поиска в имени
		* @param Mixed $value значение для поиска
		*/
		public function addNameFilterLike($value) {
			$this->setNamesFilter();
		
			$value = Array("value" => $value, "type" => "like");

			if(!in_array($value, $this->names)) {
				$this->names[] = $value;
			}
		}

		/**
		* @desc Возвращает параметры сортировки
		* @return Array | Boolean(False) 
		*/
		public function getOrderConds() {
			return ($this->is_order) ? $this->order : false;
		}

		/**
		* @desc Возвращает количественные ограничения на выборку
		* @return Array | Boolean(False) 
		*/
		public function getLimitConds() {
			return ($this->is_limit) ? $this->limit : false;
		}

		/**
		* @desc Возвращает признак активности
		* @return Boolean 
		*/
		public function getActiveConds() {
			return ($this->is_active) ? $this->active : false;
		}

		/**
		* @desc Возвращает список возможных владельцев
		* @return Array | Boolean(False) 
		*/
		public function getOwnerConds() {
			$arrAnswer = array();
			if (is_array($this->owner) && count($this->owner)) {
				$arrAnswer = array_map('intval', $this->owner);
			}
			return ($this->is_owner) ? $arrAnswer : false;
		}
		
		/**
		* @desc Возвращает список возможных id объектов
		* @return Array | Boolean(False) 
		*/
		public function getObjectsConds() {
			$arrAnswer = array();
			if (is_array($this->objects_ids) && count($this->objects_ids)) {
				$arrAnswer = array_map('intval', $this->objects_ids);
			}
			return ($this->is_objects_ids) ? $arrAnswer : false;
		}
		
		/**
		* @desc Возвращает список возможных id элементов иерархии
		* @return Array | Boolean(False) 
		*/
		public function getElementsConds() {
			$arrAnswer = array();
			if (is_array($this->elements_ids) && count($this->elements_ids)) {
				$arrAnswer = array_map('intval', $this->elements_ids);
			}
			return ($this->is_elements_ids) ? $arrAnswer : false;
		}

		/**
		* @desc Возвращает список условий на выборку по значению полей
		* @return Array | Boolean(False)
		*/
		public function getPropertyConds() {
			return ($this->is_props) ? $this->props : false;
		}

		/**
		* @desc Возвращает список возможных id типов объектов
		* @return Array | Boolean(False) 
		*/
		public function getObjectTypeConds() {
			return ($this->is_object_type) ? $this->object_type : false;
		}

		/**
		* @desc Возвращает список возможных id типов элементов иерархии
		* @return Array  | Boolean(False)
		*/
		public function getElementTypeConds() {
			if($this->getObjectTypeConds() !== false) {
				return false;
			}
			
			if($this->optimize_root_search_query) {
				if(is_array($this->element_type)) {
					if(sizeof($this->element_type) > 1) {
						reset($this->element_type);
						$this->element_type = Array(current($this->element_type));
					}
				}
			}

			return ($this->is_element_type) ? $this->element_type : false;
		}

		public function getHierarchyConds() {
			$this->hierarchy = array_unique_arrays($this->hierarchy, 0);
			return ($this->is_hierarchy && !$this->optimize_root_search_query) ? $this->hierarchy : false;
		}

		/**
		* @desc Возвращает список пользователей и/или групп с правами на элемент иерархии
		* @return Array | Boolean(False) 
		*/
		public function getPermissionsConds() {
			return ($this->is_permissions) ? $this->perms : false;
		}

		public function getForceCond() {
			return $this->is_forced;
		}

		/**
		* @desc Возвращает условия проверки имени
		* @return Array | Boolean(False)
		*/
		public function getNameConds() {
			return ($this->is_names) ? $this->names : false;
		}
		
		private function getDataByFieldId($field_id) {
			if($field = umiFieldsCollection::getInstance()->getField($field_id)) {
				$field_type_id = $field->getFieldTypeId();

				if($field_type = umiFieldTypesCollection::getInstance()->getFieldType($field_type_id)) {
					if($data_type = $field_type->getDataType()) {
						return umiFieldType::getDataTypeDB($data_type);
					} else {
						return false;
					}
				} else {
					return false;
				}
			} else {
				return false;
			}
		}

		private function getCurrentUserId() {
			if($users = cmsController::getInstance()->getModule("users")) {
				return $users->user_id;
			} else {
				return false;
			}
		}

		private function getOwnersByUser($user_id) {
			if($user = umiObjectsCollection::getInstance()->getObject($user_id)) {
				$groups = $user->getValue("groups");
				$groups[] = $user_id;
				return $groups;
			} else {
				return false;
			}
		}
		
		/**
		* @desc Устанавливает флаг "ИЛИ" группировки результатов выборки по значению полей.
		* 		Если этот флаг установлен, то выбираются объекты/элементы иерархии,
		* 		удовлетворяющие хотя бы одному условию, из указаных. В противном случае
		* 		требуется соблюдение всех указаных условий.
		*/
		public function setConditionModeOr() {
			$this->condition_mode_or = true;
		}
		
		/**
		* @desc Возвращает значение флага группировки результатов выборки по значению полей
		* @return Boolean
		*/
		public function getConditionModeOr() {
			return $this->condition_mode_or;
		}
		
		
		/**
		* @desc Устанавливает значение флага игнорирования текущего домена
		* @param Boolean $isDomainIgnored True - домен игнорируется, false - не игнорируется
		*/
		public function setIsDomainIgnored($isDomainIgnored = false) {
			$this->isDomainIgnored = (bool) $isDomainIgnored;
		}
		
		/**
		* @desc Устанавливает значение флага игнорирования текущей языковой версии
		* @param Boolean $isLangIgnored True - домен игнорируется, false - не игнорируется
		*/
		public function setIsLangIgnored($isLangIgnored = false) {
			$this->isLangIgnored = (bool) $isLangIgnored;
		}
		
		/**
		* @desc Возвращает значение  флага игнорирования текущего домена
		* @return Boolean
		*/
		public function getIsDomainIgnored() {
			return $this->isDomainIgnored;
		}

		/**
		* @desc Возвращает значение  флага игнорирования текущей языковой версии
		* @return Boolean
		*/
		public function getIsLangIgnored() {
			return $this->isLangIgnored;
		}
		
		/**
			* Искать только по указанному домену
			* @param Integer $domainId = false id домена, либо false, если поиск будет по всем доменам
		*/
		public function setDomainId($domainId = false) {
			$this->domainId = ($domainId === false) ? false : (int) $domainId;
		}
		
		/**
			* Искать только в указанной языковой версии
			* @param Integer $langId = false id языка, либо false
		*/
		public function setLangId($langId = false) {
			$this->langId = ($langId === false) ? false : (int) $langId;
		}
		
		/**
			* Поиск по строке в любом тектовом поле
			* @param String $searchString строка поиска
		*/
		public function searchText($searchString) {
			if(is_string($searchString)) {
				if(strlen($searchString) > 0 && !in_array($searchString, $this->searchStrings)) {
					$this->searchStrings[] = $searchString;
					return true;
				}
			}
			return false;
		}
		
		public function getDomainId() {
			return $this->domainId;
		}
		
		public function getLangId() {
			return $this->langId;
		}
		
		public function getRequiredPermissionsLevel() {
			return $this->permissionsLevel;
		}
		
		public function getSearchStrings() {
			return $this->searchStrings;
		}
		
		public function resetTextSearch() {
			$this->searchStrings = Array();
		}

		//

		private function toIntsArray($vValue) {
			$arrAnswer = Array();
			if (is_string($vValue)) {
				$arrAnswer = preg_split("/[^\d]/is", $vValue);
			} elseif (is_numeric($vValue)) {
				$arrAnswer = array(intval($vValue));
			} elseif (!is_array($vValue)) {
				$arrAnswer = array();
			} else {
			    $arrAnswer = $vValue;
			}
			return array_map('intval', $arrAnswer);
		}
	};


	interface iUmiSelectionsParser {
		public static function runSelection(umiSelection $selectionObject);
		public static function runSelectionCounts(umiSelection $selectionObject);
		public static function parseSelection(umiSelection $selectionObject);
	}


/**
	* Производит выборки по параметрам, переданным через класс umiSelection.
	* Содержит только статические публичные методы, сами по себе экземпляры этого класса бесполезны.
*/
	class umiSelectionsParser implements iUmiSelectionsParser {
		/*
		public static function runSelection(umiSelection $selection)
		public static function runSelectionCounts(umiSelection $selection)
		public static function parseSelection(umiSelection $selection)
		*/
		private function __construct() {}

		/**
		* @desc Выбирает id объектов (umiObject) или елементов иерархии (umiHierarchyElement), соответсвующих указаным критериям
		* @param umiSelection $selection Критерии выборки
		* @return Array id элементов иерархии или объектов
		*/
		public static function runSelection(umiSelection $selection) {
			static $permissions;
			if ($selection->result !== false) return $selection->result; // RETURN

			$sqls = self::parseSelection($selection);

			if (!$sqls['result']) return false; // RETURN

			// ====
			$result = l_mysql_query($sqls['result']);

			$res = Array();
			while ($row = mysql_fetch_row($result)) {
				list($element_id) = $row;
				if(isset($row[1])) {
					if(!$permissions) {
						$permissions = permissionsCollection::getInstance();
					}
					$permissions->pushElementPermissions($element_id, $row[1]);
				}
				$element_id = intval($element_id);
				if(in_array($element_id, $res) == false) {
					$res[] = $element_id;
				}
			}

			if($selection->excludeNestedPages) {
				$res = self::excludeNestedPages($res);
			}

			$selection->result = $res;

			if(defined("DISABLE_CALC_FOUND_ROWS")) {
				if(DISABLE_CALC_FOUND_ROWS) {
					$sql = "SELECT FOUND_ROWS()";
					$result = l_mysql_query($sql, true);

					list($count) = mysql_fetch_row($result);
					$selection->count = $count;
				}
			}
			if ($selection->optimize_root_search_query) {
				$selection->count = false;
			}
			// RETURN
			return $selection->result;
		}

		/**
		* @desc Выполняет подсчет элементов/объктов, соответствующих критериям выборки
		* @param umiSelection $selection Критерии выборки
		* @return Int количество выбранных объектов или элементов
		*/
		public static function runSelectionCounts(umiSelection $selection) {
			if ($selection->count !== false) return $selection->count; // RETURN

			$sqls = self::parseSelection($selection);

			if (!$sqls['count']) return false; // RETURN


			if ($count = cacheFrontend::getInstance()->loadSql($sqls['count'])) {
				// RETURN
				return $count;
			}

			// ====

			$result = l_mysql_query($sqls['count']);

			if (list($count) = mysql_fetch_row($result)) {
				$selection->count = intval($count);
				// RETURN
				cacheFrontend::getInstance()->saveSql($sqls['count'], $selection->count);
				return $selection->count;
			} else {
				// RETURN
				return false;
			}
		}

		/**
		* @desc Производит подготовку запросов к выборке
		* @param umiSelection $selection Критерии выборки
		* @return Array ID объектов (umiObject) или элементов иерархии (umiHierarchyElement)
		*/
		public static function parseSelection(umiSelection $selection) {

			/*

			Метод формирует запросы для использования методами
			runSelection и runSelectionCounts
			на основании данных из $selection

			Вот что мы должны получить в итоге :

			SELECT
				[ALL | DISTINCT | DISTINCTROW ]
					[HIGH_PRIORITY]
					[STRAIGHT_JOIN]
					[SQL_SMALL_RESULT] [SQL_BIG_RESULT] [SQL_BUFFER_RESULT]
					[SQL_CACHE | SQL_NO_CACHE] [SQL_CALC_FOUND_ROWS]
				select_expr, ...
				[FROM table_references
				[WHERE where_condition]
				[GROUP BY {col_name | expr | position}
					[ASC | DESC], ... [WITH ROLLUP]]
				[HAVING where_condition]
				[ORDER BY {col_name | expr | position}
					[ASC | DESC], ...]
				[LIMIT {[offset,] row_count | row_count OFFSET offset}]
				[PROCEDURE procedure_name(argument_list)]
				[INTO OUTFILE 'file_name' export_options
					| INTO DUMPFILE 'file_name'
					| INTO var_name [, var_name]]
				[FOR UPDATE | LOCK IN SHARE MODE]]

			*/

			if(!defined('MAX_SELECTION_TABLE_JOINS')) {
				define('MAX_SELECTION_TABLE_JOINS', 10);
			}

			/*
			I. Хранить промежуточные результаты мы будем в $selection'е (так как сами мы static),
			а перед работой их обдефолтим :
			*/

			// это промежуточные строки и триггеры, на основании которых соберутся итоговые запросы

			$selection->sql_cond__need_content = false;
			$selection->sql_cond__need_hierarchy = $selection->getForceCond();
			$selection->sql_cond__domain_ignored = $selection->getIsDomainIgnored();
			$selection->sql_cond__lang_ignored = $selection->getIsLangIgnored();
			$selection->sql_cond__total_joins = 0;
			$selection->sql_cond__content_tables_loaded = 0; // for tables naming in the query
			$selection->sql_arr_for_mark_used_fields = array();
			$selection->sql_arr_for_and_or_part = array();

			$selection->sql_part__hierarchy = "";			// условие на родителя элемента иерархии
			$selection->sql_part__element_type = "";		// условие на тип элементов иерархии
			$selection->sql_part__object_type = "";			// условие на тип объектов данных
			$selection->sql_part__owner = "";				// условие на владельца
			$selection->sql_part__objects = "";				// условие на конкретные объекты данных
			$selection->sql_part__elements = "";			// условие на конкретные элементы иерархии
			$selection->sql_part__perms = "";				// учесть разрешения
			$selection->sql_part__props_and_names = "";		// условия на значения свойств и имена
			$selection->sql_part__lang_cond = "";			// условие на языки
			$selection->sql_part__domain_cond = "";			// условие на домены
			$selection->sql_part__unactive_cond = "";		// условие на активность элемента

			$selection->sql_part__perms_tables = "";
			$selection->sql_part__content_tables = "";

			// это основные части итоговых запросов

			$selection->sql_kwd_distinct = "";
			$selection->sql_kwd_distinct_count = "";
			$selection->sql_kwd_straight_join = "";

			$selection->sql_select_expr = "";
			$selection->sql_table_references = "";
			$selection->sql_where_condition_required = "";
			$selection->sql_where_condition_common = "";
			$selection->sql_where_condition_additional = "";

			$selection->sql_order_by = "";
			$selection->sql_limit = ""; // ограничение на количество рядов в выборке

			/*
			II. Далее формируем промежуточные результаты
			!!! порядок вызова важен, не меняй не думая !!! // WARNING
			*/

			/*
				---- makeLimitPart ----

				формирует "ограничение на количество рядов в выборке", т.е.
				limit-offset часть запроса, согласно $selection->getLimitConds()

				условия задаются в umiSelection последовательным вызовом
				setLimitFilter и addLimit
				(или просто addLimit, т.к. он сам вызывает setLimitFilter)

				----

				Влияет на:
				- $selection->sql_limit
			*/
			self::makeLimitPart($selection);

			/*
				---- makeHierarchyPart ----

				формирует часть запроса "условие на родителя", то есть
				"выбрать только такие элементы иерархии,
				которые являются непосредственными потомками указанных элементов"

				получить "указанные элементы" - $selection->getHierarchyConds()

				задаются "указанные элементы" в umiSelection последовательным вызовом
				setHierarchyFilter и addHierarchyFilter
				(или просто addHierarchyFilter, т.к. он сам вызывает setHierarchyFilter)

				NOTE: в addHierarchyFilter указывается глубина, но в запросе, генерируемом self::makeHierarchyPart
				глубина не участвует, так как addHierarchyFilter сам пробегается по всей глубине,
				и включает всех потомков в массив, возвращаемый $selection->getHierarchyConds()
				(глубина и не может участвовать, так как таблица предполагает связь только с непосредственным родителем (rel))

				----

				Влияет на:
				- $selection->sql_part__hierarchy
				- $selection->sql_cond__domain_ignored
				- $selection->sql_cond__need_hierarchy
			*/
			self::makeHierarchyPart($selection);


			/*
				---- makeElementTypePart ----

				формирует часть запроса "условие на тип элементов иерархии", то есть
				"выбрать только те элементы иерархии, которые имеют один из указанных типов"

				получить "указанные типы элементов" - $selection->getElementTypeConds()

				задаются "указанные типы элементов" в umiSelection последовательным вызовом
				setElementTypeFilter и addElementType
				(или просто addElementType, т.к. он сам вызывает setElementTypeFilter)

				----

				Влияет на:
				$selection->sql_part__element_type
				$selection->sql_cond__need_hierarchy
			*/
			self::makeElementTypePart($selection);


			/*
				---- makeOwnerPart ----

				формирует часть запроса "условие на владельца", то есть
				"выбрать только те объекты данных / элементы иерархии,
				которые имеют одного из указанных владельцев"

				получить "указанных владельцев" - $selection->getOwnerConds()

				задаются "указанные владельцы" в umiSelection последовательным вызовом
				setOwnerFilter и addOwnerFilter
				(или просто addOwnerFilter, т.к. он сам вызывает setOwnerFilter)

				----

				Влияет на:
				$selection->sql_part__owner
			*/
			self::makeOwnerPart($selection);

			/*
				---- makeObjectsPart ----

				формирует часть запроса "условие на конкретные объекты данных", то есть
				"выбрать только те объекты данных,
				которые имеют один из указанных идентификаторов"
				(например, получены предыдущим запросом umiSelection'а)

				получить "указанные идентификаторы" - $selection->getObjectsConds()

				задаются "указанные идентификаторы" в umiSelection последовательным вызовом
				setObjectsFilter и addObjectsFilter
				(или просто addObjectsFilter, т.к. он сам вызывает setObjectsFilter)

				----

				Влияет на:
				$selection->sql_part__objects
			*/
			self::makeObjectsPart($selection);

			/*
				---- makeElementsPart ----

				формирует часть запроса "условие на конкретные элементы иерархии", то есть
				"выбрать только те элементы иерархии,
				которые имеют один из указанных идентификаторов"
				(например, получены предыдущим запросом umiSelection'а)

				получить "указанные идентификаторы" - $selection->getElementsConds()

				задаются "указанные идентификаторы" в umiSelection последовательным вызовом
				setElementsFilter и addElementsFilter
				(или просто addElementsFilter, т.к. он сам вызывает setElementsFilter)

				----

				Влияет на:
				$selection->sql_part__elements
				$selection->sql_cond__need_hierarchy
			*/
			self::makeElementsPart($selection);

			/*
				---- makePermsParts ----

				формирует часть запроса "учесть разрешения", то есть
				"выбрать только те элементы иерархии, на которые у указанного пользователя
				и групп, в которые он входит, есть разрешения на чтение"

				получить "указанного пользователя и его группы" - $selection->getPermissionsConds()

				задаются "указанный пользователь и его группы" в umiSelection последовательным вызовом
				setPermissionsFilter и addPermissions
				(или просто addPermissions, т.к. он сам вызывает setPermissionsFilter)

				----

				Влияет на:
				$selection->sql_part__perms
				$selection->sql_part__perms_tables
				$selection->sql_cond__need_hierarchy
			*/
			self::makePermsParts($selection);

			/*
				---- makePropPart ----

				формирует условия в зависимости от
				заданных "фильтров по полям объектов/элементов"

				получить "фильтры по полям объектов/элементов" - $selection->getPropertyConds()

				задаются "фильтры по полям объектов/элементов" в umiSelection последовательным вызовом
				setPropertyFilter и методов
					- addPropertyFilterBetween
					- addPropertyFilterEqual
					- addPropertyFilterNotEqual
					- addPropertyFilterLike
					- addPropertyFilterMore
					- addPropertyFilterLess
					- addPropertyFilterIsNull
				(или просто этими методами, т.к. они сами вызывают setPropertyFilter)

				----

				Влияет на:
				$selection->sql_part__props_and_names
				$selection->sql_part__content_tables
				$selection->sql_cond__need_content
				$selection->sql_cond__total_joins
			*/
			self::makePropPart($selection);

			/*
				---- makeObjectTypePart ----

				формирует часть запроса "условие на тип объектов данных", то есть
				"выбрать только те объектов (соотнесенные с ними элементы иерархии),
				которые имеют один из указанных типов"

				получить "указанные типы объектов" - $selection->getObjectTypeConds()

				задаются "указанные типы объектов" в umiSelection последовательным вызовом
				setObjectTypeFilter и addObjectType
				(или просто addObjectType, т.к. он сам вызывает setObjectTypeFilter)

				----

				Влияет на:
				$selection->sql_part__object_type
			*/
			self::makeObjectTypePart($selection);

			/*
				---- makeOrderPart ----

				формирует часть запроса "ORDER BY"

				получить "ORDER BY" - $selection->getOrderConds()

				задаются "ORDER BY" в umiSelection последовательным вызовом
				setOrderFilter и методов
					- setOrderByProperty
					- setOrderByOrd
					- setOrderByRand
					- setOrderByName
					- setOrderByObjectId
				(или просто этими методами, т.к. они сами вызывают setOrderFilter)

				----

				Влияет на:
				$selection->sql_order_by
				$selection->sql_cond__need_content
				$selection->sql_cond__content_tables_loaded
				$selection->sql_part__content_tables
				$selection->sql_arr_for_and_or_part
				$selection->sql_cond__total_joins
			*/
			self::makeOrderPart($selection);

			/*
				---- makeNamesPart ----

				формирует часть запроса
				"взять только объекты с указанными/похожими именами"

				получить "указанные имена" - $selection->getNameConds

				задаются "указанные имена" в umiSelection последовательным вызовом
				setNamesFilter и методов
					- addNameFilterEquals
					- addNameFilterLike
				(или просто этими методами, т.к. они сами вызывают setNamesFilter)

				----

				Влияет на:
				$selection->sql_arr_for_and_or_part
			*/
			self::makeNamesPart($selection);

			/*
				---- makePropsAndNames ----

				Сводит массив sql_arr_for_and_or_part в подстроку запроса

				----

				Влияет на:
				$selection->sql_part__props_and_names
			*/
			self::makePropsAndNames($selection);

			/*
				---- makeHierarchySpecificConds ----

				вводит в запрос условия, специфичные для
				элементов иерархии (в отличие от объектов данных)

				----

				Влияет на:
				$selection->sql_part__lang_cond
				$selection->sql_part__domain_cond
				$selection->sql_part__unactive_cond
			*/
			self::makeHierarchySpecificConds($selection);

			// ==== если получилось слишком много таблиц - уходим
			// RETURN

			if ($selection->sql_cond__total_joins >= 59) {
				return Array("result" => false, "count" => false);
			}

			/*
			III. Теперь формируем основные части запроса

			Эти вызовы уже ни на что не влияют,
			просто собирают основные части запроса
			из строк и в соответствии с условиями,
			сформированными на предыдущем этапе
			*/

			self::makeDistinctKeywords($selection);

			self::makeStraitJoinKeyword($selection);

			self::makeSelectExpr($selection);

			self::makeTables($selection);

			self::makeWhereConditions($selection);

			$sql_join_content_tables = "";
			$sz = sizeof($selection->usedContentTables);
			if($sz > 1) {
				for($i = 0; $i < $sz - 1; $i++) {
					$current = $selection->usedContentTables[$i];
					$next = $selection->usedContentTables[$i + 1];
					$sql_join_content_tables .= " AND {$current}.obj_id = {$next}.obj_id";
				}

			}


			/*
			IV. Формируем и возвращаем запросы
			*/

			// RETURN :
			$sql_calc_found_rows = "";
			if(defined("DISABLE_CALC_FOUND_ROWS")) {
				if(DISABLE_CALC_FOUND_ROWS) {
					$sql_calc_found_rows = "SQL_CALC_FOUND_ROWS";
				}
			}

			if($selection->sql_part__perms_tables) {
				$selection->sql_kwd_distinct = "";
				$selection->sql_group_by = " GROUP BY h.id";
			} else {
				$selection->sql_group_by = "";
			}

			$sql = <<<SQL
				SELECT {$selection->sql_kwd_straight_join} {$sql_calc_found_rows}  {$selection->sql_kwd_distinct}
					{$selection->sql_select_expr}
				FROM
					{$selection->sql_table_references}
				WHERE
					{$selection->sql_where_condition_required}
					{$selection->sql_where_condition_common}
					{$selection->sql_where_condition_additional}
					{$sql_join_content_tables}
				{$selection->sql_group_by}
				{$selection->sql_order_by}
				{$selection->sql_limit}
SQL;

			$sql_count = <<<SQL
				SELECT {$selection->sql_kwd_straight_join} 
					COUNT({$selection->sql_kwd_distinct_count}{$selection->sql_select_count_expr})
				FROM
					{$selection->sql_table_references}
				WHERE
					{$selection->sql_where_condition_required}
					{$selection->sql_where_condition_common}
					{$selection->sql_where_condition_additional}
					{$sql_join_content_tables}
SQL;

			if($selection->optimize_root_search_query
			&& sizeof($selection->getElementTypeConds())
			&& !sizeof(array_positive_values($selection->getHierarchyConds()))) {
				$types_in_clause = implode(", ", $selection->getElementTypeConds());

				if($selection->sql_table_references) {
					$selection->sql_table_references = "," . $selection->sql_table_references;
				}

				if($selection->sql_where_condition_required) {
					$selection->sql_where_condition_required = " AND " . $selection->sql_where_condition_required;
				}

				$sql = <<<SQL
SELECT DISTINCT h.id
	FROM cms3_hierarchy hp
		{$selection->sql_table_references}
		WHERE h.type_id IN ({$types_in_clause})
			AND (h.rel = 0 OR (h.rel = hp.id AND hp.type_id NOT IN ({$types_in_clause}))) {$selection->sql_part__domain_cond} {$selection->sql_part__lang_cond}
			AND h.is_deleted = '0'
			{$selection->sql_where_condition_required}
			{$selection->sql_where_condition_common}
			{$selection->sql_where_condition_additional}
				{$selection->sql_order_by}
				{$selection->sql_limit}
SQL;

				$sql_count = <<<SQL
SELECT COUNT(DISTINCT h.id) FROM cms3_hierarchy h, cms3_hierarchy hp WHERE h.type_id IN ({$types_in_clause}) AND (h.rel = 0 OR (h.rel = hp.id AND hp.type_id NOT IN ({$types_in_clause}))) {$selection->sql_part__domain_cond} {$selection->sql_part__lang_cond} AND h.is_deleted = '0'
SQL;
			}

			return array(
				'result' => $sql,
				'count' => $sql_count
			);

		}

		// ====================================================================
		// ====================================================================
		// ====================================================================
		/*
		Методы для формирования основных частей запроса
		- makeDistinctKeywords
		- makeStraitJoinKeyword
		- makeSelectExpr
		- makeTables
		- makeWhereConditions
		*/

		private static function makeDistinctKeywords(umiSelection $selection) {
			$selection->sql_kwd_distinct = '';
			$selection->sql_kwd_distinct_count = '';
			if ($selection->sql_cond__need_content || ($selection->sql_cond__need_hierarchy && $selection->sql_part__perms)) {
				$selection->sql_kwd_distinct = ' DISTINCT';
				$selection->sql_kwd_distinct_count = 'DISTINCT ';
			}
		}

		private static function makeStraitJoinKeyword(umiSelection $selection) {
			if (MAX_SELECTION_TABLE_JOINS > 0 && $selection->sql_cond__total_joins > MAX_SELECTION_TABLE_JOINS) {
				$selection->sql_kwd_straight_join = "STRAIGHT_JOIN";
			} else {
				$selection->sql_kwd_straight_join = "";
			}
		}

		private static function makeSelectExpr(umiSelection $selection) {
			if ($selection->sql_cond__need_hierarchy) {
				if($selection->sql_part__perms_tables) {
					$selection->sql_select_expr = "h.id, MAX(c3p.level)";
				} else {
					$selection->sql_select_expr = "h.id";
				}
				$selection->sql_select_count_expr = "h.id";
			} else {
				$selection->sql_select_expr = "o.id";
				$selection->sql_select_count_expr = "o.id";
			}
		}

		private static function makeTables(umiSelection $selection) {
			$s_other_tables = '';
			if ($selection->sql_cond__need_content) {
				$s_other_tables = $selection->sql_part__content_tables;
			}

			if ($selection->sql_cond__need_hierarchy) {
				if($selection->sql_part__content_tables || $selection->objectTableIsRequired) {
					$objects_table = "cms3_objects o,";
				} else {
					$objects_table = "";
				}

				$selection->sql_table_references .= <<<SQL
					{$objects_table}
					cms3_hierarchy h
					{$s_other_tables}
					{$selection->sql_part__perms_tables}
SQL;
			} else {
				$selection->sql_table_references .= <<<SQL
					cms3_objects o
					{$s_other_tables}
SQL;
			}
		}

		private static function makeWhereConditions(umiSelection $selection) {
			if($selection->sql_part__owner) {
				$selection->sql_part__owner = " AND " . $selection->sql_part__owner;
			}

			// common
			$selection->sql_where_condition_common = <<<SQL
					{$selection->sql_part__object_type}
					{$selection->sql_part__props_and_names}
					{$selection->sql_part__owner}
					{$selection->sql_part__objects}
					{$selection->sql_part__elements}
SQL;

			// required and additional
			if ($selection->sql_cond__need_hierarchy) {

				if($selection->sql_cond__need_hierarchy
				 && !$selection->sql_part__content_tables
				 && !$selection->objectTableIsRequired) {
					$objectsToHierarchyRelation = "";
				} else {
					$objectsToHierarchyRelation = "h.obj_id = o.id AND ";
				}

				$selection->sql_where_condition_required = <<<SQL
					{$objectsToHierarchyRelation}
					h.is_deleted = '0'
SQL;
				$selection->sql_where_condition_additional = <<<SQL
					{$selection->sql_part__hierarchy}
					{$selection->sql_part__unactive_cond}
					{$selection->sql_part__element_type}
					{$selection->sql_part__perms}
					{$selection->sql_part__lang_cond}
					{$selection->sql_part__domain_cond}
SQL;
			} else {
				$selection->sql_where_condition_required = "1";
				$selection->sql_where_condition_additional = "";
			}
		}

		// ====================================================================
		// ====================================================================
		// ====================================================================
		/*
		Методы для формирования промежуточных частей запроса
		и условий их сборки
		*/

		private static function makeLimitPart(umiSelection $selection) {
			$selection->sql_limit = "";
			//
			$limit_cond = $selection->getLimitConds();
			if ($limit_cond !== false) {
				if (is_array($limit_cond) && count($limit_cond) > 1 && is_numeric($limit_cond[0]) && is_numeric($limit_cond[1])) {

					$i_limit = intval($limit_cond[0]);
					$i_page = intval($limit_cond[1]);

					$i_offset = $i_page * $i_limit;

					// [LIMIT {[offset,] row_count | row_count OFFSET offset}]
					$selection->sql_limit = " LIMIT ".$i_offset.", ".$i_limit;

				}
			}
			//
			return $selection->sql_limit;
		}

		private static function makeHierarchyPart(umiSelection $selection) {
			$hierarchy_cond = $selection->getHierarchyConds();

			if (!empty($hierarchy_cond)) {
				$HierarchyRootCounter = 0;
				$HierarchyRelationsCounter = 0;
				$HierarchyRelationsConds = Array();
				foreach($hierarchy_cond as $parentFilter) {
					list($parentId, $depth) = $parentFilter;

					if($parentId == 0) {
						$HierarchyRootCounter++;
						--$depth;
					}

					$sql = "SELECT level FROM cms3_hierarchy_relations WHERE child_id = {$parentId}";
					$result = l_mysql_query($sql);

					list($level) = mysql_fetch_row($result);

					$sqlRelPart = ($parentId > 0) ? "hr.rel_id = '{$parentId}'" : "hr.rel_id IS NULL";
					if($HierarchyRelationsCounter == 0) {
						$selection->sql_table_references .= "cms3_hierarchy_relations hr, ";
						$HierarchyRelationsCounter++;
					}
					$seekDepth = $depth + $level + 1;

					$HierarchyRelationsConds[] = <<<SQL
({$sqlRelPart} AND hr.level <= '{$seekDepth}') AND hr.child_id = h.id
SQL;
				}

				if(sizeof($HierarchyRelationsConds) > 0) {
					$selection->sql_part__hierarchy .= " AND ((" . implode(") OR (", $HierarchyRelationsConds) . ")) ";
				}

				$selection->sql_cond__domain_ignored = ($HierarchyRootCounter) ? false : true; // ?
				$selection->sql_cond__lang_ignored = ($HierarchyRootCounter) ? false : true; // ?

				$selection->sql_cond__need_hierarchy = true;

				if(sizeof($hierarchy_cond) == 1) {
					if($hierarchy_cond[0] != 0) {
						$selection->sql_cond_auto_domain = true;
					}
				} else {
					$selection->sql_cond_auto_domain = true;
				}
			}
		}

		private static function makeElementTypePart(umiSelection $selection) {
			$element_type_cond = $selection->getElementTypeConds();
			if ($element_type_cond && count($element_type_cond)) {
				$selection->sql_part__element_type = " AND h.type_id IN ('".implode("', '", $element_type_cond)."')";
				$selection->sql_cond__need_hierarchy = true;
			}
		}

		private static function makeOwnerPart(umiSelection $selection) {
			$owner_cond = $selection->getOwnerConds();
			if (is_array($owner_cond) && count($owner_cond)) {
				$selection->sql_part__owner = " o.owner_id IN ('".implode("', '", $owner_cond)."')";
				$selection->objectTableIsRequired = true;
			}
		}

		private static function makeObjectsPart(umiSelection $selection) {
			$objects_cond = $selection->getObjectsConds();
			if (is_array($objects_cond) && count($objects_cond)) {
				$selection->sql_part__objects = " AND o.id IN ('".implode("', '", $objects_cond)."')";
			}
		}

		private static function makeElementsPart(umiSelection $selection) {
			$elements_cond = $selection->getElementsConds();
			if (is_array($elements_cond) && count($elements_cond)) {
				$selection->sql_part__elements = " AND h.id IN ('".implode("', '", $elements_cond)."')";
				$selection->sql_cond__need_hierarchy = true;
			}
		}

		private static function makePermsParts(umiSelection $selection) {
			if ($perms_cond = $selection->getPermissionsConds()) {
				$guestId = umiObjectsCollection::getInstance()->getObjectIdByGUID('system-guest');
				$perms_cond[] = $guestId;
				if ($sz = sizeof($perms_cond)) {
					$selection->sql_part__perms_tables = ",cms3_permissions c3p";
					$selection->sql_cond__need_hierarchy = true;

					$permissionsLevel = $selection->getRequiredPermissionsLevel();

					for ($i = 0; $i < $sz; $i++) {

						$selection->sql_part__perms .= ($i === 0 ? " AND (" : "");
						$selection->sql_part__perms .= "(c3p.owner_id = '".$perms_cond[$i]."' AND c3p.rel_id = h.id AND c3p.level & '{$permissionsLevel}')";
						$selection->sql_part__perms .= ($i === ($sz - 1) ? ")" : " OR ");

					}
				}
			}
		}

		private static function makePropPart(umiSelection $selection) {
			if($searchStrings = $selection->getSearchStrings()) {
				$tableName = "cms3_object_content";

				$elements = $selection->getHierarchyConds();
				$elements = array_extract_values($elements);
				if(sizeof($elements)) {
					$objectTypeId = umiHierarchy::getInstance()->getDominantTypeId(array_pop($elements));
					$tableName = umiBranch::getBranchedTableByTypeId($objectTypeId);
				} else {
					$types = $selection->getElementTypeConds();
					if(is_array($types) && sizeof($types)) {
						$hierarchyTypeId = array_pop($types);
						if($hierarchyTypeId == 21 && sizeof($types)) {
							$hierarchyTypeId = array_pop($types);
						}

						if(umiBranch::checkIfBranchedByHierarchyTypeId($hierarchyTypeId)) {
							$tableName .= "_" . $hierarchyTypeId;
						}
					}
				}


				$cname = "ct";

				$selection->sql_part__content_tables .= ", {$tableName} {$cname}";
				$selection->usedContentTables[] = $cname;

				$fileFields = self::getFileFields();
				if(sizeof($fileFields) > 0) {
					$fileFieldsCond = " AND ct.field_id NOT IN (" . implode(", ", $fileFields) . ")";
				} else {
					$fileFieldsCond = "";
				}

				$searchConds = Array();
				foreach($searchStrings as $searchString) {
					$searchString = l_mysql_real_escape_string($searchString);
					$intCond = (is_numeric($searchString)) ? " OR ct.float_val = '{$searchString}' OR ct.int_val = '{$searchString}'" : "";
					$searchConds[] = "o.name LIKE '%{$searchString}%' OR ct.varchar_val LIKE '%{$searchString}%' OR ct.text_val LIKE '%{$searchString}%' {$intCond}" . $fileFieldsCond;
				}

				$selection->sql_arr_for_and_or_part['where'][] = "ct.obj_id = o.id AND (" . implode(" OR ", $searchConds) . ")";
				$selection->sql_cond__need_content = true;
			}

			if ($arr_propconds = $selection->getPropertyConds()) {

				$prop_cond = array();
				foreach ($arr_propconds as $arr_cond) {
					if ($arr_cond['type'] !== false) $prop_cond[] = $arr_cond;
				}
				unset($arr_propconds);

				if ($sz = sizeof($prop_cond)) {

					$i = 0;
					for ($i = 0; $i < $sz; $i++) {
						$arr_next_cond = $prop_cond[$i];
						$s_filter_type = (isset($arr_next_cond['filter_type']) ? $arr_next_cond['filter_type'] : '');
						$v_value = (isset($arr_next_cond['value']) ? $arr_next_cond['value'] : null);
						$i_field_id = (isset($arr_next_cond['field_id']) ? $arr_next_cond['field_id'] : 0);
						$s_type = (isset($arr_next_cond['type']) ? $arr_next_cond['type'] : '');



						if($s_type == 'optioned') {
							if(!is_array($v_value)) continue;
							$keys = array_keys($v_value);
							if(sizeof($keys) == 0) continue;
							list($s_type) = $keys;

							if(in_array($s_type, array('int', 'float', 'varchar', 'tree', 'rel')) == false) continue;
							$s_type .= "_val";
						}

						/* ? */
						if (!$selection->getConditionModeOr() || $selection->sql_cond__content_tables_loaded == 0) {
							$cname = "c" . (++$selection->sql_cond__content_tables_loaded); // имя очередной таблицы

							$tableName = self::chooseContentTableName($selection, $prop_cond[$i]['field_id']);
							$selection->sql_part__content_tables .= ", {$tableName} {$cname}";
							$selection->usedContentTables[] = $cname;
						}

						$s_common = $cname.".obj_id = o.id AND ".$cname.".field_id = '".$i_field_id."'";
						if($s_type != 'optioned') {
							$s_field = $cname.".".$s_type;
						}

						switch ($s_filter_type) {

							case 'equal':
									if($v_value) {
										if (!is_array($v_value)) $v_value = array($v_value);
										$s_values = "'".(implode("', '", array_map('l_mysql_real_escape_string', $v_value)))."'";
										$s_next_cond = "(".$s_common." AND (".$s_field." IN (".$s_values.")))";
									} else {
										$v_value = l_mysql_real_escape_string($v_value);
										$s_next_cond = "({$s_common} AND ({$s_field} = '{$v_value}' OR {$s_field} IS NULL))";
									}

								break;

							case 'not_equal':
									if (!is_array($v_value)) $v_value = array($v_value);
									$s_values = "'".(implode("', '", array_map('l_mysql_real_escape_string', $v_value)))."'";

								$s_next_cond = "(".$s_common." AND ((".$s_field." IS NULL) OR (".$s_field." NOT IN (".$s_values."))))";
								break;

							case 'like':
									$b_need_percents = true;
									if (substr($v_value, 0, 1) === '%' || substr($v_value, -1) === '%') $b_need_percents = false;

									$s_value = l_mysql_real_escape_string($v_value);

								$s_next_cond = "(".$s_common." AND ".$s_field." LIKE '".($b_need_percents ? "%" : "").$s_value.($b_need_percents ? "%" : "")."')";
								break;

							case 'between':
									$f_min = (isset($arr_next_cond['min']) ? floatval($arr_next_cond['min']) : 0);
									$f_max = (isset($arr_next_cond['max']) ? floatval($arr_next_cond['max']) : 0);

								$s_next_cond = "(".$s_common." AND ".$s_field." BETWEEN '".$f_min."' AND '".$f_max."')";
								break;

							case 'more':
									$f_value = floatval($v_value);

								$s_next_cond = "(".$s_common." AND ".$s_field." >= '".$f_value."')";
								break;

							case 'less':
									$f_value = floatval($v_value);

								$s_next_cond = "(".$s_common." AND ".$s_field." <= '".$f_value."')";
								break;

							case 'null':
								$s_next_cond = "(".$s_common." AND ".$s_field." IS NULL)";
								break;

							case 'notnull':
								$s_next_cond = "(".$s_common." AND ".$s_field." IS NOT NULL)";
								break;

							default:
								$s_next_cond = "";
								break;
						}

						if (strlen($s_next_cond)) {
							$selection->sql_arr_for_and_or_part['where'][] = $s_next_cond;
						}

					}

					if (count($selection->sql_arr_for_and_or_part)) {
						$selection->sql_cond__need_content = true;
						$selection->sql_cond__total_joins += $i;
					}
				}
			}
		}

		private static function makeObjectTypePart(umiSelection $selection) {
			$object_type_cond = $selection->getObjectTypeConds();
			if ($object_type_cond && count($object_type_cond)) {
				$selection->sql_part__object_type = " AND o.type_id IN ('".implode("', '", $object_type_cond)."')";
				$selection->objectTableIsRequired = true;
			}
		}

		private static function makeOrderPart(umiSelection $selection) {
			$order_cond = $selection->getOrderConds();
			if ($order_cond) {
				$i = 0;
				$selection->sql_order_by = " ORDER BY ";
				$sz = sizeof($order_cond);

				for ($i = 0; $i < $sz; $i++) {
					if ($native_field = $order_cond[$i]['native_field']) {
						switch($native_field) {
							case "name": {
								$selection->sql_order_by .= "o.name " . (($order_cond[$i]['asc']) ? "ASC" : "DESC");
								$selection->sql_need_object_table = true;
								$selection->objectTableIsRequired = true;
								break;
							}

							case "object_id": {
								$selection->sql_order_by .= "o.id " . (($order_cond[$i]['asc']) ? "ASC" : "DESC");
								$selection->objectTableIsRequired = true;
								break;
							}

							case "rand": {
								$selection->sql_order_by .= "RAND()";
								break;
							}

							case "ord": {
								if($selection->objectTableIsRequired && !$selection->sql_cond__need_hierarchy) {
									$selection->sql_order_by .= "o.ord " . (($order_cond[$i]['asc']) ? "ASC" : "DESC");
								} else {
									$selection->sql_order_by .= "h.ord " . (($order_cond[$i]['asc']) ? "ASC" : "DESC");
								}
								break;
							}
						}

						if ($i !== ($sz - 1)) {
							$selection->sql_order_by .= ", ";
						}

					} else {

						$selection->sql_cond__need_content = true;

						$cname = "c" . (++$selection->sql_cond__content_tables_loaded);

						$tableName = self::chooseContentTableName($selection, $order_cond[$i]['field_id']);
						$selection->sql_part__content_tables .= ", {$tableName} {$cname}";
						$selection->usedContentTables[] = $cname;

						$selection->sql_arr_for_and_or_part['order'][] = "{$cname}.obj_id = o.id AND {$cname}.field_id = '{$order_cond[$i]['field_id']}'";


						$selection->sql_order_by .= "{$cname}.{$order_cond[$i]['type']} " . (($order_cond[$i]['asc']) ? "ASC" : "DESC");
						if ($i == ($sz - 1)) {
						} else {
							$selection->sql_order_by .= ", ";
						}
					}
				}

				if ($selection->sql_order_by == " ORDER BY ") {
					$selection->sql_order_by = "";
				}
				$selection->sql_cond__total_joins += $i;
			} elseif ($selection->sql_cond__need_hierarchy == true) {
				$selection->sql_order_by = " ORDER BY h.ord";
			}
		}

		private static function makeNamesPart(umiSelection $selection) {
			$arr_names_parts = array();
			if (($names_cond = $selection->getNameConds()) && count($names_cond)) {
				foreach ($names_cond as $arr_next_name) {

					$cname = $arr_next_name['value'];

					$b_need_percents = true;
					if (substr($cname, 0, 1) === '%' || substr($cname, -1) === '%') $b_need_percents = false;

					$cname = l_mysql_real_escape_string($cname);

					if ($arr_next_name['type'] == 'exact') {
						$arr_names_parts[] = "o.name = '".$cname."'";
					} else {
						$arr_names_parts[] = "o.name LIKE '".($b_need_percents ? "%" : "").$cname.($b_need_percents ? "%" : "")."'";
					}
					$selection->objectTableIsRequired = true;
				}
			}
			if (count($arr_names_parts)) {
				$selection->sql_arr_for_and_or_part['where'][] = "(".implode(' OR ', $arr_names_parts).")";
			}
		}

		private static function makePropsAndNames(umiSelection $selection) {
			$selection->sql_part__props_and_names = "";
			if($selection->sql_part__owner) {
				$selection->sql_arr_for_and_or_part['where'][] = $selection->sql_part__owner;
				$selection->sql_part__owner = "";
			}

			if (isset($selection->sql_arr_for_and_or_part['where'])) {
				$s_concat_mode = ($selection->getConditionModeOr() ? ' OR ' : ' AND ');
				$selection->sql_part__props_and_names = " AND (" . implode($s_concat_mode, $selection->sql_arr_for_and_or_part['where']) . ")";
			}

			if(isset($selection->sql_arr_for_and_or_part['order'])) {
					$selection->sql_part__props_and_names .= " AND (" . implode(" AND ", $selection->sql_arr_for_and_or_part['order']) . ")";
			}
		}

		private static function makeHierarchySpecificConds(umiSelection $selection) {
			if ($selection->sql_cond__need_hierarchy == true) {
				{
					if(!$selection->sql_cond__lang_ignored) {
						if(($langId = $selection->getLangId()) == false) {
							$langId = (int) cmsController::getInstance()->getCurrentLang()->getId();
						}
						$selection->sql_part__lang_cond = " AND h.lang_id = '" . $langId . "' ";
					}
				}

				if (!$selection->sql_cond__domain_ignored) {

					if(($domainId = $selection->getDomainId()) == false) {
						$domainId = cmsController::getInstance()->getCurrentDomain()->getId();
					}
					$selection->sql_part__domain_cond = " AND h.domain_id = '" . (int) $domainId . "' ";
				} else {
					$selection->sql_part__domain_cond = "";
				}

				if ($active_cond = $selection->getActiveConds()) {
					$is_active = (isset($active_cond[0]) && (bool) $active_cond[0])? 1 : 0;
					$selection->sql_part__unactive_cond = " AND h.is_active = '".$is_active."' ";
				} else {
					$selection->sql_part__unactive_cond = (cmsController::getInstance()->getCurrentMode() != "admin") ? " AND h.is_active = '1' " : "";
				}
			}
		}


		protected static function chooseContentTableName(umiSelection $selection, $fieldId) {
			$hierarchyTypes = $selection->getElementTypeConds();
			$objectTypes = $selection->getObjectTypeConds();

			if(!is_array($hierarchyTypes)) {
				$hierarchyTypes = Array();
			} else {
				$hierarchyTypes = array_extract_values($hierarchyTypes);
			}

			if(!is_array($objectTypes)) {
				$objectTypes = Array();
			} else {
				$objectTypes = array_extract_values($objectTypes);
			}

			if(sizeof($hierarchyTypes) == 1) {
				reset($hierarchyTypes);
				$hierarchyTypeId = current($hierarchyTypes);
				$isBranched = umiBranch::checkIfBranchedByHierarchyTypeId($hierarchyTypeId);
				return $isBranched ? "cms3_object_content_{$hierarchyTypeId}" : "cms3_object_content";
			}

			if(sizeof($hierarchyTypes) > 1) {
				$objectTypeId = self::getObjectTypeByFieldId($fieldId);
				return umiBranch::getBranchedTableByTypeId($objectTypeId);
			}

			if(sizeof($hierarchyTypes) == 0) {
				if(sizeof($objectTypes) == 1) {
					reset($objectTypes);
					$objectTypeId = current($objectTypes);
				} else {
					$objectTypeId = self::getObjectTypeByFieldId($fieldId);
				}
				return umiBranch::getBranchedTableByTypeId($objectTypeId);
			}

			return "cms3_object_content";
		}


		public static function getObjectTypeByFieldId($fieldId) {
			static $cache = Array();
			$fieldId = (int) $fieldId;

			if(isset($cache[$fieldId])) {
				return $cache[$fieldId];
			}

			$sql = <<<SQL
SELECT  MIN(fg.type_id)
	FROM cms3_fields_controller fc, cms3_object_field_groups fg
	WHERE fc.field_id = {$fieldId} AND fg.id = fc.group_id
SQL;
			if($objectTypeId = cacheFrontend::getInstance()->loadSql($sql)) {
				return $cache[$fieldId] = $objectTypeId;
			}

			$result = l_mysql_query($sql);

			if(mysql_num_rows($result)) {
				list($objectTypeId) = mysql_fetch_row($result);
			} else {
				$objectTypeId = false;
			}
			$cache[$fieldId] = $objectTypeId;
			cacheFrontend::getInstance()->saveSql($sql, $objectTypeId, 60);
			return $objectTypeId;
		}

		protected static function excludeNestedPages($arr) {
			$hierarchy = umiHierarchy::getInstance();

			$result = Array();
			foreach($arr as $elementId) {
				$element = $hierarchy->getElement($elementId);
				if($element instanceof umiHierarchyElement) {
					if(in_array($element->getRel(), $arr)) {
						continue;
					} else {
						$result[] = $elementId;
					}
				}
			}
			return $result;
		}


		protected static function getFileFields() {
			static $cache = false;
			if($cache) return $cache;

			$sql = <<<SQL
SELECT of.id
	FROM cms3_object_fields of, cms3_object_field_types oft
		WHERE of.field_type_id = oft.id
		AND oft.data_type IN ('file', 'img_file', 'swf_file')
SQL;
			$result = l_mysql_query($sql);

			$res = array();
			while(list($fieldId) = mysql_fetch_row($result)) {
				$res[] = $fieldId;
			}

			return $cache = $res;
		}
	};


/**
	* Этот класс служит для управления свойствами типа поля
*/
	class umiFieldType extends umiEntinty implements iUmiEntinty, iUmiFieldType {
		private $name, $data_type, $is_multiple = false, $is_unsigned = false;
		protected $store_type = "field_type";

		/**
			* Получить описание типа
			* @return String описание типа
		*/
		public function getName() {
			return $this->translateLabel($this->name);
		}

		/**
			* Узнать, может ли значение поля данного типа состоять из массива значений (составной тип)
			* @return Boolean true, если тип составной
		*/
		public function getIsMultiple() {
			return $this->is_multiple;
		}


		/**
			* Узнать, может ли значение поля данного типа иметь знак.
			* Зарезервировано и пока не используется
			* @return Boolean true, если значение поля не будет иметь знак
		*/
		public function getIsUnsigned() {
			return $this->is_unsigned;
		}

		/**
			* Получить идентификатор типа
			* @return String идентификатор типа
		*/
		public function getDataType() {
			return $this->data_type;
		}

		/**
			* Получить список всех поддерживаемых идентификаторов типа
			* @return Array список идентификаторов
		*/
		public static function getDataTypes() {
			return

			Array	(
				"int",
				"string",
				"text",
				"relation",
				"file",
				"img_file",
				"video_file",
				"swf_file",
				"date",
				"boolean",
				"wysiwyg",
				"password",
				"tags",
				"symlink",
				"price",
				"formula",
				"float",
				"counter",
				"optioned"
				);
		}

		/**
			* Получить имя поля таблицы БД, где будут хранится данные по идентификатору типа
			* @param String $data_type идентификатор типа
			* @return String имя поля таблицы БД, либо false, если связь не обнаружена
		*/
		public static function getDataTypeDB($data_type) {
			$rels = Array	(
				"int"		 => "int_val",
				"string"	 => "varchar_val",
				"text"		 => "text_val",
				"relation"	 => "rel_val",
				"file"		 => "text_val",
				"img_file"	 => "text_val",
				"swf_file"	 => "text_val",
				"video_file" => "text_val",
				"date"		 => "int_val",
				"boolean"	 => "int_val",
				"wysiwyg"	 => "text_val",
				"password"	 => "varchar_val",
				"tags"		 => "varchar_val",
				"symlink"	 => "tree_val",
				"price"		 => "float_val",
				"formula"	 => "varchar_val",
				"float"		 => "float_val",
				"counter"	 => "counter",
				"optioned"	 => "optioned"
				);

			if(array_key_exists($data_type, $rels) === false) {
				return false;
			} else {
				return $rels[$data_type];
			}
		}

		/**
			* Узнать, поддерживается ли идентификатор типа 
			* @param String $data_type идентификатор типа
			* @return Boolean true, если идентификатор типа поддерживается
		*/
		public static function isValidDataType($data_type) {
			return in_array($data_type, self::getDataTypes());
		}



		/**
			* Задать новое описание типа
			* Устанавливает флаг "Модифицирован".
			* @param String $name
		*/
		public function setName($name) {
			$name = $this->translateI18n($name, "field-type-");
			$this->name = $name;
			$this->setIsUpdated();
		}

		/**
			* Указать может ли значение поля данного типа состоять из массива значений (составной тип)
			* Устанавливает флаг "Модифицирован".
			* @param Boolean $is_multiple
		*/
		public function setIsMultiple($is_multiple) {
			$this->is_multiple = (bool) $is_multiple;
			$this->setIsUpdated();
		}

		/**
			* Указать может ли значение поля данного типа иметь знак.
			* Зарезервировано и пока не используется
			* Устанавливает флаг "Модифицирован".
			* @param Boolean $is_unsigned
		*/
		public function setIsUnsigned($is_unsigned) {
			$this->is_unsigned = (bool) $is_unsigned;
			$this->setIsUpdated();
		}

		/**
			* Установить идентификатор типа
			* Устанавливает флаг "Модифицирован".
			* @param String $data_type идентификатор типа
			* @return Boolean true, если удалось установить, false - если идентификатор не поддерживается
		*/
		public function setDataType($data_type) {
			if(self::isValidDataType($data_type)) {
				$this->data_type = $data_type;
				$this->setIsUpdated();
				return true;
			} else {
				return false;
			}
		}


		/**
			* Загружает необходимые данные для формирования объекта umiFieldType из БД.
			* @return Boolean true в случае успеха
		*/
		protected function loadInfo($row = false) {
			if($row === false) {
				$sql = "SELECT id, name, data_type, is_multiple, is_unsigned FROM cms3_object_field_types WHERE id = '{$this->id}'";
				$result = l_mysql_query($sql);

				if($err = l_mysql_error()) {
					throw new coreException($err);
					return false;
				}
			
				$row = mysql_fetch_row($result);
			}

			if(list($id, $name, $data_type, $is_multiple, $is_unsigned) = $row) {
				if(!self::isValidDataType($data_type)) {
					throw new coreException("Wrong data type given for filed type #{$this->id}");
					return false;
				}

				$this->name = $name;
				$this->data_type = $data_type;
				$this->is_multiple= (bool) $is_multiple;
				$this->is_unsigned = (bool) $is_unsigned;

				return true;
			} else {
				return false;
			}
		}

		/**
			* Сохранить все модификации объекта в БД.
			* @return Boolean true в случае успеха
		*/
		protected function save() {
			$name = l_mysql_real_escape_string($this->name);
			$data_type = l_mysql_real_escape_string($this->data_type);
			$is_multiple = (int) $this->is_multiple;
			$is_unsigned = (int) $this->is_unsigned;

			$sql = "UPDATE cms3_object_field_types SET name = '{$name}', data_type = '{$data_type}', is_multiple = '{$is_multiple}', is_unsigned = '{$is_unsigned}' WHERE id = '{$this->id}'";
			l_mysql_query($sql);
			
			cacheFrontend::getInstance()->flush();

			if($err = l_mysql_error()) {
				throw new coreException($err);
				return false;
			} else {
				return true;
			}
		}
	}


/**
	* Этот класс служит для управления свойствами поля
*/
	class umiField extends umiEntinty implements iUmiEntinty, iUmiField {
		private $name, $title, $is_locked = false, $is_inheritable = false, $is_visible = true;
		private  $field_type_id, $guide_id, $isRequired, $restrictionId, $sortable = false;
		private $is_in_search = true, $is_in_filter = true, $tip = NULL, $is_system;
		protected $store_type = "field";


		/**
			* Получить имя поля (строковой идентификатор)
			* @return String имя поля (строковой идентификатор)
		*/
		public function getName() {
			return $this->name;
		}

		/**
			* Получить название поля
			* @return String название поля
		*/
		public function getTitle() {
			return $this->translateLabel($this->title);
		}

		/**
			* Узнать, заблокировано ли поле на изменение свойств
			* @return Boolean true если поле заблокировано
		*/
		public function getIsLocked() {
			return $this->is_locked;
		}

		/**
			* Узнать, наследуется ли значение поля. Зарезервировано, но пока не используется.
			* @return Boolean true если поле наследуется
		*/
		public function getIsInheritable() {
			return $this->is_inheritable;
		}

		/**
			* Узнать видимость поля для пользователя
			* @return Boolean true если поле видимое для пользователя
		*/
		public function getIsVisible() {
			return $this->is_visible;
		}

		/**
			* Получить id типа данных поля (см. класс umiFieldType)
			* @return Integer id типа данных поля
		*/
		public function getFieldTypeId() {
			return $this->field_type_id;
		}

		/**
			* Получить тип данных поля (экземпляр класса umiFieldType)
			* @return umiFieldType экземпляр класса umiFieldType, соответствующий полю, либо false в случае неудачи
		*/
		public function getFieldType() {
			return umiFieldTypesCollection::getInstance()->getFieldType($this->field_type_id);
		}

		/**
			* Получить id справочника, с которым связано поле (Справочник - это тип данных)
			* @return Integer id справочника, либо NULL, если полю не связано со справочником
		*/
		public function getGuideId() {
			return $this->guide_id;
		}

		/**
			* Узнать, индексируется ли поле для поиска
			* @return Boolean true если поле индексируется
		*/
		public function getIsInSearch() {
			return $this->is_in_search;
		}

		/**
			* Узнать, может ли поле учавствать в фильтрах
			* @return Boolean true если поле может учавствать в фильтрах
		*/
		public function getIsInFilter() {
			return $this->is_in_filter;
		}

		/**
			* Получить подсказку (короткую справку) для поля.
			* @return String подсказка (короткая справка) для поля
		*/
		public function getTip() {
			return $this->tip;
		}

		/**
		* Узнать, является ли поле системным
		*
		* @return Boolean
		*/
		public function getIsSystem() {
			return $this->is_system;
		}

		/**
		* Указать будет ли поле системным
		*
		* @param Boolean $isSystem true, если системное, иначе false
		*/
		public function setIsSystem($isSystem = false) {
			$this->is_system = (bool) $isSystem;
		}


		/**
			* Задать новое имя поля (строковой идентификатор).
			* Устанавливает флаг "Модифицирован".
			* @param String $name имя поля
		*/
		public function setName($name) {
			//$name = str_replace("-", "_", $name);
			$name = umiHierarchy::convertAltName($name, "_");
			$this->name = umiObjectProperty::filterInputString($name);
			if(!strlen($this->name)) $this->name = '_';
			$this->setIsUpdated();
		}


		/**
			* Задать новое описание поля.
			* Устанавливает флаг "Модифицирован".
			* @param String $title описание поля
		*/
		public function setTitle($title) {
			$title = $this->translateI18n($title, "field-");
			$this->title = umiObjectProperty::filterInputString($title);
			$this->setIsUpdated();
		}

		/**
			* Выставить полю статус "Заблокирован/Разблокирован".
			* Устанавливает флаг "Модифицирован".
			* @param Boolean $is_locked true, если заблокировано, иначе false
		*/
		public function setIsLocked($is_locked) {
			$this->is_locked = (bool) $is_locked;
			$this->setIsUpdated();
		}

		/**
			* Указать наследуется ли значение поля.
			* Зарезервировано, но пока не используется.
			* Устанавливает флаг "Модифицирован".
			* @param Boolean $is_inheritable зарезервировано, не используется
		*/
		public function setIsInheritable($is_inheritable) {
			$this->is_inheritable = (bool) $is_inheritable;
			$this->setIsUpdated();
		}

		/**
			* Указать видимо ли поле для пользователя.
			* Устанавливает флаг "Модифицирован".
			* @param Boolean $is_visible true, если видимо, иначе false
		*/
		public function setIsVisible($is_visible) {
			$this->is_visible = (bool) $is_visible;
			$this->setIsUpdated();
		}

		/**
			* Установить id типа поля (см. класс umiFieldType)
			* @param Integer $field_type_id идентификатор типа поля
		*/
		public function setFieldTypeId($field_type_id) {
			$this->field_type_id = (int) $field_type_id;
			$this->setIsUpdated();
			return true;
		}

		/**
			* Связать поле со указаным справочником (Справочник - это тип данных)
			* @param Integer $guide_id идентификтор справочника
		*/
		public function setGuideId($guide_id) {
			$this->guide_id = is_numeric($guide_id) ? (int) $guide_id : null;
			$this->setIsUpdated();
		}

		/**
			* Указать будет ли поле индексироваться для поиска.
			* Устанавливает флаг "Модифицирован".
			* @param Boolean $is_in_search true, если использовать для поиска, иначе false
		*/
		public function setIsInSearch($is_in_search) {
			$this->is_in_search = (bool) $is_in_search;
			$this->setIsUpdated();
		}

		/**
			* Указать может ли поле учавствовать в фильтрах.
			* Устанавливает флаг "Модифицирован".
			* @param Boolean $is_in_filter true, если использовать в фильтрах, иначе false
		*/
		public function setIsInFilter($is_in_filter) {
			$this->is_in_filter = (bool) $is_in_filter;
			$this->setIsUpdated();
		}

		/**
			* Установить новую подсказку (короткую справку) для поля.
			* Устанавливает флаг "Модифицирован".
			* @param String $tip подсказка
		*/
		public function setTip($tip) {
			$this->tip = umiObjectProperty::filterInputString($tip);
			$this->setIsUpdated();
		}

		/**
			* Проверить, является ли поле обязательным для заполнения
			* @return Boolean true, если поле обязательно для заполнения, иначе false
		*/
		public function getIsRequired() {
			return $this->isRequired;
		}

		/**
			* Установить, что поле является обязательным для заполнения
			* @param Boolean $isRequired true, если поле обязательно для заполнения, иначе false
		*/
		public function setIsRequired($isRequired = false) {
			$this->isRequired = (bool) $isRequired;
			$this->setIsUpdated();
		}

		/**
			* Получить идентификатор формата значение (restriction), по которому валидируется значение поля
			* @return Integer идентификатор формата значение (restriction) (класс baseRestriction и потомки)
		*/
		public function getRestrictionId() {
			return $this->restrictionId;
		}

		/**
			* Изменить id restriction'а, по которому валидируется значение поля
			* @param Integer|Boolean $restrictionId = false id рестрикшена, либо false
		*/
		public function setRestrictionId($restrictionId = false) {
			$this->restrictionId = (int) $restrictionId;
		}

		/**
			* Проверить, является ли поле сортируемым
			* @return Boolean состояние сортировки
		*/
		public function getIsSortable() {
			return $this->sortable;
		}

		/**
			* Установить поле сортируемым
			* @param Boolean $sortable = false флаг сортировки
		*/
		public function setIsSortable($sortable = false) {
			$this->sortable = (bool) $sortable;
		}

		/**
		* Получить идентификатор типа данных
		* @return String идентификатор типа данных
		*/
		public function getDataType() {
			$fieldTypes = umiFieldTypesCollection::getInstance();
			return $fieldTypes->getFieldType($this->field_type_id)->getDataType();
		}

		/**
			* Загружает необходимые данные для формирования объекта umiField из БД.
			* @return Boolean true в случае успеха
		*/
		protected function loadInfo($row = false) {
			if($row === false) {
				$sql = "SELECT id, name, title, is_locked, is_inheritable, is_visible, field_type_id, guide_id, in_search, in_filter, tip, is_required, sortable, is_system, restriction_id FROM cms3_object_fields WHERE id = '{$this->id}'";

				$result = l_mysql_query($sql);

				$row = mysql_fetch_row($result);
			}

			if(list($id, $name, $title, $is_locked, $is_inheritable, $is_visible, $field_type_id, $guide_id, $in_search, $in_filter, $tip, $is_required, $sortable, $is_system, $restrictionId) = $row) {
				$this->name = $name;
				$this->title = $title;
				$this->is_locked = (bool) $is_locked;
				$this->is_inheritable = (bool) $is_inheritable;
				$this->is_visible = (bool) $is_visible;
				$this->field_type_id = (int) $field_type_id;
				$this->guide_id = $guide_id;
				$this->is_in_search = (bool) $in_search;
				$this->is_in_filter = (bool) $in_filter;
				$this->tip = (string) $tip;
				$this->isRequired = (bool) $is_required;
				$this->sortable = (bool) $sortable;
				$this->is_system = (bool) $is_system;
				$this->restrictionId = (int) $restrictionId;
			} else {
				return false;
			}
		}

		/**
			* Сохранить все модификации объекта в БД.
			* @return Boolean true в случае успеха
		*/
		protected function save() {
			$name = l_mysql_real_escape_string($this->name);
			$title = l_mysql_real_escape_string($this->title);
			$is_locked = (int) $this->is_locked;
			$is_inheritable = (int) $this->is_inheritable;
			$is_visible = (int) $this->is_visible;
			$field_type_id = (int) $this->field_type_id;
			$guide_id = $this->guide_id ? (int) $this->guide_id : 'NULL';
			$in_search = (int) $this->is_in_search;
			$in_filter = (int) $this->is_in_filter;
			$tip = l_mysql_real_escape_string($this->tip);
			$isRequired = (int) $this->isRequired;
			$sortable = (int) $this->sortable;
			$restrictionId = (int) $this->restrictionId;
			$is_system = (int) $this->is_system;
			$restrictionSql = $restrictionId ? ", restriction_id = '{$restrictionId}'" : ", restriction_id = NULL";

			$sql = "UPDATE cms3_object_fields SET name = '{$name}', title = '{$title}', is_locked = '{$is_locked}', is_inheritable = '{$is_inheritable}', is_visible = '{$is_visible}', field_type_id = '{$field_type_id}', guide_id = {$guide_id}, in_search = '{$in_search}', in_filter = '{$in_filter}', tip = '{$tip}', is_required = '{$isRequired}', sortable = '{$sortable}', is_system = '{$is_system}' {$restrictionSql} WHERE id = '{$this->id}'";

			l_mysql_query($sql);
			cacheFrontend::getInstance()->flush();

			return true;
		}
	}


/**
	* Этот класс реализует объединение полей в именованные группы.
*/
	class umiFieldsGroup extends umiEntinty implements iUmiEntinty, iUmiFieldsGroup {
		private	$name, $title,
			$type_id, $ord,
			$is_active = true, $is_visible = true, $is_locked = false,

			$autoload_fields = false,

			$fields = Array();
		
		protected $store_type = "fields_group";

		/**
			* Получить строковой id группы
			* @return String строковой id группы
		*/
		public function getName() {
			return $this->name;
		}

		/**
			* Получить название группы
			* @return String название группы в текущей языковой версии
		*/
		public function getTitle() {
			return $this->translateLabel($this->title);
		}

		/**
			* Получить id типа данных, к которому относится группа полей
			* @return Integer id типа данных (класс umiObjectType)
		*/
		public function getTypeId() {
			return $this->type_id;
		}

		/**
			* Получить порядковый номер группы, по которому она сортируется в рамках типа данных
			* @return Integer порядковый номер
		*/
		public function getOrd() {
			return $this->ord;
		}

		/**
			* Узнать, активна ли группа полей
			* @return Boolean значение флага активности
		*/
		public function getIsActive() {
			return $this->is_active;
		}

		/**
			* Узнать, видима ли группа полей
			* @return Boolean значение флага видимости
		*/
		public function getIsVisible() {
			return $this->is_visible;
		}

		/**
			* Узнать, заблокирована ли группа полей (разработчиком)
			* @return Boolean значение флага блокировка
		*/
		public function getIsLocked() {
			return $this->is_locked;
		}

		/**
			* Изменить строковой id группы на $name
			* @param String $name новый строковой id группы полей
		*/
		public function setName($name) {
			$this->name = umiObjectProperty::filterInputString($name);
			$this->setIsUpdated();
		}

		/**
			* Изменить название группы полей
			* @param $title новое название группы полей
		*/
		public function setTitle($title) {
			$title = $this->translateI18n($title, "fields-group");
			$this->title = umiObjectProperty::filterInputString($title);
			$this->setIsUpdated();
		}

		/**
			* Изменить тип данных, которому принадлежит группа полей
			* @param Integer $type_id id нового типа данных (класс umiObjectType)
			* @return Boolean true, если такое изменение возможно, иначе false
		*/
		public function setTypeId($type_id) {
			$types = umiObjectTypesCollection::getInstance();
			if($types->isExists($type_id)) {
				$this->type_id = $type_id;
				return true;
			} else {
				return false;
			}
		}

		/**
			* Установить новое значение порядка сортировки
			* @param Integer $ord новый порядковый номер
		*/
		public function setOrd($ord) {
			$this->ord = $ord;
			$this->setIsUpdated();
		}

		/**
			* Изменить активность группы полей
			* @param Boolean $is_active новое значение флага активности
		*/
		public function setIsActive($is_active) {
			$this->is_active = (bool) $is_active;
			$this->setIsUpdated();
		}

		/**
			* Изменить видимость группы полей
			* @param Boolean $is_visible новое значение флага видимости
		*/
		public function setIsVisible($is_visible) {
			$this->is_visible = (bool) $is_visible;
			$this->setIsUpdated();
		}

		/**
			* Изменить стостояние блокировки группы полей
			* @param Boolean $is_locked новое значение флага блокировки
		*/
		public function setIsLocked($is_locked) {
			$this->is_locked = (bool) $is_locked;
			$this->setIsUpdated();
		}
		protected function loadInfo($row = false) {
			if($row === false) {
				$sql = "SELECT id, name, title, type_id, is_active, is_visible, is_locked, ord FROM cms3_object_field_groups WHERE id = '{$this->id}'";
				$result = l_mysql_query($sql);

				if($err = l_mysql_error()) {
					throw new coreException($err);
					return false;
				}
				
				$row = mysql_fetch_row($result);
			}

			if(list($id, $name, $title, $type_id, $is_active, $is_visible, $is_locked, $ord) = $row) {
				if(!umiObjectTypesCollection::getInstance()->isExists($type_id)) {
					return false;
				}

				$this->name = $name;
				$this->title = $title;
				$this->type_id = $type_id;
				$this->is_active = (bool) $is_active;
				$this->is_visible = (bool) $is_visible;
				$this->is_locked = (bool) $is_locked;
				$this->ord = (int) $ord;

				if($this->autoload_fields) {
					return $this->loadFields();
				} else {
					return true;
				}
			} else {
				return false;
			}
		}


		protected function save() {
			$name = l_mysql_real_escape_string($this->name);
			$title = l_mysql_real_escape_string($this->title);
			$type_id = (int) $this->type_id;
			$is_active = (int) $this->is_active;
			$is_visible = (int) $this->is_visible;
			$ord = (int) $this->ord;
			$is_locked = (int) $this->is_locked;

			$sql = "UPDATE cms3_object_field_groups SET name = '{$name}', title = '{$title}', type_id = '{$type_id}', is_active = '{$is_active}', is_visible = '{$is_visible}', ord = '{$ord}', is_locked = '{$is_locked}' WHERE id = '{$this->id}'";
			$result = l_mysql_query($sql);

			if($err = l_mysql_error()) {
				throw new coreException($err);
				return false;
			} else {
				return true;
			}
		}

		/**
			* Не используйте этот метод в прикладном коде.
		*/
		public function loadFields($rows = false) {
			$fields = umiFieldsCollection::getInstance();

			if($rows === false) {
				$sql = "SELECT cof.id, cof.name, cof.title, cof.is_locked, cof.is_inheritable, cof.is_visible, cof.field_type_id, cof.guide_id, cof.in_search, cof.in_filter, cof.tip, cof.is_required FROM cms3_fields_controller cfc, cms3_object_fields cof WHERE cfc.group_id = '{$this->id}' AND cof.id = cfc.field_id ORDER BY cfc.ord ASC";
				$result = l_mysql_query($sql);

				if($err = l_mysql_error()) {
					throw new coreException($err);
					return false;
				}

				while(list($field_id) = $row = mysql_fetch_row($result)) {
					if($field = $fields->getField($field_id, $row)) {
						$this->fields[$field_id] = $field;
					}
				}

			} else {
				foreach($rows as $row) {
					list($field_id) = $row;
					if($field = $fields->getField($field_id, $row)) {
						$this->fields[$field_id] = $field;
					}
				}
			}
		}

		/**
			* Получить список всех полей в группе
			* @return Array массив из объектов umiField
		*/
		public function getFields() {
			return $this->fields;
		}

		private function isLoaded($field_id) {
			return (bool) array_key_exists($field_id, $this->fields);
		}

		/**
			* Присоединить к группе еще одно поле
			* @param Integer $field_id id присоединяемого поля
			* @param Boolean $ignor_loaded если true, то можно будет добавлять уже внесенные в эту группу поля
		*/
		public function attachField($field_id, $ignore_loaded = false) {
			if($this->isLoaded($field_id) && !$ignore_loaded) {
				return true;
			} else {
				$field_id = (int) $field_id;

				$sql = "SELECT MAX(ord) FROM cms3_fields_controller WHERE group_id = '{$this->id}'";
				$result = l_mysql_query($sql);

				if($err = l_mysql_error()) {
					throw new coreException($err);
					return false;
				}

				list($ord) = mysql_fetch_row($result);
				$ord += 5;

				$sql = "INSERT INTO cms3_fields_controller (field_id, group_id, ord) VALUES('{$field_id}', '{$this->id}', '{$ord}')";
				l_mysql_query($sql);

				if($err = l_mysql_error()) {
					throw new coreException($err);
					return false;
				}
				
				cacheFrontend::getInstance()->flush();

				$fields = umiFieldsCollection::getInstance();
				$field = $fields->getField($field_id);
				$this->fields[$field_id] = $field;
				
				$this->fillInContentTable($field_id);
			}
		}
		
		
		protected function fillInContentTable($field_id) {
			$type_id = $this->type_id;
		
			$sql = "INSERT INTO cms3_object_content (obj_id, field_id, int_val, varchar_val, text_val, rel_val, tree_val, float_val) SELECT id, {$field_id}, NULL, NULL, NULL, NULL, NULL, NULL FROM cms3_objects WHERE type_id = {$type_id}";
			l_mysql_query($sql);
			
			if($err = l_mysql_error()) {
				throw new coreException($err);
			}
			
		}

		/**
			* Вывести поле из группы полей.
			* При этом поле физически не удаляется, так как может одновременно фигурировать в разный группах полей разных типов данных.
			* @param Integer $field_id id поля (класс umiField)
			* @return Boolean результат операции
		*/
		public function detachField($field_id) {
			if($this->isLoaded($field_id)) {
				$field_id = (int) $field_id;

				$sql = "DELETE FROM cms3_fields_controller WHERE field_id = '{$field_id}' AND group_id = '{$this->id}'";
				l_mysql_query($sql);

				if($err = l_mysql_error()) {
					throw new coreException($err);
					return false;
				}

				unset($this->fields[$field_id]);

				$sql = "SELECT COUNT(*) FROM cms3_fields_controller WHERE field_id = '{$field_id}'";
				$result = l_mysql_query($sql);

				if($err = l_mysql_error()) {
					throw new coreException($err);
					return false;
				}
				
				cacheFrontend::getInstance()->flush();

				if(list($c) = mysql_fetch_row($result)) {
					return ($c == 0) ? umiFieldsCollection::getInstance()->delField($field_id) : true;
				} else return false;

				return true;
			} else {
				return false;
			}
		}

		/**
			* Переместить поле $field_id после поля $after_field_id в группе $group_id
			* @param Integer $field_id id перемещаемого поля
		 	* @param Integer $after_field_id id поля, после которого нужно расположить перемещаемое поле
		 	* @param Integer $group_id id группы полей, в которой производятся перемещения
		 	* @param Boolean $is_last переместить в конец
		 	* @return Boolean результат операции
		*/
		public function moveFieldAfter($field_id, $after_field_id, $group_id, $is_last) {
			if($after_field_id == 0) {
				$neword = 0;
			} else {
				$sql = "SELECT ord FROM cms3_fields_controller WHERE group_id = '{$group_id}' AND field_id = '{$after_field_id}'";
				$result = l_mysql_query($sql);

				if($err = l_mysql_error()) {
					throw new coreException($err);
					return false;
				} else {
					list($neword) = mysql_fetch_row($result);
				}
			}

			if($is_last) {
				$sql = "UPDATE cms3_fields_controller SET ord = (ord + 1) WHERE group_id = '{$this->id}' AND ord >= '{$neword}'";

				l_mysql_query($sql);

				if($err = l_mysql_error()) {
					throw new coreException($err);
					return false;
				}
			} else {
				$sql = "SELECT MAX(ord) FROM cms3_fields_controller WHERE group_id = '{$group_id}'";
				$result = l_mysql_query($sql);

				if($err = l_mysql_error()) {
					throw new coreException($err);
					return false;
				}

				list($neword) = mysql_fetch_row($result);
				++$neword;
			}

			$sql = "UPDATE cms3_fields_controller SET ord = '{$neword}', group_id = '$group_id' WHERE group_id = '{$this->id}' AND field_id = '{$field_id}'";
			l_mysql_query($sql);
			
			cacheFrontend::getInstance()->flush();

			if($err = l_mysql_error()) {
				throw new coreException($err);
				return false;
			} else {
				return true;
			}
		}

		public function commit() {
			parent::commit();
			cacheFrontend::getInstance()->flush();
		}
		
		/**
			* Получить список всех групп с названием $name вне зависимости от типа данных
			* @param String $name название группы полей
			* @return Array массив из объектов umiFieldsGroup
		*/
		public static function getAllGroupsByName($name) {
			if($name) {
				$name = l_mysql_real_escape_string($name);
			} else {
				return false;
			}
			
			$sql = "SELECT `id` FROM `cms3_object_field_groups` WHERE `name` = '{$name}'";
			$result = l_mysql_query($sql);
			
			$groups = Array();
			while(list($groupId) = mysql_fetch_row($result)) {
				$group = new umiFieldsGroup($groupId);
				if($group instanceof umiFieldsGroup) {
					$groups[] = $group;
				}
			}
			return $groups;
		}
	};


/**
	* Этот класс служит для управления свойствами типа данных
*/
	class umiObjectType extends umiEntinty implements iUmiEntinty, iUmiObjectType {
		private $name, $parent_id, $is_locked = false;
		private $field_groups = Array(), $field_all_groups = Array();
		private $is_guidable = false, $is_public = false, $hierarchy_type_id;
		private $sortable = false;
		private $guid = null;
		protected $store_type = "object_type";

		/**
			* Получить название типа.
			* @return String название типа
		*/
		public function getName() {
			return $this->translateLabel($this->name);
		}

		/**
			* Изменить название типа.
			* @param String $name новое название типа данных
		*/
		public function setName($name) {
			$name = $this->translateI18n($name, "object-type-");
			$this->name = $name;
			$this->setIsUpdated();
		}

		/**
			* Узнать, заблокирован ли тип данных. Если тип данных заблокирован, то его нельзя удалить из системы.
			* @return Boolean true если тип данных заблокирован
		*/
		public function getIsLocked() {
			return $this->is_locked;
		}

		/**
			* Изменить флаг блокировки у типа данных. Если тип данных заблокирован, его нельзя будет удалить.
			* @param Boolean $is_locked флаг блокировки
		*/
		public function setIsLocked($is_locked) {
			$this->is_locked = (bool) $is_locked;
			$this->setIsUpdated();
		}

		/**
			* Получить id родительского типа данных, от которого унаследованы группы полей и поля
			* @return Integer id родительского типа данных
		*/
		public function getParentId() {
			return $this->parent_id;
		}

		/**
			* Узнать, помечен ли тип данных как справочник.
			* @return Boolean true, если тип данных помечен как справочник
		*/
		public function getIsGuidable() {
			return $this->is_guidable;
		}

		/**
			* Изменить флаг "Справочник" у типа данных.
			* @param Boolean $is_guidable новое значение флага "Справочник"
		*/
		public function setIsGuidable($is_guidable) {
			$this->is_guidable = (bool) $is_guidable;
			$this->setIsUpdated();
		}

		/**
			* Установить флаг "Общедоступный" для справочника. Не имеет значение, если тип данных не является справочником.
			* @return Boolean true если тип данных общедоступен
		*/
		public function getIsPublic() {
			return $this->is_public;
		}

		/**
			* Изменить значение флага "Общедоступен" для типа данных. Не имеет значения, если тип данных не является справочником.
			* @param Boolean $is_public новое значение флага "Общедоступен"
		*/
		public function setIsPublic($is_public) {
			$this->is_public = (bool) $is_public;
			$this->setIsUpdated();
		}

		/**
			* Получить id базового типа, к которому привязан тип данных (класс umiHierarchyType).
			* @return Integer id базового типа данных (класс umiHierarchyType)
		*/
		public function getHierarchyTypeId() {
			return $this->hierarchy_type_id;
		}

		/**
			* Проверить, являются ли объекты этого типа сортируемыми
			* @return Boolean состояние сортировки
		*/
		public function getIsSortable() {
			return $this->sortable;
		}

		/**
			* Установить тип сортируемым
			* @param Boolean $sortable = false флаг сортировки
		*/
		public function setIsSortable($sortable = false) {
			$this->sortable = (bool) $sortable;
		}

		/**
			* Изменить базовый тип (класс umiHierarchyType), к которому привязан тип данных.
			* @param Integer $hierarchy_type_id новый id базового типа (класс umiHierarchyType)
		*/
		public function setHierarchyTypeId($hierarchy_type_id) {
			$this->hierarchy_type_id = (int) $hierarchy_type_id;
			$this->setIsUpdated();
		}

		/**
			* Добавить в тип данных новую группу полей (класс umiFieldsGroup)
			* @param String $name - строковой идентификатор группы полей
			* @param String $title - название группы полей
			* @param Boolean $is_active=true флаг активности группы полей (всегда true)
			* @param Boolean $is_visible=true видимость группы полей
			* @return Integer id созданной группы полей
		*/
		public function addFieldsGroup($name, $title, $is_active = true, $is_visible = true) {
			if($group = $this->getFieldsGroupByName($name)) {
				return $group->getId();
			}

			$sql = "SELECT MAX(ord) FROM cms3_object_field_groups WHERE type_id = '{$this->id}'";
			$result = l_mysql_query($sql);

			if($err = l_mysql_error()) {
				throw new coreException($err);
				return false;
			}

			if(list($ord) = mysql_fetch_row($result)) {
				$ord = ((int) $ord) + 5;
			} else {
				$ord = 1;
			}

			$sql = "INSERT INTO cms3_object_field_groups (type_id, ord) VALUES('{$this->id}', '{$ord}')";
			l_mysql_query($sql);

			if($err = l_mysql_error()) {
				throw new coreException($err);
				return false;
			}

			$field_group_id = l_mysql_insert_id();

			$field_group = new umiFieldsGroup($field_group_id);
			$field_group->setName($name);
			$field_group->setTitle($title);
			$field_group->setIsActive($is_active);
			$field_group->setIsVisible($is_visible);
			$field_group->commit();

			$this->field_groups[$field_group_id] = $field_group;
			$this->field_all_groups[$field_group_id] = $field_group;


			$child_types = umiObjectTypesCollection::getInstance()->getSubTypesList($this->id);
			$sz = sizeof($child_types);
			for($i = 0; $i < $sz; $i++) {
				$child_type_id = $child_types[$i];

				if($type = umiObjectTypesCollection::getInstance()->getType($child_type_id)) {
					$type->addFieldsGroup($name, $title, $is_active, $is_visible);
				} else {
					throw new coreException("Can't load object type #{$child_type_id}");
				}
			}

			cacheFrontend::getInstance()->flush();

			return $field_group_id;
		}

		/**
			* Удалить группу полей (класс umiFieldsGroup).
			* @param Integer $field_group_id id группы, которую необходимо удалить
			* @return Boolean true, если удаление прошло успешно
		*/
		public function delFieldsGroup($field_group_id) {
			if($this->isFieldsGroupExists($field_group_id)) {
				$field_group_id = (int) $field_group_id;
				$sql = "DELETE FROM cms3_object_field_groups WHERE id = '{$field_group_id}'";
				l_mysql_query($sql);

				if($err = l_mysql_error()) {
					throw new coreException($err);
					return false;
				}

				unset($this->field_groups[$field_group_id]);

				cacheFrontend::getInstance()->flush();
				return true;

			} else {
				return false;
			}
		}

		/**
			* Получить группу полей (класс umiFieldsGroup) по ее строковому идентификатору
			* @param String $field_group_name строковой идентификатор группы полей
			* @param String $allow_disabled разрешить получать не активные группы
			* @return umiFieldsGroup|Boolean группы полей (экземпляр класса umiFieldsGroup), либо false
		*/
		public function getFieldsGroupByName($field_group_name, $allow_disabled = false) {
			$groups = $this->getFieldsGroupsList($allow_disabled);
			foreach($groups as $group_id => $group) {
				if($group->getName()  == $field_group_name) {
					return $group;
				}
			}
			return false;
		}

		/**
			* Получить группу полей (класс umiFieldsGroup) по ее id
			* @param Integer $field_group_id id группы полей
			* @param Boolean $ignore_is_active  false, если поиск ведется только среди активных групп
			* @return umiFieldsGroup|Boolean группы полей (экземпляр класса umiFieldsGroup), либо false
		*/
		public function getFieldsGroup($field_group_id, $ignore_is_active = false) {
			if($this->isFieldsGroupExists($field_group_id)) {
				if ($ignore_is_active) {
					return $this->field_all_groups[$field_group_id];
				} else {
					if (array_key_exists($field_group_id, $this->field_groups)) {
						return $this->field_groups[$field_group_id];
					} else {
						return false;
					}
				}
			} else {
				return false;
			}
		}

		/**
			* Получить список всех групп полей у типа данных
			* @param Boolean $showDisabledGroups = false включить в результат неактивные группы полей
			* @return Array массив состоящий из экземпляров класса umiFieldsGroup
		*/
		public function getFieldsGroupsList($showDisabledGroups = false) {
			return $showDisabledGroups ? $this->field_all_groups : $this->field_groups;
		}


		/**
			* Проверить, существует ли у типа данных группа полей с id $field_group_id
			* @param Integer $field_group_id id группы полей
			* @return Boolean true, если группа полей существует у этого типа данных
		*/
		private function isFieldsGroupExists($field_group_id) {
			if(!$field_group_id) {
				return false;
			} else {
				return (bool) array_key_exists($field_group_id, $this->field_all_groups);
			}
		}

		/**
			* Загрузить информацию о типе данных из БД
		*/
		protected function loadInfo() {
			$sql = "SELECT name, parent_id, is_locked, is_guidable, is_public, hierarchy_type_id, sortable, guid FROM cms3_object_types WHERE id = '{$this->id}'";
			$result = l_mysql_query($sql);

			if(list($name, $parent_id, $is_locked, $is_guidable, $is_public, $hierarchy_type_id, $sortable, $guid) = mysql_fetch_row($result)) {
				$this->name = $name;
				$this->parent_id = (int) $parent_id;
				$this->is_locked = (bool) $is_locked;
				$this->is_guidable = (bool) $is_guidable;
				$this->is_public = (bool) $is_public;
				$this->hierarchy_type_id = (int) $hierarchy_type_id;
				$this->sortable = (bool) $sortable;
				$this->guid = $guid;

				return $this->loadFieldsGroups();
			} else {
				return false;
			}
		}

		/**
			* Загрузить группы полей и поля для типа данных из БД
			* @return Boolean true, если не возникло ошибок
		*/
		private function loadFieldsGroups() {
			$sql = <<<SQL
SELECT 
   ofg.id as groupId, cof.id, cof.name, cof.title, cof.is_locked, cof.is_inheritable, cof.is_visible, cof.field_type_id, cof.guide_id, cof.in_search, cof.in_filter, cof.tip, cof.is_required, cof.sortable, cof.is_system, cof.restriction_id
      FROM cms3_object_field_groups ofg, cms3_fields_controller cfc, cms3_object_fields cof
         WHERE ofg.type_id = '{$this->id}' AND cfc.group_id = ofg.id AND cof.id = cfc.field_id
            ORDER BY ofg.ord ASC, cfc.ord ASC
SQL;

			$result = l_mysql_query($sql);
			$fields = Array();
			while(list($group_id, $id, $name, $title, $is_locked, $is_inheritable, $is_visible, $field_type_id, $guide_id, $in_search, $in_filter, $tip, $is_required, $is_system, $sortable, $restriction_id) = mysql_fetch_row($result)) {
				if(!isset($fields[$group_id]) || !is_array($fields[$group_id])) {
					$fields[$group_id] = Array();
				}
				$fields[$group_id][] = Array($id, $name, $title, $is_locked, $is_inheritable, $is_visible, $field_type_id, $guide_id, $in_search, $in_filter, $tip, $is_required, $is_system, $sortable, $restriction_id);
			}

			$sql = "SELECT id, name, title, type_id, is_active, is_visible, is_locked, ord FROM cms3_object_field_groups WHERE type_id = '{$this->id}' ORDER BY ord ASC";
			$result = l_mysql_query($sql);

			while(list($field_group_id,,,,$isActive) = $row = mysql_fetch_row($result)) {
				$field_group = new umiFieldsGroup($field_group_id, $row);

				if(!isset($fields[$field_group_id])) {
					$fields[$field_group_id] = Array();
				}
				$field_group->loadFields($fields[$field_group_id]);
				$this->field_all_groups[$field_group_id] = $field_group;
				if($isActive) {
					$this->field_groups[$field_group_id] = $field_group;
				}
			}
			return true;
		}

		/**
			* Сохранить в БД внесенные изменения
		*/
		protected function save() {
			$name = umiObjectProperty::filterInputString($this->name);
			$guid = umiObjectProperty::filterInputString($this->guid);
			$parent_id = (int) $this->parent_id;
			$is_locked = (int) $this->is_locked;
			$is_guidable = (int) $this->is_guidable;
			$is_public = (int) $this->is_public;
			$hierarchy_type_id = (int) $this->hierarchy_type_id;
			$sortable = (int) $this->sortable;

			$sql = "UPDATE cms3_object_types SET name = '{$name}', guid = '{$guid}', parent_id = '{$parent_id}', is_locked = '{$is_locked}', is_guidable = '{$is_guidable}', is_public = '{$is_public}', hierarchy_type_id = '{$hierarchy_type_id}', sortable = '{$sortable}' WHERE id = '{$this->id}'";
			$result = l_mysql_query($sql);

			cacheFrontend::getInstance()->flush();

			if($err = l_mysql_error()) {
				throw new coreException($err);
				return false;
			} else {
				return false;
			}
		}

		/**
			* Изменить порядок следования группы полей
			* @param Integer $group_id идентификатор группы полей, порядоковый номер которой мы хотим изменить
			* @param Integer $neword новый порядковый номер группы полей
			* @param Boolean $is_last хотим ли сделать группу полей последней в списке
			* @return Boolean true, если порядок успешно изменен, false в противном случае
		*/
		public function setFieldGroupOrd($group_id, $neword, $is_last) {
			$neword = (int) $neword;
			$group_id = (int) $group_id;

			if(!$is_last) {
				$sql = "SELECT type_id FROM cms3_object_field_groups WHERE id = '{$group_id}'";
				$result = l_mysql_query($sql);

				if($err = l_mysql_error()) {
					throw new coreException($err);
					return false;
				}


				if(!(list($type_id) = mysql_fetch_row($result))) {
					return false;
				}

				$sql = "UPDATE cms3_object_field_groups SET ord = (ord + 1) WHERE type_id = '{$type_id}' AND ord >= '{$neword}'";
				l_mysql_query($sql);

				if($err = l_mysql_error()) {
					throw new coreException($err);
					return false;
				}
			}

			$sql = "UPDATE cms3_object_field_groups SET ord = '{$neword}' WHERE id = '{$group_id}'";
			l_mysql_query($sql);

			cacheFrontend::getInstance()->flush();

			if($err = l_mysql_error()) {
				throw new coreException($err);
				return false;
			}
			return true;
		}

		/**
			* Получить список всех полей типа данных
			* @param Boolean $returnOnlyVisibleFields=false если флаг установлен true, то метод вернет только видимые поля
			* @return Array массив, состоящий из экземпляров класса umiField
		*/
		public function getAllFields($returnOnlyVisibleFields = false) {
			$fields = Array();

			$groups = $this->getFieldsGroupsList();
			foreach($groups as $group) {
				if($returnOnlyVisibleFields) {
					if(!$group->getIsVisible()) {
						continue;
					}
				}

				$fields = array_merge($fields, $group->getFields());
			}

			return $fields;
		}

		/**
			* Получить id поля по его строковому идентификатору
			* @param String $field_name строковой идентификатор поля
			* @param Boolean $ignoreInactiveGroups true, если нужно найти поле только в активных группах
			* @return Integer|Boolean id поля, либо false если такого поля не существует
		*/
		public function getFieldId($field_name, $ignoreInactiveGroups = true) {
			$groups = $this->getFieldsGroupsList(!$ignoreInactiveGroups);
			foreach($groups as $group_id => $group) {

				$fields = $group->getFields();

				foreach($fields as $field_id => $field) {
					if($field->getName() == $field_name) {
						return $field->getId();
					}
				}
			}
			return false;
		}

		/**
			* Получить название модуля иерархического типа, если такой есть у этого типа данных
			* @return String название модуля
		*/
		public function getModule() {
			$hierarchyTypeId = $this->getHierarchyTypeId();
			$hierarchyType = umiHierarchyTypesCollection::getInstance()->getType($hierarchyTypeId);
			if($hierarchyType instanceof umiHierarchyType) {
				return $hierarchyType->getName();
			} else {
				return false;
			}
		}

		/**
			* Получить название метода иерархического типа, если такой есть у этого типа данных
			* @return String название метода
		*/
		public function getMethod() {
			$hierarchyTypeId = $this->getHierarchyTypeId();
			$hierarchyType = umiHierarchyTypesCollection::getInstance()->getType($hierarchyTypeId);
			if($hierarchyType instanceof umiHierarchyType) {
				return $hierarchyType->getExt();
			} else {
				return false;
			}
		}

		/**
		* Получить GUID
		* @return string GUID
		*/
		public function getGUID() {
			return $this->guid;
		}

		/**
		* Установить GUID
		* @deprecated
		* @throws coreException если GUID уже используется
		* @param string $guid
		*/
		public function setGUID($guid) {
			$id = umiObjectTypesCollection::getInstance()->getTypeIdByGUID($guid);
			if($id && $id != $this->id) {
				throw new coreException("GUID {$guid} already in use");
			}
			$this->guid = $guid;
			$this->setIsUpdated();
		}
	};


/**
 * Общий класс для взаимодействия с объектами системы.
 * @author lyxsus <sa@umisoft.ru>
 */
	class umiObject extends umiEntinty implements iUmiEntinty, iUmiObject {
		private $name, $type_id, $is_locked, $owner_id = false,
			$type, $properties = Array(), $prop_groups = Array(), $guid = null, $type_guid = null;
		protected $store_type = "object";

		/**
			* Получить название объекта
			* @param Boolean $translate_ignored = false
			* @return String название объекта
		*/
		public function getName($translate_ignored = false) {
			return $translate_ignored ? $this->name : $this->translateLabel($this->name);
		}

		/**
			* Получить id типа объекта
			* @return Integer id типа объекта (для класса umiObjectType)
		*/
		public function getTypeId() {
			return $this->type_id;
		}

		/**
			* Получить guid типа объекта
			* @return String guid типа объекта (для класса umiObjectType)
		*/
		public function getTypeGUID(){
			return $this->type_guid;
		}

		public function getType() {
			if(!$this->type) {
				$this->loadType();
			}
			return $this->type;
		}

		/**
			* Узнать, заблокирован ли объект. Метод зарезервирован, но не используется. Предполагается, что этот флаг будет блокировать любое изменение объекта
			* @return Boolean true если обект заблокирован
		*/
		public function getIsLocked() {
			return $this->is_locked;
		}

		/**
			* Задать новое название объекта. Устанавливает флаг "Модифицирован".
			* @param String $name
		*/
		public function setName($name) {

			$not_allowed_symbols = array(1, 2, 3, 4, 5, 6, 7, 8, 11, 12, 14, 15, 16, 17, 18, 19, 20,21, 22, 23, 24, 25, 26, 27, 28, 29, 30, 31);
			$pattern ='';
			foreach ($not_allowed_symbols as $symbol) {
				$pattern = $pattern . chr($symbol);
			}
			$name = preg_replace("/[" . $pattern . "]/isu", "", $name);

			$name = $this->translateI18n($name, "object-");
			$this->name = $name;
			$this->setIsUpdated();
		}

		/**
			* Установить новый id типа данных (класс umiObjectType) для объекта.
			* Используйте этот метод осторожно, потому что он просто переключает id типа данных.
			* Уже заполненные значения остануться в БД, но станут недоступны через API, если не переключить тип данных для объекта назад.
			* Устанавливает флаг "Модифицирован".
			* @return Boolean true всегда
		*/
		public function setTypeId($type_id) {
			if ($this->type_id !== $type_id) {
				$this->type_id = $type_id;
				$this->setIsUpdated();
			}
			return true;
		}

		/**
			* Выставить объекту статус "Заблокирован". Этот метод зарезервирован, но в настоящее время не используется.
		*/
		public function setIsLocked($is_locked) {
			if ($this->is_locked !== ((bool) $is_locked)) {
				$this->is_locked = (bool) $is_locked;
				$this->setIsUpdated();
			}
		}

		/**
			* Установить id владельца объекта. Это означает, что пользователь с id $ownerId полностью владеет этим объектом:
			* создал его, может модифицировать, либо удалить.
			* @param Integer $ownerId id нового владельца. Обязательно действительный id объекта (каждый пользователь это объект в umi)
			* @return Boolean true в случае успеха, false если $ownerId не является нормальным id для umiObject
		*/
		public function setOwnerId($ownerId) {
			if(!is_null($ownerId) and umiObjectsCollection::getInstance()->isExists($ownerId)) {
				if ($this->owner_id !== $ownerId) {
					$this->owner_id = $ownerId;
					$this->setIsUpdated();
				}
				return true;
			}
			else {
				if (!is_null($this->owner_id)) {
					$this->owner_id = NULL;
					$this->setIsUpdated();
				}
				return false;
			}
		}

		/**
			* Получить id пользователя, который владеет этим объектом
			* @return Integer id пользователя. Всегда действительный id для umiObject или NULL если не задан.
		*/
		public function getOwnerId() {
			return $this->owner_id;
		}

		/**
			* Проверить, заполены ли все необходимые поля у объекта
			* @return Boolean
		*/
		public function isFilled() {
			$fields = $this->type->getAllFields();
			foreach($fields as $field)
				if($field->getIsRequired() && is_null($this->getValue($field->getName())))
						return false;
			return true;
		}

		/**
			* Сохранить все модификации объекта в БД. Вызывает метод commit() на каждом загруженом свойстве (umiObjectProperty)
		*/
		protected function save() {
			if ($this->is_updated) {

				$name = umiObjectProperty::filterInputString($this->name);
				$guid = umiObjectProperty::filterInputString($this->guid);
				$type_id = (int) $this->type_id;
				$is_locked = (int) $this->is_locked;
				$owner_id = (int) $this->owner_id;

				$sql = "START TRANSACTION /* Updating object #{$this->id} info */";
				$result = l_mysql_query($sql);

				if($err = l_mysql_error()) {
					throw new coreException($err);
				}

				$nameSql = $name ? "'{$name}'" : "NULL";
				$sql = "UPDATE cms3_objects SET name = {$nameSql}, type_id = '{$type_id}', is_locked = '{$is_locked}', owner_id = '{$owner_id}', guid = '{$guid}' WHERE id = '{$this->id}'";
				l_mysql_query($sql);
				if($err = l_mysql_error()) {
					throw new coreException($err);
				}

				foreach($this->properties as $prop) {
					if(is_object($prop)) $prop->commit();
				}

				$sql = "COMMIT";
				l_mysql_query($sql);

				if($err = l_mysql_error()) {
					throw new coreException($err);
				}

				$this->setIsUpdated(false);

			}
			return true;
		}

		public function __construct($id, $row = false) {
			parent::__construct($id, $row);
		}

		/**
			* Загружает необходимые данные для формирования объекта. Этот метод не подгружает значения свойств.
			* Значения свойств запрашиваются по требованию
			* В случае нарушения целостности БД, когда с загружаемым объектом в базе не связан ни один тип данных, объект удаляется.
			* @return Boolean true в случае успеха
		*/
		protected function loadInfo($row = false) {

			if($row === false || count($row) < 6) {
				$sql = "SELECT o.name, o.type_id, o.is_locked, o.owner_id, o.guid as `guid`, t.guid as `type_guid` FROM cms3_objects `o`, cms3_object_types `t` WHERE o.id = '{$this->id}' and o.type_id = t.id";
				$result = l_mysql_query($sql, true);

				if($err = l_mysql_error()) {
					cacheFrontend::getInstance()->del($object->getId(), "object");
					throw new coreException($err);
					return false;
				}
				$row = mysql_fetch_row($result);
				if(!$row) {
					throw new coreException("Object #{$this->id} doesn't exists");
					return false;
				}
			}
//var_dump($sql, $this->id, $row);
			list($name, $type_id, $is_locked, $owner_id, $guid, $type_guid) = $row;
			if(!$type_id) {	//Foregin keys check failed, or manual queries made. Delete this object.
				umiObjectsCollection::getInstance()->delObject($this->id);
				return false;
			}

			$this->name = $name;
			$this->type_id = (int) $type_id;
			$this->is_locked = (bool) $is_locked;
			$this->owner_id = (int) $owner_id;
			$this->guid = $guid;
			$this->type_guid = $type_guid;
			return $this->loadType();
		}


		/**
			* Загрузить тип данных (класс umiObjectType), который описывает этот объект
		*/
		private function loadType() {
			$type = umiObjectTypesCollection::getInstance()->getType($this->type_id);

			if(!$type) {
				throw new coreException("Can't load type in object's init");
			}

			$this->type = $type;
			return $this->loadProperties();
		}

		/**
			* Подготовить внутреннеие массивы для свойств и групп свойств на основе структуры типа данных, с которым связан объект
		*/
		private function loadProperties() {
			$type = $this->type;
			$groups_list = $type->getFieldsGroupsList();
			foreach($groups_list as $group) {
				if($group->getIsActive() == false) continue;

				$fields = $group->getFields();

				$this->prop_groups[$group->getId()] = Array();

				foreach($fields as $field) {
					$this->properties[$field->getId()] = $field->getName();
					$this->prop_groups[$group->getId()][] = $field->getId();
				}
			}
		}

		/**
			* Получить свойство объекта по его строковому идентификатору
			* @param String $prop_name строковой идентификатор свойства
			* @return umiObjectProperty или NULL в случае неудачи
		*/
		public function getPropByName($prop_name) {
			$prop_name = strtolower($prop_name);

			foreach($this->properties as $field_id => $prop) {
				if(is_object($prop)) {
					if($prop->getName() == $prop_name) {
						return $prop;
					}
				} else {
					if(strtolower($prop) == $prop_name) {
						$prop = cacheFrontend::getInstance()->load($this->id . "." . $field_id, "property");
						if($prop instanceof umiObjectProperty == false) {
							$prop = umiObjectProperty::getProperty($this->id, $field_id, $this->type_id);
							cacheFrontend::getInstance()->save($prop, "property");
						}
						$this->properties[$field_id] = $prop;
						return $prop;
					}
				}
			}
			return NULL;
		}

		/**
			* Получить свойство объекта по его числовому идентификатору (просто id)
			* @param Integer $field_id id поля
			* @return umiObjectProperty или NULL в случае неудачи
		*/
		public function getPropById($field_id) {
			if(!$this->isPropertyExists($field_id)) {
				return NULL;
			} else {
				if(!is_object($this->properties)) {
					$this->properties[$field_id] = umiObjectProperty::getProperty($this->id, $field_id, $this->type_id);
				}
				return $this->properties[$field_id];
			}
		}

		/**
			* Узнать, существует ли свойство с id $field_id
			* @param Integer $field_id id поля
			* @return Boolean true, если поле существует
		*/
		public function isPropertyExists($field_id) {
			return (bool) array_key_exists($field_id, $this->properties);
		}

		/**
			* Узнать, существует ли группа полей с id $prop_group_id у объекта
			* @param Integer $prop_group_id id группы полей
			* @return Boolean true, если группа существует
		*/
		public function isPropGroupExists($prop_group_id) {
			return (bool) array_key_exists($prop_group_id, $this->prop_groups);
		}

		/**
			* Получить id группы полей по ее строковому идентификатору
			* @param String $prop_group_name Строковой идентификатор группы полей
			* @return Integer id группы полей, либо false, если такой группы не существует
		*/
		public function getPropGroupId($prop_group_name) {
			$groups_list = $this->getType()->getFieldsGroupsList();

			foreach($groups_list as $group) {
				if($group->getName() == $prop_group_name) {
					return $group->getId();
				}
			}
			return false;
		}

		/**
			* Получить группу полей по ее строковому идентификатору
			* @param String $prop_group_name Строковой идентификатор группы полей
			* @return umiFieldsGroup, либо false, если такой группы не существует
		*/
		public function getPropGroupByName($prop_group_name) {
			if($group_id = $this->getPropGroupId($prop_group_name)) {
				return $this->getPropGroupById($group_id);
			} else {
				return false;
			}
		}

		/**
			* Получить группу полей по ее id
			* @param Integer $prop_group_id id группы полей
			* @return umiFieldsGroup, либо false, если такой группы не существует
		*/
		public function getPropGroupById($prop_group_id) {
			if($this->isPropGroupExists($prop_group_id)) {
				return $this->prop_groups[$prop_group_id];
			} else {
				return false;
			}
		}


		/**
			* Получить значение свойства $prop_name объекта
			* @param String $prop_name строковой идентификатор поля
			* @param Array $params = NULL дополнительные параметры (обычно не используется)
			* @return Mixed значение поле. Тип значения зависит от типа поля. Вернет false, если свойства не существует.
		*/
		public function getValue($prop_name, $params = NULL) {
			if($prop = $this->getPropByName($prop_name)) {
				return $prop->getValue($params);
			} else {
				return false;
			}
		}

		/**
			* Установить значение свойства с $prop_name данными из $prop_value. Устанавливает флаг "Модифицирован".
			* Значение в БД изменится только когда на объекте будет вызван темод commit(), либо в деструкторе объекта
			* @param String $prop_name строковой идентификатор поля
			* @param Mixed $prop_value новое значение для поля. Зависит от типа поля
			* @return Boolean true если прошло успешно
		*/
		public function setValue($prop_name, $prop_value) {
			if($prop = $this->getPropByName($prop_name)) {
				$this->setIsUpdated();
				return $prop->setValue($prop_value);
			} else {
				return false;
			}
		}

		/*
			* Сохранить все значения в базу, если объект модификирован
		*/
		public function commit() {
			l_mysql_query("START TRANSACTION /* Saving object {$this->id} */");
			$USE_TRANSACTIONS = umiObjectProperty::$USE_TRANSACTIONS;
			umiObjectProperty::$USE_TRANSACTIONS = false;

			if($this->checkSelf()) {
				foreach($this->properties as $prop) {
					if(is_object($prop)) {
						$prop->commit();
					}
				}
			}

			parent::commit();
			l_mysql_query("COMMIT");
			umiObjectProperty::$USE_TRANSACTIONS = $USE_TRANSACTIONS;
		}

		public function checkSelf() {
			static $res;
			if($res !== null) {
				return $res;
			}

			if(!cacheFrontend::getInstance()->getIsConnected()) {
				return $res = true;
			}

			$sql = "SELECT id FROM cms3_objects WHERE id = '{$this->id}'";
			$result = l_mysql_query($sql);
			if($err = l_mysql_error()) {
				throw new coreException($err);
			}
			$res = (bool) mysql_num_rows($result);
			if(!$res) {
				cacheFrontend::getInstance()->flush();
			}
			return $res;
		}


		/**
			* Вручную установить флаг "Модифицирован"
		*/
		public function setIsUpdated($isUpdated = true) {
			umiObjectsCollection::getInstance()->addUpdatedObjectId($this->id);
			return parent::setIsUpdated($isUpdated);
		}

		/**
			* Удалить объект
		*/
		public function delete() {
			umiObjectsCollection::getInstance()->delObject($this->id);
		}

		public function __get($varName) {
			switch($varName) {
				case "id":		return $this->id;
				case "name":	return $this->getName();
				case "ownerId":	return $this->getOwnerId();
				case "typeId":	return $this->getTypeId();
				case "GUID":	return $this->getGUID();
				case "typeGUID":return $this->getTypeGUID();
				case "xlink":	return 'uobject://' . $this->id;

				default:		return $this->getValue($varName);
			}
		}

		public function __set($varName, $value) {
			switch($varName) {
				case "id":		throw new coreException("Object id could not be changed");
				case "name":	return $this->setName($value);
				case "ownerId":	return $this->setOwnerId($value);

				default:		return $this->setValue($varName, $value);
			}
		}

		public function beforeSerialize($reget = false) {
			static $types = array();
			if ($reget && isset($types[$this->type_id])) {
				$this->type = $types[$this->type_id];
			}
			else {
				$types[$this->type_id] = $this->type;
				$this->type = null;
			}
		}

		public function afterSerialize() {
			$this->beforeSerialize(true);
		}

		public function afterUnSerialize() {
			$this->getType();
		}

		public function getModule() {
			return $this->type->getModule();
		}

		public function getMethod() {
			return $this->type->getMethod();
		}

		/**
		* Получить GUID
		* @return string GUID
		*/
		public function getGUID() {
			return $this->guid;
		}

		/**
		* Установить GUID
		* @deprecated
		* @throws coreException если GUID уже используется
		* @param string $guid
		*/
		public function setGUID($guid) {
			$id = umiObjectsCollection::getInstance()->getObjectIdByGUID($guid);
			if($id && $id != $this->id) {
				throw new coreException("GUID {$guid} already in use");
			}
			$this->guid = $guid;
			$this->setIsUpdated();
		}
	}


/**
	* Этот класс-коллекция служит для управления/получения доступа к типам полей
	* Класс является синглтоном, экземпляр класса можно получить через статический метод getInstance()
*/
	class umiFieldTypesCollection extends singleton implements iSingleton, iUmiFieldTypesCollection {
		private $field_types = Array();

		protected function __construct() {
			$this->loadFieldTypes();
		}

		/**
			* Получить экземпляр коллекции
			* @return umiFieldTypesCollection экземпляр класса
		*/
		public static function getInstance($c = NULL) {
			return parent::getInstance(__CLASS__);
		}

		/**
			* Создать новый тип поля
			* @param String $name описание типа
			* @param String $data_type тип данных
			* @param Boolean $is_multiple является ли тип составным (массив значений)
			* @param Boolean $is_unsigned зарезервировано и пока не используется, рекомендуется выставлять в false
			* @return Integer идентификатор созданного типа, либо false в случае неудачи
		*/
		public function addFieldType($name, $data_type = "string", $is_multiple = false, $is_unsigned = false) {
			if(!umiFieldType::isValidDataType($data_type)) {
				throw new coreException("Not valid data type given");
				return false;
			}
			$this->disableCache();
			cacheFrontend::getInstance()->flush();

			$sql = "INSERT INTO cms3_object_field_types (data_type) VALUES('{$data_type}')";
			$result = l_mysql_query($sql);

			if($err = l_mysql_error()) {
				throw new coreException($err);
				return false;
			}

			$field_type_id = l_mysql_insert_id();

			$field_type = new umiFieldType($field_type_id);

			$field_type->setName($name);
			$field_type->setDataType($data_type);
			$field_type->setIsMultiple($is_multiple);
			$field_type->setIsUnsigned($is_unsigned);
			$field_type->commit();

			$this->field_types[$field_type_id] = $field_type;

			return $field_type_id;
		}

		/**
			* Удалить тип поля с заданным идентификатором из коллекции
			* @param Integer $field_type_id идентификатор поля
			* @return Boolean true, если удаление удалось
		*/
		public function delFieldType($field_type_id) {
			$this->disableCache();
			cacheFrontend::getInstance()->flush();

			if($this->isExists($field_type_id)) {
				$field_type_id = (int) $field_type_id;
				$sql = "DELETE FROM cms3_object_field_types WHERE id = '{$field_type_id}'";
				l_mysql_query($sql);

				if($err = l_mysql_error()) {
					throw new coreException($err);
					return false;
				}

				unset($this->field_types[$field_type_id]);
				return true;
			} else {
				return false;
			}
		}

		/**
			* Получтить экземпляр класса umiFieldType по идентификатору
			* @param Integer $field_type_id идентификатор поля
			* @return umiFieldType экземпляр класса umiFieldType, либо false в случае неудачи
		*/
		public function getFieldType($field_type_id) {
			if($this->isExists($field_type_id)) {
				return $this->field_types[$field_type_id];
			} else {
				return true;
			}
		}

		/**
			* Получтить экземпляр класса umiFieldType по типу данных
			* @param String $data_type тип данных
			* @param Boolean $multiple может ли значение поля данного типа состоять из массива значений (составной тип)
			* @return umiFieldType экземпляр класса umiFieldType, либо false в случае неудачи
		*/
		public function getFieldTypeByDataType($data_type, $multiple = false) {
			if(!strlen($data_type)) return false;

			$field_types = $this->getFieldTypesList();
			$field_type = false;

			foreach($field_types as $ftype) {
				if ($ftype->getDataType() == $data_type && $ftype->getIsMultiple() == $multiple) {
					$field_type = $ftype;
					break;
				}
			}
			return $field_type;
		}

		/**
			* Проверить, существует ли в БД тип поля с заданным идентификатором
			* @param Integer $field_type_id идентификатор типа
			* @return Boolean true, если тип поля существует в БД
		*/
		public function isExists($field_type_id) {
			return (bool) array_key_exists($field_type_id, $this->field_types);
		}

		/**
			* Загружает в коллекцию все типы полей, создает экземпляры класса umiFieldType для каждого типа
			* @return Boolean true, если удалось загрузить, либо строку - описание ошибки, в случае неудачи.
		*/
		private function loadFieldTypes() {
			$cacheFrontend = cacheFrontend::getInstance();

			$fieldTypeIds = $cacheFrontend->loadData("field_types");
			if(!is_array($fieldTypeIds)) {
				$sql = "SELECT id, name, data_type, is_multiple, is_unsigned FROM cms3_object_field_types ORDER BY name ASC";
				$result = l_mysql_query($sql);
				$fieldTypeIds = array();
				while(list($field_type_id) = $row = mysql_fetch_row($result)) {
					$fieldTypeIds[$field_type_id] = $row;
				}
				$cacheFrontend->saveData("field_types", $fieldTypeIds, 3600);
			} else $row = false;

			foreach($fieldTypeIds as $field_type_id => $row) {
				$field_type = $cacheFrontend->load($field_type_id, "field_type");
				if($field_type instanceof umiFieldType == false) {
					try {
						$field_type = new umiFieldType($field_type_id, $row);
					} catch(privateException $e) {
						continue;
					}

					$cacheFrontend->save($field_type, "field_type");
				}
				$this->field_types[$field_type_id] = $field_type;
			}

			return true;
		}

		/**
			* Возвращает список всех типов полей
			* @return Array список типов (экземпляры класса umiFieldType)
		*/
		public function getFieldTypesList() {
			return $this->field_types;
		}

		public function clearCache() {
			$keys = array_keys($this->field_types);
			foreach($keys as $key) unset($this->field_types[$key]);
			$this->field_types = array();
			$this->loadFieldTypes();
		}
	}


/**
	* Этот класс-коллекция служит для управления/получения доступа к полям
	* Класс является синглтоном, экземпляр класса можно получить через статический метод getInstance()
*/
	class umiFieldsCollection extends singleton implements iSingleton, iUmiFieldsCollection {
		private	$fields = Array();

		protected function __construct() {
		}

		/**
			* Получить экземпляр коллекции
			* @return umiFieldsCollection экземпляр класса
		*/
		public static function getInstance($c = NULL) {
			return parent::getInstance(__CLASS__);
		}

		/**
			* Получтить экземпляр класса umiField, соответсвующший полю с id = $field_id
			* @param Integer $field_id id поля
			* @param Array $row=false или false информация о поле. Это служебный параметр и его передавать не нужно
			* @return umiField экземпляр класса umiField, соответсвующший полю с id = $field_id, либо false в случае неудачи
		*/
		public function getField($field_id, $row = false) {
			if($this->isExists($field_id)) {
				return $this->fields[$field_id];
			} else {
				return $this->loadField($field_id, $row);
			}
		}

		/**
			* Удалить поле с id $field_id из коллекции
			* @param Integer $field_id id поля
			* @return Boolean true, если удаление удалось
		*/
		public function delField($field_id) {
			$this->disableCache();

			if($this->isExists($field_id)) {
				$sql = "DELETE FROM cms3_object_fields WHERE id = '{$field_id}'";
				l_mysql_query($sql);

				if($err = l_mysql_error()) {
					throw new coreException($err);
					return false;
				}

				unset($this->fields[$field_id]);
				return true;
			} else {
				return false;
			}
		}

		/**
			* Создать новое поле
			* @param String $name имя поля (строковой идентификатор)
			* @param String $title название поля
			* @param Integer $field_type_id id типа данных поля (см. класс umiFieldType)
			* @param Boolean $is_visible=true видимость поля для пользователя
			* @param Boolean $is_locked=false указывает заблокировано ли поле на изменения
			* @param Boolean $is_inheritable=false указывает наследовать ли значение поля. Зарезервировано, но пока не используется, рекомендуется выставлять в false.
			* @return Integer id созданного поля, либо false в случае неудачи
		*/
		public function addField($name, $title, $field_type_id, $is_visible = true, $is_locked = false, $is_inheritable = false) {
			$this->disableCache();

			$sql = "INSERT INTO cms3_object_fields VALUES()";
			l_mysql_query($sql);

			if($err = l_mysql_error()) {
				throw new coreException($err);
				return false;
			}

			$field_id = l_mysql_insert_id();

			$field = new umiField($field_id);

			$field->setName($name);
			$field->setTitle($title);
			if(!$field->setFieldTypeId($field_type_id)) return false;
			$field->setIsVisible($is_visible);
			$field->setIsLocked($is_locked);
			$field->setIsInheritable($is_inheritable);

			if(!$field->commit()) return false;

			$this->fields[$field_id] = $field;

			return $field_id;
		}

		/**
			* Проверить, существует ли в БД поле с id = $field_id
			* @param Integer $field_id id поля
			* @return Boolean true, если поле существует в БД
		*/
		public function isExists($field_id) {
			if(!$field_id) return false;
			return (bool) array_key_exists($field_id, $this->fields);
		}


		/**
			* Загружает в коллекцию экземпляр класса umiField, соответсвующший полю с id = $field_id, и возвращает его
			* @param Integer $field_id id поля
			* @param Array $row=false или false информация о поле. Это служебный параметр и его передавать не нужно
			* @return umiField экземпляр класса umiField, соответсвующший полю c id = $field_id, либо false в случае неудачи
		*/
		private function loadField($field_id, $row) {
		    $field = cacheFrontend::getInstance()->load($field_id, "field");

			if($field instanceof umiField == false) {
				try {
					$field = new umiField($field_id, $row);
				} catch(privateException $e) {
					return false;
				}

				cacheFrontend::getInstance()->save($field, "field");
			}

			if($field instanceof umiField) {
				$this->fields[$field_id] = $field;
				return $this->fields[$field_id];
			} else {
				return false;
			}
		}

		public function clearCache() {
			$keys = array_keys($this->fields);
			foreach($keys as $key) unset($this->fields[$key]);
			$this->fields = array();
		}
	}


/**
	* Коллекция для работы с типами данных (umiObjectType), синглтон.
*/
	class umiObjectTypesCollection extends singleton implements iSingleton, iUmiObjectTypesCollection {
		private $types = Array();

		/**
			* Конструктор, который ничего не делает
		*/
		protected function __construct() {
		}

		/**
			* Получить экземпляр коллекции
			* @return umiObjectTypesCollection экземпляр класса
		*/
		public static function getInstance($c = NULL) {
			return parent::getInstance(__CLASS__);
		}


		/**
			* Полчить тип по его id
			* @param Integer $type_id id типа данных
			* @return umiObjectType тип данных (класс umiObjectType), либо false
		*/
		public function getType($type_id) {
			if(!$type_id) {
				return false;
			}

			if(!is_numeric($type_id)) {
				$type_id = $this->getTypeIdByGUID($type_id);
			}

			if($this->isLoaded($type_id)) {
				return $this->types[$type_id];
			} else {
				$this->loadType($type_id);
				return getArrayKey($this->types, $type_id);
			}
			throw new coreException("Unknow error");
		}

		/**
		* Получить тип по его GUID
		*
		* @param mixed $guid Global Umi Identifier
		* @return umiObjectType тип данных (класс umiObjectType), либо false
		*/
		public function getTypeByGUID($guid) {
			$id = $this->getTypeIdByGUID($guid);
			return $this->getType($id);
		}

		/**
		* Получить числовой идентификатор типа по его GUID
		*
		* @param string $guid Global Umi Identifier
		* @return integer/boolean(false)
		*/
		public function getTypeIdByGUID($guid) {
			static $cache = array();

			if(!$guid) {
				return false;
			}

			if(!cmsController::$IGNORE_MICROCACHE && isset($cache[$guid])) return $cache[$guid];

			$guid = l_mysql_real_escape_string($guid);
			$query = "SELECT `id` FROM `cms3_object_types` WHERE `guid` = '{$guid}'";
			$result = l_mysql_query($query);

			if($error = l_mysql_error()) {
				throw new coreException($error);
			}

			if(list($id) = mysql_fetch_row($result)) {
				return $cache[$guid] = $id;
			} else {
				return $cache[$guid] = false;
			}
		}

		/**
			* Создать тип данных с названием $name, дочерний от типа $parent_id
			* @param Integer $parent_id id родительского типа данных, от которого будут унаследованы поля и группы полей
			* @param String $name название создаваемого типа данных
			* @param Boolean $is_locked=false статус блокировки. Этот параметр указывать не надо
			* @return Integer id созданного типа данных, либо false в случае неудачи
		*/
		public function addType($parent_id, $name, $is_locked = false, $ignore_parent_groups = false) {
			$this->disableCache();

			$parent_id = (int) $parent_id;

			$sql = "INSERT INTO cms3_object_types (parent_id) VALUES('{$parent_id}')";
			$result = l_mysql_query($sql);

			if($err = l_mysql_error()) {
				throw new coreException($err);
				return false;
			}

			$type_id = l_mysql_insert_id();

			//Making types inheritance...
			if (!$ignore_parent_groups) {

				$sql = "SELECT * FROM cms3_object_field_groups WHERE type_id = '{$parent_id}'";
				$result = l_mysql_query($sql);

				if($err = l_mysql_error()) {
					throw new coreException($err);
					return false;
				}

				while($row = mysql_fetch_assoc($result)) {
					$sql = "INSERT INTO cms3_object_field_groups (name, title, type_id, is_active, is_visible, ord, is_locked) VALUES ('" . l_mysql_real_escape_string($row['name']) . "', '" . l_mysql_real_escape_string($row['title']) . "', '{$type_id}', '{$row['is_active']}', '{$row['is_visible']}', '{$row['ord']}', '{$row['is_locked']}')";
					l_mysql_query($sql);

					if($err = l_mysql_error()) {
						throw new coreException($err);
						return false;
					}

					$old_group_id = $row['id'];
					$new_group_id = l_mysql_insert_id();

					$sql = "INSERT INTO cms3_fields_controller SELECT ord, field_id, '{$new_group_id}' FROM cms3_fields_controller WHERE group_id = '{$old_group_id}'";
					l_mysql_query($sql);

					if($err = l_mysql_error()) {
						throw new coreException($err);
						return false;
					}
				}
			}

			$parent_hierarchy_type_id = false;
			if($parent_id) {
				$parent_type = $this->getType($parent_id);
				if($parent_type) {
					$parent_hierarchy_type_id = $parent_type->getHierarchyTypeId();
				}
			}

			$type = new umiObjectType($type_id);
			$type->setName($name);
			$type->setIsLocked($is_locked);
			if($parent_hierarchy_type_id) {
				$type->setHierarchyTypeId($parent_hierarchy_type_id);
			}
			$type->commit();

			$this->types[$type_id] = $type;

			umiBranch::saveBranchedTablesRelations();
			return $type_id;
		}

		/**
			* Удалить тип данных с id $type_id.
			* Все объекты этого типа будут автоматически удалены без возможности восстановления
			* Все дочерние типы от $type_id будут удалены рекурсивно.
			* @param Integer $type_id id типа данных, который будет удален
			* @return Boolean true, если удаление было успешным
		*/
		public function delType($type_id) {
			if($this->isExists($type_id)) {

				$type = $this->getType($type_id);
				if ($type->getIsLocked()) throw new publicAdminException (getLabel('error-object-type-locked'));

				$this->disableCache();

				$childs = $this->getChildClasses($type_id);

				$sz = sizeof($childs);
				for($i = 0; $i < $sz; $i++) {
					$child_type_id = $childs[$i];

					if($this->isExists($child_type_id)) {
						$sql = "DELETE FROM cms3_objects WHERE type_id = '{$child_type_id}'";
						l_mysql_query($sql);

						$sql = "DELETE FROM cms3_object_types WHERE id = '{$child_type_id}'";
						l_mysql_query($sql);

						$sql = "DELETE FROM cms3_import_types WHERE new_id = '{$child_type_id}';";
						l_mysql_query($sql);

						if($err = l_mysql_error()) {
							throw new coreException($err);
							return false;
						}
						unset($this->types[$child_type_id]);
					}
				}

				$type_id = (int) $type_id;

				$sql = "DELETE FROM cms3_objects WHERE type_id = '{$type_id}'";
				l_mysql_query($sql);

				$sql = "DELETE FROM cms3_object_types WHERE id = '{$type_id}'";
				l_mysql_query($sql);

				$sql = "DELETE FROM cms3_import_types WHERE new_id = '{$type_id}';";
				l_mysql_query($sql);

				if($err = l_mysql_error()) {
					throw new coreException($err);
					return false;
				}

				unset($this->types[$type_id]);

				umiBranch::saveBranchedTablesRelations();
				return true;
			} else {
				return false;
			}
		}

		/**
			* @deprecated
			* @param Integer $type_id
			* @return Boolean true всегда
		*/
		public function isExists($type_id) {
			return true;
		}

		/**
			* Проверить, загружен ли тип данных $type_id в коллекцию
			* @param Integer $type_id id типа данных
			* @return Boolean true, если загружен
		*/
		private function isLoaded($type_id) {
			if($type_id === false) return false;
			return (bool) array_key_exists($type_id, $this->types);
		}

		/**
			* Загрузить тип данных в память
			* @param Integer $type_id id типа данных
			* @return Boolean true, если объект удалось загрузить
		*/
		private function loadType($type_id) {
			if($this->isLoaded($type_id)) {
				return true;
			} else {
			    $type = cacheFrontend::getInstance()->load($type_id, "object_type");
				if($type instanceof umiObjectType == false) {
					try {
						$type = new umiObjectType($type_id);
					} catch(privateException $e) {
						return false;
					}

					cacheFrontend::getInstance()->save($type, "object_type");
				}

				if(is_object($type)) {
					$this->types[$type_id] = $type;
					return true;
				} else {
					return false;
				}
			}
		}

		/**
			* Получить список дочерних типов по отношению к типу $type_id
			* @param Integer $type_id id родительского типа данных
			* @return Array массив, состоящий из id дочерних типов данных. Если не получилось, то false.
		*/
		public function getSubTypesList($type_id) {
			if(!is_numeric($type_id)) {
				throw new coreException("Type id must be numeric");
				return false;
			}

			$type_id = (int) $type_id;

			$sql = "SELECT id FROM cms3_object_types WHERE parent_id = '{$type_id}'";
			$result = l_mysql_query($sql);

			if($err = l_mysql_error()) {
				throw new coreException($err);
				return false;
			}

			$res = Array();
			while(list($type_id) = mysql_fetch_row($result)) {
				$res[] = (int) $type_id;
			}
			return $res;
		}

		/**
			* Получить id типа данных, который является непосредственным родителем типа $type_id
			* @param Integer $type_id id типа данных
			* @return Integer id родительского типа, либо false
		*/
		public function getParentClassId($type_id) {
			if($this->isLoaded($type_id)) {
				return $this->getType($type_id)->getParentId();
			} else {
				$type_id = (int) $type_id;
				$sql = "SELECT parent_id FROM cms3_object_types WHERE id = '{$type_id}'";
				$result = l_mysql_query($sql);

				if($err = l_mysql_error()) {
					throw new coreException($err);
					return false;
				}

				if(list($parent_type_id) = mysql_fetch_row($result)) {
					return (int) $parent_type_id;
				} else {
					return false;
				}
			}
		}

		/**
			* Получить список всех дочерних типов от $type_id на всю глубину наследования
			* @param Integer $type_id id типа данных
			* @param mixed $childs этот параметр указывать не требуется
			* @return Array массив, состоящий из $id типов данных
		*/
		public function getChildClasses($type_id, $childs = false) {
			$res = Array();
			if(!$childs) $childs = Array();

			$type_id = (int) $type_id;

			$sql = "SELECT id FROM cms3_object_types WHERE parent_id = '{$type_id}'";
			$result = l_mysql_query($sql);

			if($err = l_mysql_error()) {
				throw new coreException($err);
				return false;
			}

			while(list($id) = mysql_fetch_row($result)) {
				$res[] = $id;

				if(!in_array($id, $childs)) $res = array_merge($res, $this->getChildClasses($id, $res));
			}
			$res = array_unique($res);
			return $res;
		}

		/**
			* Получить список типов данных, которые можно использовать в качестве справочников
			* @param Boolean $public_only=false искать только те типа данных, у которых стоит флаг "Публичный"
			* @param Integer $parentTypeId = null искать только в этом родителе
			* @return Array массив, где ключ это id типа данных, а значение это его название
		*/
		public function getGuidesList($public_only = false, $parentTypeId = null) {
			$res = Array();

			if($public_only) {
				$sql = "SELECT id, name FROM cms3_object_types WHERE is_guidable = '1' AND is_public = '1'";
			} else {
				$sql = "SELECT id, name FROM cms3_object_types WHERE is_guidable = '1'";
			}

			if($parentTypeId) {
				$parentTypeId = (int) $parentTypeId;
				 $sql .= " AND parent_id = '{$parentTypeId}'";
			}

			$result = l_mysql_query($sql);

			while(list($id, $name) = mysql_fetch_row($result)) {
				$res[$id] = $this->translateLabel($name);
			}
			return $res;
		}

		/**
			* Получить список всех типов данных, связанных с базовым типом (umiHierarchyType) $hierarchy_type_id
			* @param Integer $hierarchy_type_id id базового типа
			* @param Boolean $ignoreMicroCache=false не использовать микрокеширование результата
			* @return Array массив, где ключ это id типа данных, а значние - название типа данных
		*/
		public function getTypesByHierarchyTypeId($hierarchy_type_id, $ignoreMicroCache = false) {
			static $cache = Array();
			$hierarchy_type_id = (int) $hierarchy_type_id;

			if(isset($cache[$hierarchy_type_id]) && $ignoreMicroCache == false) return $cache[$hierarchy_type_id];

			$sql = "SELECT id, name FROM cms3_object_types WHERE hierarchy_type_id = '{$hierarchy_type_id}'";
			$result = l_mysql_query($sql);

			if($err = l_mysql_error()) {
				throw new coreException($err);
				return false;
			}

			$res = Array();
			while(list($id, $name) = mysql_fetch_row($result)) {
				$res[$id] = $this->translateLabel($name);
			}

			return $cache[$hierarchy_type_id] = $res;
		}

		/**
			* Получить тип данных, связанный с базовым типом (umiHierarchyType) $hierarchy_type_id
			* @param Integer $hierarchy_type_id id базового типа
			* @param Boolean $ignoreMicroCache=false не использовать микрокеширование результата
			* @return Integer id типа данных, либо false
		*/
		public function getTypeByHierarchyTypeId($hierarchy_type_id, $ignoreMicroCache = false) {
			static $cache = Array();
			$hierarchy_type_id = (int) $hierarchy_type_id;

			if(isset($cache[$hierarchy_type_id]) && $ignoreMicroCache == false && cmsController::$IGNORE_MICROCACHE == false) return $cache[$hierarchy_type_id];

			$sql = "SELECT  id FROM cms3_object_types WHERE hierarchy_type_id = '{$hierarchy_type_id}' LIMIT 1";
			$result = l_mysql_query($sql);

			if($err = l_mysql_error()) {
				throw new coreException($err);
				return false;
			}

			if(list($id) = mysql_fetch_row($result)) {
				return $cache[$hierarchy_type_id] = $id;
			} else {
				return $cache[$hierarchy_type_id] = false;
			}
		}


		/**
			* Получить все тип данных
			* @return Array массив всех типов или false
		*/
		public function getAllTypes() {
			static $cache = Array();

               if(!empty($cache)) return $cache;

			$sql = "SELECT id, name, guid, is_locked, parent_id, is_guidable, is_public, hierarchy_type_id, sortable FROM cms3_object_types";
			$result = l_mysql_query($sql);

			if($err = l_mysql_error()) {
				throw new coreException($err);
				return false;
			}

			$res = Array();
			while($row = mysql_fetch_assoc($result)) {
				$row['name'] = $this->translateLabel($row['name']);

				$res [$row['id']] = $row;
			}

			$cache = $res;

			return $res;
		}


		/**
			* Получить тип данных, связанный с базовым типом (umiHierarchyType) $module/$method
			* @param String $module имя модуля
			* @param String $method имя метода
			* @return Integer id типа данных, либо false
		*/
		public function getBaseType($module, $method = "") {
			$hierarchy_type = umiHierarchyTypesCollection::getInstance()->getTypeByName($module, $method);

			if($hierarchy_type) {
				$hierarchy_type_id = $hierarchy_type->getId();
				$type_id = $this->getTypeByHierarchyTypeId($hierarchy_type_id);
				return (int) $type_id;
			} else {
				return false;
			}
		}

		public function clearCache() {
			$keys = array_keys($this->types);
			foreach($keys as $key) unset($this->types[$key]);
			$this->types = array();
		}
	}


/**
	* Этот класс служит для управления/получения доступа к объектам.
	* Класс является синглтоном, экземпляр класса можно получить через статический метод getInstance()
*/
	class umiObjectsCollection extends singleton implements iSingleton, iUmiObjectsCollection {
		private	$objects = Array();
		private $updatedObjects = Array();

		protected function __construct() {
		}

		/**
			* Получить экземпляр коллекции
			* @return umiObjectsCollection экземпляр класса
		*/
		public static function getInstance($c = NULL) {
			return parent::getInstance(__CLASS__);
		}

		/**
			* Проверить, загружен ли в память объект с id $object_id
			* @param Interger $object_id id объекта
			* @return Boolean true, если объект загружен
		*/
		private function isLoaded($object_id) {
			if(gettype($object_id) == "object") {
			throw new coreException("Object given!");
			}
			return (bool) array_key_exists($object_id, $this->objects);
		}

		/**
			* Проверить, существует ли в БД объект с id $object_id
			* @deprecated
			* @param Integer $object_id id объекта
			* @return Boolean true, если объект существует в БД
		*/
		public function isExists($object_id) {
			$object_id = (int) $object_id;
			$result = l_mysql_query("SELECT COUNT(*) FROM cms3_objects WHERE id = '{$object_id}'");

			if($err = l_mysql_error()) {
				throw new coreException($err);
			} else {
				list($count) = mysql_fetch_row($result);
			}
			return ($count > 0);
		}

		/**
			* Получтить экземпляр объекта с id $object_id
			* @param Integer $object_id id объекта
			* @return umiObject экземпляр объекта $object_id, либо false в случае неудачи
		*/
		public function getObject($object_id, $row = false) {
			$object_id = (int) $object_id;

			if(!$object_id) {
				return false;
			}

			if($this->isLoaded($object_id)) {
				return $this->objects[$object_id];
			}

			$object = cacheFrontend::getInstance()->load($object_id, "object");
			if($object instanceof umiObject == false) {
				try {
					$object = new umiObject($object_id, $row);
				} catch (baseException $e) {
					return false;
				}
				cacheFrontend::getInstance()->save($object, "object");
			}


			if(is_object($object)) {
				$this->objects[$object_id] = $object;
				return $this->objects[$object_id];
			} else {
				return false;
			}
		}

		/**
		* Получить тип по его GUID
		*
		* @param mixed $guid Global Umi Identifier
		* @return umiObject тип данных (класс umiObjectType), либо false
		*/
		public function getObjectByGUID($guid) {
			$id = $this->getObjectIdByGUID($guid);
			return $this->getObject($id);
		}

		/**
		* Получить числовой идентификатор типа по его GUID
		*
		* @param string $guid Global Umi Identifier
		* @return integer/boolean(false)
		*/
		public function getObjectIdByGUID($guid) {
			static $cache = array();

			if(!$guid) {
				return false;
			}

			if(!cmsController::$IGNORE_MICROCACHE && isset($cache[$guid])) return $cache[$guid];

			$guid = l_mysql_real_escape_string($guid);
			$query = "SELECT `id` FROM `cms3_objects` WHERE `guid` = '{$guid}'";
			$result = l_mysql_query($query);

			if($error = l_mysql_error()) {
				throw new coreException($error);
			}

			if(list($id) = mysql_fetch_row($result)) {
				return $cache[$guid] = $id;
			} else {
				return $cache[$guid] = false;
			}
		}

		/**
			* Удалить объект с id $object_id. Если объект заблокирован, он не будет удален.
			* При удалении принудительно вызывается commit() на удаляемом объекте
			* Нельзя удалить пользователей с guid равными system-guest и system-supervisor, нельзя удалить группу супервайзеров.
			* @param Integer $object_id id объекта
			* @return Boolean true, если удаление удалось
		*/
		public function delObject($object_id) { 
			if($this->isExists($object_id)) {
				$this->disableCache();

				$object_id = (int) $object_id;

				if(defined("SV_USER_ID")) {
					if($object_id == SV_USER_ID || $object_id == SV_GROUP_ID || $object_id == $this->getObjectIdByGUID('system-guest')) {
						throw new coreException("You are not allowed to delete object #{$object_id}. Never. Don't even try.");
					}
				}


				//Make sure, we don't will not try to commit it later
				$object = $this->getObject($object_id);
				$object->commit();

				$sql = "DELETE FROM cms3_objects WHERE id = '{$object_id}' AND is_locked='0'";
				l_mysql_query($sql);

				if($err = l_mysql_error()) {
					throw new coreException($err);
					return false;
				}

				if($this->isLoaded($object_id)) {
					unset($this->objects[$object_id]);
				}

				cacheFrontend::getInstance()->del($object_id, "object");

				return true;
			} else {
				return false;
			}
		}

		/**
			* Создать новый объект в БД
			* @param String $name название объекта.
			* @param Integer $type_id id типа данных (класс umiObjectType), которому будет принадлежать объект.
			* @param Boolean $is_locked=false Состояние блокировки по умолчанию. Рекоммендуем этот параметр не указывать.
			* @return Integer id созданного объекта, либо false в случае неудачи
		*/
		public function addObject($name, $type_id, $is_locked = false) {
			$this->disableCache();

			$type_id = (int) $type_id;

			if(!$type_id) {
				throw new coreException("Can't create object without object type id (null given)");
			}

			$sql = "INSERT INTO cms3_objects (type_id) VALUES('$type_id')";
			l_mysql_query($sql);

			if($err = l_mysql_error()) {
				throw new coreException($err);
				return false;
			}

			$object_id = l_mysql_insert_id();
			$object = new umiObject($object_id);

			$object->setName($name);
			$object->setIsLocked($is_locked);

			//Set current user
			if($users_inst = cmsController::getInstance()->getModule("users")) {
				if($users_inst->is_auth()) {
					$user_id = cmsController::getInstance()->getModule("users")->user_id;
					$object->setOwnerId($user_id); 
				}
			} else {
				$object->setOwnerId(NULL);
			}

			//try {
				$this->resetObjectProperties($object_id);
			//} catch (valueRequiredException $e) {
			//	$e->unregister();
			//}

			$object->commit();
			$this->objects[$object_id] = $object;

			return $object_id;
		}

		/**
			* Сделать копию объекта и всех его свойств
			* @param id $iObjectId копируемого объекта
			* @return Integer id объекта-копии
		*/
		public function cloneObject($iObjectId) {
			$vResult = false;

			$oObject = $this->getObject($iObjectId);
			if ($oObject instanceof umiObject) {
				// clone object definition
				$sSql = "INSERT INTO cms3_objects (name, is_locked, type_id, owner_id) SELECT name, is_locked, type_id, owner_id FROM cms3_objects WHERE id = '{$iObjectId}'";
				l_mysql_query($sSql);

				if ($err = l_mysql_error()) {
					throw new coreException($err);
					return false;
				}

				$iNewObjectId = l_mysql_insert_id();

				// clone object content
				$sSql = "INSERT INTO cms3_object_content (obj_id, field_id, int_val, varchar_val, text_val, rel_val, tree_val,float_val)  SELECT '{$iNewObjectId}' as obj_id, field_id, int_val, varchar_val, text_val, rel_val, tree_val,float_val FROM cms3_object_content WHERE obj_id = '$iObjectId'";
				l_mysql_query($sSql);

				if ($err = l_mysql_error()) {
					throw new coreException($err);
					return false;
				}

				$vResult = $iNewObjectId;
			}

			return $vResult;
		}

		/**
			* Получить отсортированный по имени список всех объектов в справочнике $guide_id (id типа данных).
			* Равнозначно если бы мы хотели получить этот список для всех объектов определенного типа данных
			* @param id $guide_id справочника (id типа данных)
			* @return Array массив, где ключи это id объектов, а значения - названия объектов
		*/
		public function getGuidedItems($guide_id) {
			$res = Array();			
			
			if (is_int($guide_id)) {
				$guide_id = (int) $guide_id;
			}
			else {
				$guide_id = addslashes($guide_id);
				$query = "SELECT `id` FROM `cms3_object_types` WHERE `guid`='". $guide_id ."' LIMIT 1";				
				$result = l_mysql_query($query);
				if ( 0<mysql_numrows($result) ) {
					$guide_id = mysql_result($result, 0);				
				}
				else {
					$guide_id = (int) $guide_id;
				}
				
			}
			
			$ignoreSorting = intval(regedit::getInstance()->getVal("//settings/ignore_guides_sort")) ? true : false;			
			
			if($ignoreSorting)
				$sql = "SELECT id, name FROM cms3_objects WHERE type_id = '{$guide_id}' ORDER BY id ASC";
			else
				$sql = "SELECT id, name FROM cms3_objects WHERE type_id = '{$guide_id}' ORDER BY name ASC";
			

			$result = l_mysql_query($sql);

			if($err = l_mysql_error()) {
				throw new coreException($err);
				return false;
			}

			while(list($id, $name) = mysql_fetch_row($result)) {
				$res[$id] = $this->translateLabel($name);
			}

			if(!$ignoreSorting)
				natsort($res);

			return $res;
		}

		public function getCountByTypeId($typeId) {
			$count = false;
			$typeId = (int) $typeId;
			$connection = ConnectionPool::getInstance()->getConnection();
			$result = $connection->queryResult("SELECT COUNT(id) FROM cms3_objects WHERE type_id = '{$typeId}'");
			if($error = l_mysql_error()) {
				throw new databaseException($error);
			}
			list($count) = $result->fetch();
			return $count;
		}

		/**
			* Обнулить все свойства у объекта $object_id
			* @param Integer $object_id id объекта
		*/
		protected function resetObjectProperties($object_id) {
			$object = $this->getObject($object_id);
			$object_type_id = $object->getTypeId();
			$object_type = umiObjectTypesCollection::getInstance()->getType($object_type_id);
			$tableName = umiBranch::getBranchedTableByTypeId($object_type_id);

			$query = "INSERT INTO {$tableName} (obj_id, field_id, int_val, varchar_val, text_val, rel_val, tree_val, float_val) VALUES ";

			$object_fields = $object_type->getAllFields();

			$vals = array();
			foreach($object_fields as $object_field) {
				$vals[] = "('{$object_id}', '{$object_field->getId()}', NULL, NULL, NULL, NULL, NULL, NULL)";
			}

			if(sizeof($object_fields) != 0) {
				l_mysql_query($query . implode($vals, ", "));
			} else {
				$sql = "INSERT INTO {$tableName} (obj_id, field_id) VALUES ('{$object_id}', NULL)";
				l_mysql_query($sql);
				if($err = l_mysql_error()) {
					throw new coreException($err);
				}
			}
		}


		/**
			* Выгрузить объект из коллекции
			* @param Integer $object_id id объекта
		*/
		public function unloadObject($object_id) {
			if($this->isLoaded($object_id)) {
				unset($this->objects[$object_id]);
			} else {
				return false;
			}
		}

		/**
			* Выгрузить объекты из коллекции
			* @param Integer $object_id id объекта
		*/
		public function unloadAllObjects() {
			
			foreach($this->objects as $object_id => $v)
			{
                    unset($this->objects[$object_id]);
			}
		}

		/**
			* Получить id всех объектов, загруженных в коллекцию
			* @return Array массив, состоящий из id объектов
		*/
		public function getCollectedObjects() {
			return array_keys($this->objects);
		}

		/**
			* Указать, что $object_id был изменен во время сессии. Используется внутри ядра.
			* Явный вызов этого метода клиентским кодом не нужен.
			* @param Integer $object_id id объекта
		*/
		public function addUpdatedObjectId($object_id) {
			if(!in_array($object_id, $this->updatedObjects)) {
				$this->updatedObjects[] = $object_id;
			}
		}

		/**
			* Получить список измененных объектов за текущую сессию
			* @return Array массив, состоящий из id измененных значений
		*/
		public function getUpdatedObjects() {
			return $this->updatedObjects;
		}

		/**
			* Деструктор коллекции. Явно вызывать его не нужно никогда.
		*/
		public function __destruct() {
			if(sizeof($this->updatedObjects)) {
				if(function_exists("deleteObjectsRelatedPages")) {
					deleteObjectsRelatedPages();

				}
			}
		}
		
		public function clearCache() {
			$keys = array_keys($this->objects);
			foreach($keys as $key) unset($this->objects[$key]);			
			$this->objects = array();
		}
	}


/**
	* Этот класс служит для управления свойством объекта
*/
	abstract class umiObjectProperty extends umiEntinty implements iUmiEntinty, iUmiObjectProperty {
		protected
			$object_id, $field_id, $field, $field_type,
			$value = array(), $tableName = "cms3_object_content", $is_updated = false;
		protected static $dataCache = array();

		public	$store_type = "property";
		public static $USE_FORCE_OBJECTS_CREATION = false;
		public static $IGNORE_FILTER_INPUT_STRING = false;
		public static $IGNORE_FILTER_OUTPUT_STRING = false;
		public static $USE_TRANSACTIONS = true;
		public static $IGNORE_CACHE = false;

		/**
			* Конструктор класса
			* @param $id Integer id свойства
			* @param $id Integer id поля (umiField), с которым связано свойство
		*/
		public function __construct($id, $field_id, $type_id) {
			$this->tableName = umiBranch::getBranchedTableByTypeId($type_id);

			$this->setId($id);
			$this->object_id = (int) $id;

			$this->field = umiFieldsCollection::getInstance()->getField($field_id);
			$this->field_id = $field_id;

			$this->loadInfo();
		}

		/**
			* Получить класс свойства (umiObjectProperty) для объекта $id, поля $field_id, типа данных $type_id
			* @param Integer $id id объекта
			* @param Integer $field_id id поля (класс umiField)
			* @param Integer $type_id id типа данных (класс umiObjectType)
			* @return umiObjectProperty объект свойства
		*/
		public static function getProperty($id, $field_id, $type_id) {
			$className = self::getClassNameByFieldId($field_id);
			return new $className($id, $field_id, $type_id);
		}

		/**
			* Получить уникальный идентификатор свойства
			* @return Integer id свойства
		*/
		public function getId() {
			return $this->id . "." . $this->field_id;
		}

		/**
			* Получить значение свойства
			* @param Array $params = NULL дополнительные параметры (обычно не используется)
			* @return Mixed значение поля. Тип значения зависит от типа поля, связанного с этим свойством. Вернет NULL, если значение свойства не выставленно.
		*/
		public function getValue(array $params = NULL) {
			if($this->getIsMultiple() === false) {
				if(sizeof($this->value) > 0) {
					list($value) = $this->value;
				} else {
					$value = null;
				}
			} else {
				$value = $this->value;
			}
			if(!is_null($params)) {
				$value = $this->applyParams($value, $params);
			}

			if($restrictionId = $this->field->getRestrictionId()) {
				$restriction = baseRestriction::get($restrictionId);
				if($restriction instanceof iNormalizeOutRestriction) {
					$value = $restriction->normalizeOut($value, $this->object_id);
				}
			}

			return $value;
		}

		/**
			* Получить имя свойсива
			* @return String имя свойства.
		*/
		public function getName() {
			return $this->field->getName();
		}

		/**
			* Получить описание свойсива
			* @return String описание свойства.
		*/
		public function getTitle() {
			return $this->field->getTitle();
		}

		/**
			* Провалидировать значение согласно настройкам поля
			* @param String $value проверяемое начение
			* @return String проверенное (возможно, модифицированное) значение поля
		*/
		public function validateValue($value) {
			if((is_null($value) || $value === false || $value === "") && $this->field->getIsRequired()) {
				throw new valueRequiredException(getLabel('error-value-required', null, $this->getTitle()));
			}

			if($value && $restrictionId = $this->field->getRestrictionId()) {
				$restriction = baseRestriction::get($restrictionId);
				if($restriction instanceof baseRestriction) {
					if($restriction instanceof iNormalizeInRestriction) {
						$value = $restriction->normalizeIn($value, $this->object_id);
					}

					if($restriction->validate($value, $this->object_id) === false) {
						throw new wrongValueException(getLabel($restriction->getErrorMessage(), null, $this->getTitle()));
					}
				}
			}
			return $value;
		}

		/**
			* Установить значение свойства.
			* Устанавливает флаг "Модифицирован".
			* Значение в БД изменится только когда на экземпляре umiObjectProperty будет вызван темод commit(), либо в деструкторе экземпляра
			* @param $value Mixed новое значение для поля. Зависит от типа поля, связанного с этим свойством
			* @return Boolean true если прошло успешно
		*/
		public function setValue($value) {
			$value = $this->validateValue($value);

			if(!is_array($value)) {
				$value = Array($value);
			}

			$not_allowed_symbols = array(1, 2, 3, 4, 5, 6, 7, 8, 11, 12, 14, 15, 16, 17, 18, 19, 20,21, 22, 23, 24, 25, 26, 27, 28, 29, 30, 31);

			$pattern = '';
			foreach ($not_allowed_symbols as $symbol) {
				$pattern = $pattern . chr($symbol);
			}

			foreach($value as &$v) {
				if(is_string($v)) $v = preg_replace("/[" . $pattern . "]/isu", "", $v);
			}

			$data_type = $this->getDataType();
			if ($data_type === 'date') {
				foreach ($value as $vKey=>$vVal) {
					if (!($vVal instanceof umiDate)) {
						$value[$vKey] = new umiDate(intval($vVal));
					}
				}
			}

			$this->value = $value;
			return $this->setIsUpdated();
//			return $this->setObjectIsUpdated();
		}

		/**
			* Сбросить значение свойства.
			* Устанавливает флаг "Модифицирован".
			* Значение в БД изменится только когда на экземпляре umiObjectProperty будет вызван темод commit(), либо в деструкторе экземпляра
			* @return Boolean true если прошло успешно
		*/
		public function resetValue() {
			$this->value = Array();
			$this->setIsUpdated();
		}

		/**
			* Загружает необходимые данные для формирования объекта umiObjectProperty из БД.
			* @return Boolean true в случае успеха
		*/
		protected function loadInfo() {
			$field = $this->field;
			$field_types = umiFieldTypesCollection::getInstance();

			$field_type_id = $field->getFieldTypeId();

			$field_type = $field_types->getFieldType($field_type_id);
			$this->field_type = $field_type;

			$this->value = $this->loadValue();
		}

		protected function save() {
			$object = umiObjectsCollection::getInstance()->getObject($this->id);
			if($object instanceof umiObject) {
				if($object->checkSelf() == false) {
					cacheFrontend::getInstance()->del($object->getId(), "object");
					return false;
				}
			}

			cacheFrontend::getInstance()->del($this->getId(), "property");

			if(self::$USE_TRANSACTIONS) {
				l_mysql_query("START TRANSACTION /* Saving property for object {$this->id} */");
			}

			$result = $this->saveValue();

			if(self::$USE_TRANSACTIONS) {
				l_mysql_query("COMMIT");
			}

			if(isset(umiObjectProperty::$dataCache[$this->object_id])) {
				unset(umiObjectProperty::$dataCache[$this->object_id]);
			}

			$this->loadInfo();

			return $result;
		}

		/**
			* Узнать, может ли значение данного свойства состоять из массива значений (составной тип)
			* @return Boolean true, если тип составной
		*/
		public function getIsMultiple() {
			return $this->field_type->getIsMultiple();
		}

		/**
			* Узнать, может ли значение данного свойства иметь знак.
			* Зарезервировано и пока не используется
			* @return Boolean true, если значение свойства не будет иметь знак
		*/
		public function getIsUnsigned() {
			return $this->field_type->getIsUnsigned();
		}

		/**
			* Получить идентификатор типа поля, связанного с данным свойством
			* @return String идентификатор типа
		*/
		public function getDataType() {
			return $this->field_type->getDataType();
		}

		/**
			* Узнать, заблокировано ли свойство на изменение
			* @return Boolean true если свойство заблокировано
		*/
		public function getIsLocked() {
			return $this->field->getIsLocked();
		}

		/**
			* Узнать, наследуется ли значение свойства. Зарезервировано, но пока не используется.
			* @return Boolean true если свойство наследуется
		*/
		public function getIsInheritable() {
			return $this->field->getIsInheritable();
		}

		/**
			* Узнать видимость свойства для пользователя
			* @return Boolean true если свойство видимое для пользователя
		*/
		public function getIsVisible() {
			return $this->field->getIsVisible();
		}

		/**
			* Сохраняет значение свойства в БД, если тип свойства "Тэги"
		*/
		public static function filterInputString($string) {
			$string = umiObjectProperty::filterCDATA($string);
			$string = l_mysql_real_escape_string($string);

			if(isset($_SERVER['DOCUMENT_ROOT']) && cmsController::getInstance()->getCurrentMode() != "admin" && !umiObjectProperty::$IGNORE_FILTER_INPUT_STRING && !(defined("CRON")&&CRON)) {
				$string = htmlspecialchars( htmlspecialchars_decode($string), ENT_NOQUOTES);
				$string = str_replace("%", "&#37;", $string);
			}

			return $string;
		}

		/**
			* Заменяет в строке символ "%" на "&#037;" и обратно, в зависимости от режима работы cms.
			* Используется ядром для защиты от иньекций макросов на клинтской стороне
			* @param String $string фильтруемая строка
			* @return String отфильтрованная строка
		*/
		public static function filterOutputString($string) {
			if(!isset($_SERVER['DOCUMENT_ROOT']) || cmsController::getInstance()->getCurrentMode() == "admin" || self::$IGNORE_FILTER_OUTPUT_STRING) {
				$string = str_replace("%", "&#037;", $string);
			} else {
				//$string = stripslashes(str_replace(array("&#037;", "&#37;"), "%", $string));
				$string = str_replace(array("&#037;", "&#37;"), "%", $string);
			}

			return $string;
		}

		/**
			* Заменяет в строке символ закрывающую последовательность для CDATA (]]>) на "]]&gt;"
			* Используется ядром поддержания валидности XML-документов
			* @param String $string фильтруемая строка
			* @return String отфильтрованная строка
		*/
		public static function filterCDATA($string) {
			$string = str_replace("]]>", "]]&gt;", $string);
			return $string;
		}

		/**
			* Устанавливает маркер "модифицирован" у связанного с этим свойством объекта
			* @return Boolean false, в случае неудачи
		*/
		protected function setObjectIsUpdated() {
			if($object = $this->getObject()) {
				$object->setIsUpdated();
				return true;
			} else {
				return false;
			}
		}

		protected function getPropData() {
			$cache = &umiObjectProperty::$dataCache;

			if(defined("DISABLE_GETVAL_OPT") && DISABLE_GETVAL_OPT) {
				return false;
			}

			$fieldId = $this->field_id;
			$objectId = $this->object_id;

			if(!isset($cache[$objectId])) {
				$data = array();

				$sql = "SELECT field_id, int_val, varchar_val, text_val, rel_val, tree_val, float_val FROM {$this->tableName} WHERE obj_id = '{$this->id}'";
				$result = l_mysql_query($sql);
				while($row = mysql_fetch_assoc($result)) {
					$data[$row['field_id']]['int_val'][] = $row['int_val'];
					$data[$row['field_id']]['varchar_val'][] = $row['varchar_val'];
					$data[$row['field_id']]['text_val'][] = $row['text_val'];
					$data[$row['field_id']]['rel_val'][] = $row['rel_val'];
					$data[$row['field_id']]['tree_val'][] = $row['tree_val'];
					$data[$row['field_id']]['float_val'][] = $row['float_val'];
				}
				$cache[$objectId] = $data;

				if(sizeof($cache) >= 3) {
					foreach($cache as $i => $d) {
						unset($cache[$i]);
						break;
					}
				}
			} else {
				$data = $cache[$objectId];
			}

			if(isset($data[$fieldId])) {
				$result = $data[$fieldId];
				unset($cache[$objectId][$fieldId]);
				if(sizeof($cache[$objectId]) == 0){
					unset($cache[$objectId]);
				}
				return $result;
			} else {
				return false;
			}
		}

		/**
			* Возвращает связанный с этим свойством объект (umiObject)
			* @return umiObject
			* @see umiObject
		*/
		public function getObject() {
			return umiObjectsCollection::getInstance()->getObject($this->object_id);
		}


		/**
			* Возвращает id объекта (umiObject), связанного с этим свойством
			* @return umiObject
			* @see umiObject
		*/
		public function getObjectId() {
			return $this->object_id;
		}

		/**
			* Возвращает тип свойства (umiFieldType)
			* @return umiFieldType
			* @see umiFieldType
		*/
		public function getField() {
			return $this->field;
		}

		protected static function unescapeFilePath($filepath) {
			return str_replace("\\\\", "/", $filepath);
		}

		protected function deleteCurrentRows() {
			$sql = "DELETE FROM {$this->tableName} WHERE obj_id = '{$this->object_id}' AND (field_id = '{$this->field_id}' OR field_id IS NULL)";
			l_mysql_query($sql);

			if($err = l_mysql_error()) {
				throw new coreException($err);
				return false;
			}
		}

		/**
			* Заполнить все столбцы значений таблицы БД, соответствующие данному свойству NULL'ами
		*/
		protected function fillNull() {
			$sql = "SELECT COUNT(*) FROM {$this->tableName} WHERE obj_id = '{$this->object_id}' AND field_id = '{$this->field_id}'";
			$result = l_mysql_query($sql);

			if($err = l_mysql_error()) {
				throw new coreException($err);
				return false;
			} else {
				list($c) = mysql_fetch_row($result);
			}

			if($c == 0) {
				$sql = "INSERT INTO {$this->tableName} (obj_id, field_id) VALUES('{$this->object_id}', '{$this->field_id}')";
				l_mysql_query($sql);

				if($err = l_mysql_error()) {
					throw new coreException($err);	//TODO: Ignore references, debug.
					return false;
				} else {
					return true;
				}
			}
			return true;
		}


		protected static function getClassNameByFieldId($field_id) {
			static $cache = Array();


			if(isset($cache[$field_id]) && !self::$IGNORE_CACHE) {
				return $cache[$field_id];
			}

			$field = umiFieldsCollection::getInstance()->getField($field_id);
			$fieldTypeId = $field->getFieldTypeId();
			$fieldType = umiFieldTypesCollection::getInstance()->getFieldType($fieldTypeId);
			$fieldDataType = $fieldType->getDataType();

			$propertyClasses = Array(
				'relation' => 'umiObjectPropertyRelation',
				'wysiwyg' => 'umiObjectPropertyWYSIWYG',
				'string' => 'umiObjectPropertyString',
				'file' => 'umiObjectPropertyFile',
				'img_file' => 'umiObjectPropertyImgFile',
				'swf_file' => 'umiObjectPropertyImgFile',
				'video_file' => 'umiObjectPropertyFile',
				'boolean' => 'umiObjectPropertyBoolean',
				'int' => 'umiObjectPropertyInt',
				'text' => 'umiObjectPropertyText',
				'date' => 'umiObjectPropertyDate',
				'symlink' => 'umiObjectPropertySymlink',
				'price' => 'umiObjectPropertyPrice',
				'float' => 'umiObjectPropertyFloat',
				'tags' => 'umiObjectPropertyTags',
				'password' => 'umiObjectPropertyPassword',
				'counter' => 'umiObjectPropertyCounter',
				'optioned' => 'umiObjectPropertyOptioned'
			);

			if(isset($propertyClasses[$fieldDataType])) {
				return $cache[$field_id] = $propertyClasses[$fieldDataType];
			} else {
				throw new coreException("Unhandled field of type \"{$fieldDataType}\"");
			}
		}

		/**
			* Не используйте этот метод, его поведение будет изменено в ближайших версиях
		*/
		public static function objectsByValue($i_field_id, $arr_value = NULL, $b_elements = false, $b_stat = true, $arr_domains = NULL) {
			$arr_answer = array();

			// ==== validate input : =======================

			if (!(is_null($arr_value) || is_array($arr_value) || intval($arr_value) === -1 || strval($arr_value) === 'all' || strval($arr_value) == 'Все')) {
				$arr_value = array($arr_value);
			}

			// h.domain_id
			$arr_domain_ids = NULL;
			if ($b_elements) {
				if (is_null($arr_domains)) { // current domain
					$arr_domain_ids = array(cmsController::getInstance()->getCurrentDomain()->getId());
				} elseif (intval($arr_domains) === -1 || strval($arr_domains) === 'all' || strval($arr_domains) == 'Все') {
					$arr_domain_ids = array();
				} elseif (is_array($arr_domains)) {
					$arr_domain_ids = array_map('intval', $arr_domains);
				} else {
					$arr_domain_ids = array(intval($arr_domains));
				}
			}

			$field = umiFieldsCollection::getInstance()->getField($i_field_id);
			if($field instanceof umiField) {
				$fieldDataType = $field->getFieldType()->getDataType();
				$s_col_name = umiFieldType::getDataTypeDB($fieldDataType);
			} else {
				throw new coreException("Field #{$fieldId} not found");
			}

			// ==== construct sql queries : ================

			$objectTypeId = umiSelectionsParser::getObjectTypeByFieldId($i_field_id);
			$tableName = umiBranch::getBranchedTableByTypeId($objectTypeId);

			$s_from = "{$tableName} `o`";
			if ($b_elements) $s_from .= ", cms3_hierarchy `h`";

			if ($b_elements) {
				$s_count_field = "h.id";
			} else {
				$s_count_field = "o.obj_id";
			}

			$s_where_tail = ($b_elements ? " AND h.obj_id = o.obj_id AND h.is_active=1 AND h.is_deleted=0" : "");

			if ($b_elements && is_array($arr_domain_ids) && count($arr_domain_ids)) {
				$s_where_tail .= " AND h.domain_id IN ('".implode("', '", $arr_domain_ids)."')";
			}

			$s_values_filter = "";
			if (!(intval($arr_value) === -1 || strval($arr_value) === 'all' || strval($arr_value) === 'Âñå')) {
				$s_values_filter = " AND o.{$s_col_name} ".(is_null($arr_value) ? "IS NULL" : "IN ('".implode("', '", $arr_value)."')");
			}

			if ($b_stat) {
				$s_query = "SELECT o.".$s_col_name." as `value`, COUNT(".$s_count_field.") as `items` FROM ".$s_from." WHERE o.field_id = ".$i_field_id.$s_values_filter.$s_where_tail." GROUP BY o.".$s_col_name." ORDER BY `items`";
			} else {
				$s_query = "SELECT DISTINCT ".$s_count_field." as `item` FROM ".$s_from." WHERE o.field_id = ".$i_field_id.$s_values_filter.$s_where_tail;
			}

			// ==== execute sql query : ====================

			$arr_query = array();
			$rs_query = l_mysql_query($s_query);
			$i_query_error = mysql_errno();
			$s_query_error = l_mysql_error();
			if ($rs_query === false || $i_query_error) {
				throw new coreException("Error executing db query (errno ".$i_query_error.", error ".$s_query_error.", query ".$s_query.")");
			} else {
				while ($arr_next_row = mysql_fetch_assoc($rs_query)) {
					$arr_query[] = $arr_next_row;
				}
			}

			// ==== construct returning answer : ===========

			if ($b_stat) {
				$arr_answer['values'] = array();
				$i_max = 0;
				$i_summ = 0;
				foreach ($arr_query as $arr_row) {
					$i_cnt = intval($arr_row['items']);

					$arr_answer['values'][] = array('value' => $arr_row['value'], 'cnt' => $i_cnt);

					if ($i_cnt > $i_max) $i_max = $i_cnt;
					$i_summ += $i_cnt;
				}
				$arr_answer['max'] = $i_max;
				$arr_answer['sum'] = $i_summ;
			} else {
				foreach ($arr_query as $arr_row) $arr_answer[] = $arr_row['item'];
			}

			// RETURN :
			return $arr_answer;

		}

		protected function applyParams($values, $params = NULL) {
			return $values;
		}

		protected function prepareRelationValue($value) {
			if(!$value) {
				return false;
			}

			$objects = umiObjectsCollection::getInstance();
			$forceObjectsCreation = self::$USE_FORCE_OBJECTS_CREATION;

			if(is_object($value)) {
				return $value->getId();
			} else {
				if(is_numeric($value) && $objects->isExists($value) && !$forceObjectsCreation) {
					return (int) $value;
				} else {
					if($guide_id = $this->field->getGuideId()) {
						$val_name = self::filterInputString($value);
						$val_label = $this->translateI18n($val_name);

						$sql = "SELECT id FROM cms3_objects WHERE type_id = '{$guide_id}' AND name = '{$val_label}'";
						$result = l_mysql_query($sql);

						if(mysql_num_rows($result)) {
							list($value) = mysql_fetch_row($result);
							return $value;
						} else {
							$valueToAdd = ($val_label == $val_name) ? $value : $val_label;
							if($value = $objects->addObject($valueToAdd, $guide_id)) {
								return (int) $value;
							} else {
								throw new coreException("Can't create guide item");
							}
						}
					} else {
						return null;
					}
				}
			}
		}
	};


/**
	* Этот класс служит для управления свойством объекта.
	* Обрабатывает тип поля "Кнопка-флажок" (булевый тип)
*/
	class umiObjectPropertyBoolean extends umiObjectProperty {
		/**
			* Загружает значение свойства из БД, если тип свойства целое число
		*/
		protected function loadValue() {
			$res = Array();
			$field_id = $this->field_id;
			
			if($data = $this->getPropData()) {
				foreach($data['int_val'] as $val) {
					if(is_null($val)) continue;
					$res[] = (int) $val;
				}
				return $res;
			}

			$sql = "SELECT  int_val FROM {$this->tableName} WHERE obj_id = '{$this->object_id}' AND field_id = '{$field_id}' LIMIT 1";
			$result = l_mysql_query($sql, true);

			while(list($val) = mysql_fetch_row($result)) {
				if(is_null($val)) continue;
				$res[] = (int) $val;
			}

			return $res;
		}
		
		/**
			* Сохраняет значение свойства в БД, если тип свойства "Число"
		*/
		protected function saveValue() {
			$this->deleteCurrentRows();

			$cnt = 0;
			foreach($this->value as $val) {
				if(!$val) continue;
				$val = (int)$this->boolval($val,true);
				
				$sql = "INSERT INTO {$this->tableName} (obj_id, field_id, int_val) VALUES('{$this->object_id}', '{$this->field_id}', '{$val}')";
				l_mysql_query($sql);
				++$cnt;
			}
			
			if(!$cnt) $this->fillNull();
		}
		protected function boolval($in, $strict=false) {
			$out = null;
			// if not strict, we only have to check if something is false
			if (in_array($in,array('false', 'False', 'FALSE', 'no', 'No', 'n', 'N', '0', 'off',
                           'Off', 'OFF', false, 0, null), true)) {
				$out = false;
			} else if ($strict) {
				// if strict, check the equivalent true values
				if (in_array($in,array('true', 'True', 'TRUE', 'yes', 'Yes', 'y', 'Y', '1',
                               'on', 'On', 'ON', true, 1), true)) {
					$out = true;
				}
			} else {
				// not strict? let the regular php bool check figure it out (will
				//     largely default to true)
				$out = ($in?true:false);
			}
			return $out;
		}
	};


/**
	*       .
	*    ""
*/
	class umiObjectPropertyCounter extends umiObjectProperty {
		protected $oldValue;
		
		/**
			*     
		*/
		protected function loadValue() {
			$res = Array();
			$field_id = $this->field_id;

			$sql = "SELECT cnt FROM `cms3_object_content_cnt` WHERE obj_id = '{$this->object_id}' AND field_id = '{$field_id}' LIMIT 1";
			$result = l_mysql_query($sql, true);

			if(list($val) = mysql_fetch_row($result)) {
				$cnt = (int) $val;
			} else {
				$cnt = 0;
			}
			$this->oldValue = $cnt;

			return Array($cnt);
		}

		/**
			*     ,    ""
		*/
		protected function saveValue() {
			$value = sizeof($this->value) ? (int) $this->value[0] : 0;
			$lambda = $value - $this->oldValue;
			if((abs($lambda) == 1) && $value !== 0 && $this->oldValue) {
				$sql = "UPDATE `cms3_object_content_cnt` SET cnt = cnt + ({$lambda}) WHERE obj_id = '{$this->object_id}' AND field_id = '{$this->field_id}'";
				l_mysql_query($sql);
			} else {
				$this->deleteCurrentRows();
				$sql = "INSERT INTO `cms3_object_content_cnt` (obj_id, field_id, cnt) VALUES('{$this->object_id}', '{$this->field_id}', '{$value}')";
				l_mysql_query($sql);
			}
		}
		
		protected function deleteCurrentRows() {
			$objectId = (int) $this->object_id;
			$fieldId = (int) $this->field_id;
			
			$sql = "DELETE FROM `cms3_object_content_cnt` WHERE `obj_id` = {$objectId} AND `field_id` = {$fieldId}";
			l_mysql_query($sql);
		}
		
		protected function fillNull() {
			$objectId = (int) $this->object_id;
			$fieldId = (int) $this->field_id;
			
			$sql = "SELECT COUNT(*) FROM `cms3_object_content_cnt` WHERE `obj_id` = {$objectId} AND `field_id` = {$fieldId}";
			$result = l_mysql_query($sql);
			list($count) = mysql_fetch_row($result);
			if($count == 0) {
				$sql = "INSERT INTO `cms3_object_content_cnt` (`obj_id`, `field_id`) VALUES ('{$objectId}', '{$fieldId}')";
				l_mysql_query($sql);
			}
		}
	};


/**
	* Этот класс служит для управления свойством объекта.
	* Обрабатывает тип поля "Дата"
*/
	class umiObjectPropertyDate extends umiObjectProperty {
		/**
			* Загружает значение свойства из БД, если тип свойства "Дата"
		*/
		protected function loadValue() {
			$res = Array();
			$field_id = $this->field_id;
			
			if($data = $this->getPropData()) {
				foreach($data['int_val'] as $val) {
					if(is_null($val)) continue;
					$res[] = new umiDate((int) $val);
				}
				return $res;
			}

			$sql = "SELECT  int_val FROM {$this->tableName} WHERE obj_id = '{$this->object_id}' AND field_id = '{$field_id}' LIMIT 1";
			$result = l_mysql_query($sql, true);

			while(list($val) = mysql_fetch_row($result)) {
				if(is_null($val)) continue;
				$res[] = new umiDate((int) $val);
			}

			return $res;
		}
		
		/**
			* Сохраняет значение свойства в БД, если тип свойства "Дата"
		*/
		protected function saveValue() {
			$this->deleteCurrentRows();
			
			$cnt = 0;
			foreach($this->value as $val) {
				if($val === false || $val === "") {
					continue;
				} else {
					$val = (is_object($val)) ? (int) $val->timestamp : (int) $val;
					if($val == false) {
						continue;
					}
				}

				$sql = "INSERT INTO {$this->tableName} (obj_id, field_id, int_val) VALUES('{$this->object_id}', '{$this->field_id}', '{$val}')";
				l_mysql_query($sql);
				++$cnt;
			}
			
			if(!$cnt) $this->fillNull();
		}
	};


/**
	* Этот класс служит для управления свойством объекта.
	* Обрабатывает тип поля "Файл"
*/
	class umiObjectPropertyFile extends umiObjectProperty {
		/**
			* Загружает значение свойства из БД, если тип свойства "Файл"
		*/
		protected function loadValue() {
			$res = Array();
			$field_id = $this->field_id;
			
			if($data = $this->getPropData()) {
				foreach($data['text_val'] as $val) {
					if(is_null($val)) continue;
					$val = self::unescapeFilePath($val);
					
					$file = new umiFile(self::filterOutputString($val));
					if($file->getIsBroken()) continue;
					$res[] = $file;
				}
				return $res;
			}

			$sql = "SELECT  text_val FROM {$this->tableName} WHERE obj_id = '{$this->object_id}' AND field_id = '{$field_id}' LIMIT 1";
			$result = l_mysql_query($sql, true);

			while(list($val) = mysql_fetch_row($result)) {
				if(is_null($val)) continue;
				$file = new umiFile($val);
				if($file->getIsBroken()) continue;
				$res[] = $file;
			}
			return $res;
		}

		/**
			* Сохраняет значение свойства в БД, если тип свойства "Файл"
		*/
		protected function saveValue() {
			$this->deleteCurrentRows();

			if(is_null($this->value)) {
				return;
			}

			$cnt = 0;
			foreach($this->value as $val) {
				if(!$val) continue;
				
				if(is_object($val)) {
					if(!@is_file($val->getFilePath())) {
						continue;
					}
					$val = l_mysql_real_escape_string($val->getFilePath());
				} else {
					$val = l_mysql_real_escape_string($val);
				}

				$sql = "INSERT INTO {$this->tableName} (obj_id, field_id, text_val) VALUES('{$this->object_id}', '{$this->field_id}', '{$val}')";
				l_mysql_query($sql);
				++$cnt;
			}
			
			if(!$cnt) $this->fillNull();
		}
	};


/**
	* Этот класс служит для управления свойством объекта.
	* Обрабатывает тип поля "Число с точкой"
*/
	class umiObjectPropertyFloat extends umiObjectProperty {
		/**
			* Загружает значение свойства из БД, если тип свойства "число с точкой"
		*/
		protected function loadValue() {
			$res = Array();
			$field_id = $this->field_id;

			if($data = $this->getPropData()) {
				foreach($data['float_val'] as $val) {
					if(is_null($val)) continue;
					$res[] = (float) $val;
				}
				return $res;
			}

			$sql = "SELECT  float_val FROM {$this->tableName} WHERE obj_id = '{$this->object_id}' AND field_id = '{$field_id}' LIMIT 1";
			$result = l_mysql_query($sql, true);

			while(list($val) = mysql_fetch_row($result)) {
				if(is_null($val)) continue;
				$res[] = (float) $val;
			}

			return $res;
		}
		
		/**
			* Сохраняет значение свойства в БД, если тип свойства "Число с точкой"
		*/
		protected function saveValue() {
			$this->deleteCurrentRows();

			$cnt = 0;
			foreach($this->value as $val) {
				if($val === false || $val === "") continue;

				if(strpos(".", $val) === false) $val = str_replace(",", ".", $val);
				$val = (float) $val;

				$sql = "INSERT INTO {$this->tableName} (obj_id, field_id, float_val) VALUES('{$this->object_id}', '{$this->field_id}', '{$val}')";
				l_mysql_query($sql);
				++$cnt;
			}
			
			if(!$cnt) $this->fillNull();
		}
	};


/**
	* Этот класс служит для управления свойством объекта.
	* Обрабатывает тип поля "Картинка"
*/
	class umiObjectPropertyImgFile extends umiObjectProperty {
		/**
			* Загружает значение свойства из БД, если тип свойства "Изображение"
		*/
		protected function loadValue() {
			$res = Array();
			$field_id = $this->field_id;

			if($data = $this->getPropData()) {
				foreach($data['text_val'] as $val) {
					if(is_null($val)) continue;
					$val = self::unescapeFilePath($val);
					
					$img = new umiImageFile(self::filterOutputString($val));
					if($img->getIsBroken()) continue;
					$res[] = $img;
				}
				return $res;
			}

			$sql = "SELECT  text_val FROM {$this->tableName} WHERE obj_id = '{$this->object_id}' AND field_id = '{$field_id}' LIMIT 1";
			$result = l_mysql_query($sql, true);

			while(list($val) = mysql_fetch_row($result)) {
				if(is_null($val)) continue;
				
				$val = self::unescapeFilePath($val);
				
				$img = new umiImageFile(self::filterOutputString($val));
				if($img->getIsBroken()) continue;
				$res[] = $img;
			}
			return $res;
		}

		/**
			* Сохраняет значение свойства в БД, если тип свойства "Изображение"
		*/
		protected function saveValue() {
			$this->deleteCurrentRows();

			if(is_null($this->value)) {
				return;
			}

			$cnt = 0;
			foreach($this->value as $val) {
				if(!$val) continue;
				
				if(is_object($val)) {
					if(!@is_file($val->getFilePath())) {
						continue;
					}
					$val = l_mysql_real_escape_string($val->getFilePath());
				} else {
					$val = l_mysql_real_escape_string($val);
				}
				
				$val = self::unescapeFilePath($val);

				$sql = "INSERT INTO {$this->tableName} (obj_id, field_id, text_val) VALUES('{$this->object_id}', '{$this->field_id}', '{$val}')";
				l_mysql_query($sql);
				++$cnt;
			}
			
			if(!$cnt) $this->fillNull();
		}
	};


/**
	* Этот класс служит для управления свойством объекта.
	* Обрабатывает тип поля "Число"
*/
	class umiObjectPropertyInt extends umiObjectProperty {
		/**
			* Загружает значение свойства из БД, если тип свойства целое число
		*/
		protected function loadValue() {
			$res = Array();
			$field_id = $this->field_id;
			
			if($data = $this->getPropData()) {
				foreach($data['int_val'] as $val) {
					if(is_null($val)) continue;
					$res[] = (int) $val;
				}
				return $res;
			}

			$sql = "SELECT  int_val FROM {$this->tableName} WHERE obj_id = '{$this->object_id}' AND field_id = '{$field_id}' LIMIT 1";
			$result = l_mysql_query($sql, true);

			while(list($val) = mysql_fetch_row($result)) {
				if(is_null($val)) continue;
				$res[] = (int) $val;
			}

			return $res;
		}

		/**
			* Сохраняет значение свойства в БД, если тип свойства "Число"
		*/
		protected function saveValue() {
			$this->deleteCurrentRows();
			
			$cnt = 0;
			foreach($this->value as $val) {
				if($val === false || $val === "") continue;
				$val = (int) $val;

				$sql = "INSERT INTO {$this->tableName} (obj_id, field_id, int_val) VALUES('{$this->object_id}', '{$this->field_id}', '{$val}')";
				l_mysql_query($sql);
				++$cnt;
			}
			
			if(!$cnt) {
				$this->fillNull();
			}
		}
	};


/**
	* 
	* 
	* 
*/
	class umiObjectPropertyOptioned extends umiObjectProperty {
		public function setValue($value) {
			if(is_array($value)) {
				$value = array_distinct($value);
			}
			parent::setValue($value);
		}
		
		/**
			* 
		*/
		protected function loadValue() {
			$values = array();
			
			$data = $this->getPropData();
			if($data == false) {
				$data = array();
				$sql = "SELECT int_val, varchar_val, text_val, rel_val, tree_val, float_val FROM {$this->tableName} WHERE obj_id = '{$this->object_id}' AND field_id = '{$this->field_id}'";
				$result = l_mysql_query($sql, true);
				while($row = mysql_fetch_assoc($result)) {
					foreach($row as $i => $v) {
						$data[$i][] = $v;
					}
				}
			}
			

			for($i = 0; true; $i++) {
				if($value = $this->parsePropData($data, $i)) {
					foreach($value as $t => $v) {
						$value[$t] = ($t == 'float') ? $this->filterFloat($v) : self::filterOutputString($v);
					}
					
					$values[] = $value;
					continue;
				} break;
			}
			
			return $values;
		}


		/**
			* 
		*/
		protected function saveValue() {
			$this->deleteCurrentRows();
			foreach($this->value as $key => $data) {
				$sql = "INSERT INTO `{$this->tableName}` (`obj_id`, `field_id`, `int_val`, `varchar_val`, `rel_val`, `tree_val`, `float_val`) VALUES ('{$this->object_id}', '{$this->field_id}', ";
				
				$cnt = 0;
				if($intValue = (int) getArrayKey($data, 'int')) {
					$sql .= "'{$intValue}', ";
					++$cnt;
				} else {
					$sql .= "NULL, ";
				}
				
				if($varcharValue = (string) getArrayKey($data, 'varchar')) {
					$varcharValue = self::filterInputString($varcharValue);
					$sql .= "'{$varcharValue}', ";
					++$cnt;
				} else {
					$sql .= "NULL, ";
				}
				
				if($relValue = (int) $this->prepareRelationValue(getArrayKey($data, 'rel'))) {
					$sql .= "'{$relValue}', ";
					++$cnt;
				} else {
					$sql .= "NULL, ";
				}
				$this->values[$key]['rel'] = $relValue;
				
				if($treeValue = (int) getArrayKey($data, 'tree')) {
					$sql .= "'{$treeValue}', ";
					++$cnt;
				} else {
					$sql .= "NULL, ";
				}
				
				if($floatValue = (float) getArrayKey($data, 'float')) {
					$sql .= "'{$floatValue}'";
					++$cnt;
				} else {
					$sql .= "NULL";
				}
				
				$sql .= ")";
				
				if($cnt < 2) {
					continue;
				}
				
				l_mysql_query($sql);
			}
		}
		
		
		protected function parsePropData($data, $index) {
			$result = Array();
			$hasValue = false;
			foreach($data as $contentType => $values) {
				if(isset($values[$index])) {
					$contentType = $this->decodeContentType($contentType);
					$result[$contentType] = $values[$index];
					$hasValue = true;
				}
			}
			return $hasValue ? $result : false;
		}
		
		protected function decodeContentType($contentType) {
			if(substr($contentType, -4) == '_val') {
				$contentType = substr($contentType, 0, strlen($contentType) - 4);
			}
			return $contentType;
		}
		
		protected function applyParams($values, $params = NULL) {
			$filter = getArrayKey($params, 'filter');
			$requireFieldType = getArrayKey($params, 'field-type');
			
			if(!is_null($filter)) {
				$result = Array();
				foreach($values as $index => $value) {
					foreach($filter as $fieldType => $filterValue) {
						if(isset($value[$fieldType]) && $value[$fieldType] == $filterValue) {
							$result[] = $value;
						}
					}
				}
				$values = $result;
			}
			
			if(!is_null($requireFieldType)) {
				foreach($values as $i => $value) {
					$values[$i] = getArrayKey($value, $requireFieldType);
				}
			}
			return $values;
		}
		
		protected function filterFloat($value) {
			return round($value, 2);
		}
	};


/**
	* Этот класс служит для управления свойством объекта.
	* Обрабатывает тип поля "Пароль"
*/
	class umiObjectPropertyPassword extends umiObjectProperty {
		/**
			* Загружает значение свойства из БД, если тип свойства целое число
		*/
		protected function loadValue() {
			$res = Array();
			$field_id = $this->field_id;

			if($data = $this->getPropData()) {
				foreach($data['varchar_val'] as $val) {
					if(is_null($val)) continue;
					$res[] = self::filterOutputString((string) $val);
				}
				return $res;
			}

			$sql = "SELECT  varchar_val FROM {$this->tableName} WHERE obj_id = '{$this->object_id}' AND field_id = '{$field_id}' LIMIT 1";
			$result = l_mysql_query($sql, true);

			while(list($val) = mysql_fetch_row($result)) {
				if(is_null($val)) continue;
				$res[] = self::filterOutputString((string) $val);
			}

			return $res;
		}


		/**
			* Сохраняет значение свойства в БД, если тип свойства "Пароль"
		*/
		protected function saveValue() {
			$cnt = 0;
			foreach($this->value as $val) {
				if(strlen($val) == 0) continue;

				$this->deleteCurrentRows();

				$val = self::filterInputString($val);

				$sql = "INSERT INTO {$this->tableName} (obj_id, field_id, varchar_val) VALUES('{$this->object_id}', '{$this->field_id}', '{$val}')";
				l_mysql_query($sql);
				++$cnt;
			}
			
			if(!$cnt) $this->fillNull();
		}
	};


/**
	* Этот класс служит для управления свойством объекта.
	* Обрабатывает тип поля "Цена". При загрузке данных вызывается событие "umiObjectProperty_loadPriceValue".
*/
	class umiObjectPropertyPrice extends umiObjectPropertyFloat {
		protected $dbValue;
		
		/**
			* Загружает значение свойства из БД, если тип свойства "Цена"
		*/
		protected function loadValue() {
			$res = parent::loadValue();

			$price = 0;
			if(is_array($res) && isset($res[0])) {
				list($price) = $res;
			}
			
			$this->dbValue = $price;
			
			if($eshop_inst = cmsController::getInstance()->getModule("eshop")) {
				$price = $eshop_inst->calculateDiscount($this->object_id, $price);
			}

			$oEventPoint = new umiEventPoint("umiObjectProperty_loadPriceValue");
			$oEventPoint->setParam("object_id", $this->object_id);
			$oEventPoint->addRef("price", $price);
			$oEventPoint->call();
			$res = Array($price);
			
			return $res;
		}

		/**
			* Сохраняет значение свойства в БД, если тип свойства "Цена"
		*/
		protected function saveValue() {
			$this->deleteCurrentRows();

			$cnt = 0;
			foreach($this->value as $val) {
				if($val === false || $val === "") continue;

				if(strpos(".", $val) === false) $val = str_replace(",", ".", $val);
				$val = abs((float) $val);
				if($val > 999999999.99) $val = 999999999.99;

				$sql = "INSERT INTO {$this->tableName} (obj_id, field_id, float_val) VALUES('{$this->object_id}', '{$this->field_id}', '{$val}')";
				l_mysql_query($sql);

				if($err = l_mysql_error()) {
					throw new coreException($err);
				}
				++$cnt;
			}
			
			$this->dbValue = $this->value;
			
			if(!$cnt) {
				$this->fillNull();
			}
		}
		
		public function __wakeup() {
			if($this->dbValue) {
				$price = $this->dbValue;
				if($eshop_inst = cmsController::getInstance()->getModule("eshop")) {
					$price = $eshop_inst->calculateDiscount($this->object_id, $price);
				}

				$oEventPoint = new umiEventPoint("umiObjectProperty_loadPriceValue");
				$oEventPoint->setParam("object_id", $this->object_id);
				$oEventPoint->addRef("price", $price);
				$oEventPoint->call();
				$value = Array($price);

				$this->value = $value;
			}
		}
	};


/**
	* Этот класс служит для управления свойством объекта.
	* Обрабатывает тип поля "Выпадающий список", т.е. свойства с использованием справочников.
*/
	class umiObjectPropertyRelation extends umiObjectProperty {
		/**
			* Загружает значение свойства из БД, если тип свойства "Ссылка на объект"
		*/
		protected function loadValue() {
			$res = Array();
			$field_id = $this->field_id;

			if($data = $this->getPropData()) {
				foreach($data['rel_val'] as $val) {
					if(is_null($val)) continue;
					$res[] = $val;
				}
				return $res;
			}

			if($this->getIsMultiple()) {
				$sql = "SELECT  rel_val FROM {$this->tableName} WHERE obj_id = '{$this->object_id}' AND field_id = '{$field_id}'";
			} else {
				$sql = "SELECT  rel_val FROM {$this->tableName} WHERE obj_id = '{$this->object_id}' AND field_id = '{$field_id}' LIMIT 1";
			}

			$result = l_mysql_query($sql, true);

			while(list($val) = mysql_fetch_row($result)) {
				if(is_null($val)) continue;
				$res[] = $val;
			}
			return $res;
		}

		/**
			* Сохраняет значение свойства в БД, если тип свойства "Ссылка на объект"
		*/
		protected function saveValue() {
			$this->deleteCurrentRows();

			if(is_null($this->value)) {
				return;
			}

			$tmp = Array();
			foreach($this->value as $val) {
				if(!$val) continue;

				if(is_string($val) && strpos($val, "|") !== false) {
					$tmp1 = explode("|", $val);
					foreach($tmp1 as $v) {
						$v = trim($v);
						if($v) $tmp[] = $v;
						unset($v);
					}
					unset($tmp1);
					$this->getField()->setFieldTypeId(umiFieldTypesCollection::getInstance()->getFieldTypeByDataType('relation',1)->getId());	//Check, if we can use it without fieldTypeId

				} else {
					$tmp[] = $val;
				}
			}
			$this->value = $tmp;
			unset($tmp);

			$cnt = 0;

			foreach($this->value as $key => $val) {
				if($val) {
					$val = $this->prepareRelationValue($val);
					$this->values[$key] = $val;
				}
				if(!$val) continue;

				$sql = "INSERT INTO {$this->tableName} (obj_id, field_id, rel_val) VALUES('{$this->object_id}', '{$this->field_id}', '{$val}')";
				l_mysql_query($sql);
				++$cnt;
			}

			if(!$cnt) $this->fillNull();
		}
	};


/**
	* Этот класс служит для управления свойством объекта
	* Обрабатывает тип поля "Строка".
*/
	class umiObjectPropertyString extends umiObjectProperty {
		/**
			* Загружает значение свойства из БД, если тип свойства "Строка"
		*/
		protected function loadValue() {
			$res = Array();
			$field_id = $this->field_id;
			
			if($data = $this->getPropData()) {
				foreach($data['varchar_val'] as $val) {
					if(is_null($val)) continue;
					$res[] = self::filterOutputString((string) $val);
				}
				return $res;
			}

			$sql = "SELECT  varchar_val FROM {$this->tableName} WHERE obj_id = '{$this->object_id}' AND field_id = '{$field_id}' LIMIT 1";
			$result = l_mysql_query($sql, true);

			while(list($val) = mysql_fetch_row($result)) {
				if(is_null($val)) continue;
				$res[] = self::filterOutputString((string) $val);
			}

			return $res;
		}
		
		/**
			* Сохраняет значение свойства в БД, если тип свойства "Строка"
		*/
		protected function saveValue() {
			$this->deleteCurrentRows();

			$cnt = 0; 
			foreach($this->value as $val) {
				if(strlen($val) == 0) continue;

				$val = self::filterInputString($val);

				$sql = "INSERT INTO {$this->tableName} (obj_id, field_id, varchar_val) VALUES('{$this->object_id}', '{$this->field_id}', '{$val}')";
				l_mysql_query($sql);
				++$cnt;
			}
			
			if(!$cnt) $this->fillNull();
		}
	}


/**
	* Этот класс служит для управления свойством объекта
	* Обрабатывает тип поля "Ссылка на дерево".
*/
	class umiObjectPropertySymlink extends umiObjectProperty {
		/**
			* Загружает значение свойства из БД, если тип свойства "Ссылка на дерево"
		*/
		protected function loadValue() {
			$res = Array();
			$field_id = $this->field_id;

			if($data = $this->getPropData()) {
				foreach($data['tree_val'] as $val) {
					if(is_null($val)) continue;
					$element = umiHierarchy::getInstance()->getElement( (int) $val );
					if($element === false) continue;
					if($element->getIsActive() == false) continue;
	
					$res[] = $element;
				}
				return $res;
			}

			$sql = "SELECT  tree_val FROM {$this->tableName} WHERE obj_id = '{$this->object_id}' AND field_id = '{$field_id}'";
			$result = l_mysql_query($sql, true);

			while(list($val) = mysql_fetch_row($result)) {
				if(is_null($val)) continue;
				$element = umiHierarchy::getInstance()->getElement( (int) $val );
				if($element === false) continue;
				if($element->getIsActive() == false) continue;

				$res[] = $element;
			}

			return $res;
		}

		/**
			* Сохраняет значение свойства в БД, если тип свойства "Ссылка на дерево"
		*/
		protected function saveValue() {
			$this->deleteCurrentRows();
			$hierarchy = umiHierarchy::getInstance();

			$cnt = 0;
			foreach($this->value as $i => $val) {
				if($val === false || $val === "") continue;

				if(is_object($val)) {
					$val = (int) $val->getId();
				} else {
					$val = intval($val);
				}
				
				if(!$val) continue;

				if(is_numeric($val)) {
					$val = (int) $val;
					$this->value[$i] = $hierarchy->getElement($val);
				}

				$sql = "INSERT INTO {$this->tableName} (obj_id, field_id, tree_val) VALUES('{$this->object_id}', '{$this->field_id}', '{$val}')";

				l_mysql_query($sql);
				++$cnt;
			}
			
			if(!$cnt) {
				$this->fillNull();
			}
		}
	};


/**
	* Этот класс служит для управления свойством объекта
	* Обрабатывает тип поля "Теги".
*/
	class umiObjectPropertyTags extends umiObjectProperty {
		/**
			* Загружает значение свойства из БД, если тип свойства "Тэги"
		*/
		protected function loadValue() {
			$res = Array();
			$field_id = $this->field_id;

			if($data = $this->getPropData()) {
				foreach($data['varchar_val'] as $val) {
					if(is_null($val)) continue;
					$res[] = self::filterOutputString((string) $val);
				}
				return $res;
			}

			$sql = "SELECT  varchar_val FROM {$this->tableName} WHERE obj_id = '{$this->object_id}' AND field_id = '{$field_id}'";
			$result = l_mysql_query($sql, true);

			while(list($val) = mysql_fetch_row($result)) {
				if(is_null($val)) continue;
				$res[] = self::filterOutputString((string) $val);
			}
			return $res;
		}

		/**
			* Сохраняет значение свойства в БД, если тип свойства "Тэги"
		*/
		protected function saveValue() {
			$this->deleteCurrentRows();

			if(sizeof($this->value) == 1) {				
				$value = trim($this->value[0], ",");				
				$value = preg_replace("/[^A-Za-z0-9А-Яа-яЁё'\-$%_,\s]/u", "", $value);				
				$value =  explode(",", $value);
			} else {
				$value = array_map( create_function('$a', " return preg_replace(\"/[^A-Za-z0-9А-Яа-яЁё'\\-\\$%_,\s]?/u\", \"\", \$a); ") , $this->value);
			}

			$cnt = 0;
			foreach($value as $val) {
				$val = trim($val);
				if(strlen($val) == 0) continue;

				$val = self::filterInputString($val);

				$sql = "INSERT INTO {$this->tableName} (obj_id, field_id, varchar_val) VALUES('{$this->object_id}', '{$this->field_id}', '{$val}')";
				l_mysql_query($sql);
				++$cnt;
			}
			
			if(!$cnt) {
				$this->fillNull();
			}
		}
	};


/**
	* Этот класс служит для управления свойством объекта
	* Обрабатывает тип поля "Текст".
*/
	class umiObjectPropertyText extends umiObjectProperty {
		/**
			* Загружает значение свойства из БД, если тип свойства "Текст"
		*/
		protected function loadValue() {
			$res = Array();
			$field_id = $this->field_id;

			if($data = $this->getPropData()) {
				foreach($data['text_val'] as $val) {
					if(is_null($val)) continue;
					$res[] = self::filterOutputString((string) $val);
				}
				return $res;
			}

			$sql = "SELECT  text_val FROM {$this->tableName} WHERE obj_id = '{$this->object_id}' AND field_id = '{$field_id}' LIMIT 1";
			$result = l_mysql_query($sql, true);

			while(list($val) = mysql_fetch_row($result)) {
				if(is_null($val)) continue;
				$res[] = self::filterOutputString((string) $val);
			}

			return $res;
		}

		/**
			* Сохраняет значение свойства в БД, если тип свойства "Текст"
		*/
		protected function saveValue() {
			$this->deleteCurrentRows();

			$cnt = 0;
			foreach($this->value as $val) {
				if($val == "<p />" || $val == "&nbsp;") $val = "";

				$val = self::filterInputString($val);

				$sql = "INSERT INTO {$this->tableName} (obj_id, field_id, text_val) VALUES('{$this->object_id}', '{$this->field_id}', '{$val}')";
				l_mysql_query($sql);
				++$cnt;
			}
			
			if(!$cnt) {
				$this->fillNull();
			}
		}
		
		public function __wakeup() {
			foreach($this->value as $i => $v) {
				if(is_string($v)) {
					$this->value[$i] = str_replace("&#037;", "%", $v);
				}
			}
		}
	};


/**
	* Этот класс служит для управления свойством объекта
	* Обрабатывает тип поля "WYSIWYG".
*/
	class umiObjectPropertyWYSIWYG extends umiObjectPropertyText {
		protected function saveValue() {
			foreach($this->value as $i => $value) {
				$value = str_replace(array('&lt;!--', '--&gt;'), array('<!--', '-->'),  $value);
				$value = preg_replace('/<!--\[if(.*?)>(.*?)<!(-*)\[endif\][\s]*-->/mis', '', $value);
				$this->value[$i] = $value;
			}
			parent::saveValue();
		}

		/**
			* Загружает значение свойства из БД, если тип свойства "HTML-текст"
		*/
		protected function loadValue() {
			$res = Array();
			$field_id = $this->field_id;

			if($data = $this->getPropData()) {
				foreach($data['text_val'] as $val) {
					if(is_null($val)) continue;
					if(str_replace("&nbsp;", "", trim($val)) == "") continue;
					$res[] = self::filterOutputString((string) $val);
				}
				return $res;
			}

			$sql = "SELECT  text_val FROM {$this->tableName} WHERE obj_id = '{$this->object_id}' AND field_id = '{$field_id}' LIMIT 1";
			$result = l_mysql_query($sql, true);

			while(list($val) = mysql_fetch_row($result)) {
				if(is_null($val)) continue;
				if(str_replace("&nbsp;", "", trim($val)) == "") continue;
				$res[] = self::filterOutputString((string) $val);
			}

			return $res;
		}
	};


	interface iBackupModel {
		public function getChanges($param = "");
		public function save($cparam = "");
		public function rollback($revisionId);
		public function addLogMessage($elementId);
		public function fakeBackup($elementId);
	};


/**
	* Класс для управления резервными копиями страниц
*/
	class backupModel extends singleton implements iBackupModel {

		protected function __construct() {}

		public static function getInstance($c = NULL) {
			return parent::getInstance(__CLASS__);
		}

		/**
			* Получить список изменений для страницы $cparam
			* @param Integer $cparam = false id страницы
			* @return Array список изменений
		*/
		public function getChanges($cparam = false) {

			$regedit = regedit::getInstance();

			if (!$regedit->getVal("modules/backup/enabled")) {
				return false;
			}

			$limit = (int) $regedit->getVal("//modules/backup/max_save_actions");
			$time_limit = (int) $regedit->getVal("//modules/backup/max_timelimit");
			$end_time = $time_limit * 3600 * 24;

			$cparam = (int) $cparam;

			$limit = ($limit > 2) ? $limit : 2;

			$sql = "SELECT id, ctime, changed_module, user_id, is_active FROM cms_backup WHERE param='" . $cparam . "' AND (" . time() . "-ctime)<" . $end_time . " ORDER BY ctime DESC LIMIT {$limit}";
			$result = l_mysql_query($sql);

			if (mysql_num_rows($result) < 2) {
				$sql = "SELECT id, ctime, changed_module, user_id, is_active FROM cms_backup WHERE param='" . $cparam . "' ORDER BY ctime DESC LIMIT 2";
				$result = l_mysql_query($sql);
			}

			$params = array();
			$rows = array();
			while(list($revision_id, $ctime, $changed_module, $user_id, $is_active) = mysql_fetch_row($result)) {
				
				$revision_info = $this->getChangeInfo($revision_id, $ctime, $changed_module, $cparam, $user_id, $is_active);
				if (count($revision_info)) $rows[] = $revision_info;				
			}

			$params['nodes:revision'] = $rows;
			return $params;

		}
		
		protected function getChangeInfo($revision_id, $ctime, $changed_module, $cparam, $user_id, $is_active) {
			
			$hierarchy = umiHierarchy::getInstance();
			$cmsController = cmsController::getInstance();
			
			$revision_info = array();	
			
			$element = $hierarchy->getElement($cparam);
			if ($element instanceof umiHierarchyElement) {

				$revision_info['attribute:changetime'] = $ctime;
				$revision_info['attribute:user-id'] = $user_id;
				if (strlen($changed_module) == 0) {
					$revision_info['attribute:is-void'] = true;
				}
				if ($is_active) {
					$revision_info['attribute:active'] = "active";
				}
				$revision_info['date'] = new umiDate($ctime);
				$revision_info['author'] = selector::get('object')->id($user_id);
				$revision_info['link'] = "/admin/backup/rollback/{$revision_id}/";

				$module_name = $element->getModule();
				$method_name = $element->getMethod();

				$module = $cmsController->getModule($module_name);
				if($module instanceof def_module) {
					$links = $module->getEditLink($cparam, $method_name);
					if(isset($links[1])) {
						$revision_info['page'] = array();
						$revision_info['page']['attribute:name'] = $element->getName();
						$revision_info['page']['attribute:edit-link'] = $links[1];
						$revision_info['page']['attribute:link'] = $element->link;
					}
				}
			}
			
			return $revision_info;
			
		}

		/**
			* Получить список изменений для всех страниц
			* @return Array список изменений
		*/
		public function getAllChanges() {
			if (!regedit::getInstance()->getVal("modules/backup/enabled")) {
				return false;
			}

			$sql = "SELECT id, ctime, changed_module, param, user_id, is_active FROM cms_backup ORDER BY ctime DESC LIMIT 100";
			$result = l_mysql_query($sql);
			
			$params = array();
			$rows = array();
			
			while(list($revision_id, $ctime, $changed_module, $cparam, $user_id, $is_active) = mysql_fetch_row($result)) {
				$revision_info = $this->getChangeInfo($revision_id, $ctime, $changed_module, $cparam, $user_id, $is_active);
				if (count($revision_info)) $rows = array_merge($rows, array($revision_info));
			}

			$params['nodes:revision'] = $rows;
			return $params;

		}

		/**
			* Сохранить как точку восстановления текущие изменения для страницы $cparam
			* @param Integer $cparam = false id страницы
			* @param String $changed_module = "" не используется более
			* @param String $changed_method = "" не используется более
		*/
		public function save($cparam = "", $cmodule = "", $cmethod = "") {

			if(!regedit::getInstance()->getVal("//modules/backup/enabled")) return false;
			if(getRequest('rollbacked')) return false;

			$this->restoreIncrement();

			$cmsController = cmsController::getInstance();
			if(!$cmodule) $cmodule = $cmsController->getCurrentModule();
			$cmethod = $cmsController->getCurrentMethod();

			$cuser_id = ($cmsController->getModule('users')) ? $cuser_id = $cmsController->getModule('users')->user_id : 0;


			$ctime = time();

			if(!$cmodule) {
				$cmodule = getRequest('module');
			}

			if(!$cmethod) {
				$cmethod = getRequest('method');
			}

			foreach($_REQUEST as $cn => $cv) {
				if($cn == "save-mode") continue;
				$_temp[$cn] = (!is_array($cv)) ? base64_encode($cv) : $cv;
			}


			if(isset($_temp['data']['new'])) {
				$element = umiHierarchy::getInstance()->getElement($cparam);
				if($element instanceof umiHierarchyElement) {
					$_temp['data'][$element->getObjectId()] = $_temp['data']['new'];
					unset($_temp['data']['new']);
				}

			}

			$req = serialize($_temp);
			$req = l_mysql_real_escape_string($req);

			$sql = "UPDATE cms_backup SET is_active='0' WHERE param='" . $cparam . "'";
			l_mysql_query($sql);

			$sql = <<<SQL
INSERT INTO cms_backup (ctime, changed_module, changed_method, param, param0, user_id, is_active)
				VALUES('{$ctime}', '{$cmodule}', '{$cmethod}', '{$cparam}', '{$req}', '{$cuser_id}', '1')
SQL;
			l_mysql_query($sql);

			$limit = regedit::getInstance()->getVal("//modules/backup/max_save_actions");
			$sql = "SELECT COUNT(*) FROM cms_backup WHERE param='" . $cparam . "' ORDER BY ctime DESC";
			$result = l_mysql_query($sql);
			list($total_b) = mysql_fetch_row($result);

			$td = $total_b - $limit;
			if($td < 0) {
				$td = 0;
			}

			$sql = "SELECT id FROM cms_backup WHERE param='" . $cparam . "' ORDER BY ctime DESC LIMIT 2";
			$result = l_mysql_query($sql);
			$backupIds = array();
			while(list($backupId) = mysql_fetch_row($result)) {
				$backupIds[] = $backupId;
			}
			$notId = "";
			if (count($backupIds)) $notId = "AND id NOT IN (" . implode(", ", $backupIds) . ")";


			$sql = "DELETE FROM cms_backup WHERE param='" . $cparam . "' {$notId} ORDER BY ctime ASC LIMIT " . ($td);
			l_mysql_query($sql);

			$time_limit = regedit::getInstance()->getVal("//modules/backup/max_timelimit");
			$end_time = $time_limit*3600*24;
			$sql="DELETE FROM cms_backup WHERE param='" . $cparam . "' AND (" . time() . "-ctime)>" . $end_time . " {$notId} ORDER BY ctime ASC";
			l_mysql_query($sql);

			return true;
		}

		/**
			* Восстановить данные из резервной точки $revision_id
			* @param Integer $revision_id id резервное копии
			* @return Boolean false, если восстановление невозможно
		*/
		public function rollback($revision_id) {
			if(!regedit::getInstance()->getVal("//modules/backup/enabled")) {
				return false;
			}

			$revision_id = (int) $revision_id;

			$sql = "SELECT param, param0, changed_module, changed_method FROM cms_backup WHERE id='$revision_id' LIMIT 1";
			$result = l_mysql_query($sql);

			if(list($element_id, $data, $changed_module, $changed_method) = mysql_fetch_row($result)) {
				$changed_param = $element_id;

				$sql = "UPDATE cms_backup SET is_active='0' WHERE param='" . $changed_param . "'";
				l_mysql_query($sql);

				$sql = "UPDATE cms_backup SET is_active='1' WHERE id='" . $revision_id . "'";
				l_mysql_query($sql);

				$_temp = unserialize($data);
				$_REQUEST = Array();

				foreach($_temp as $cn => $cv) {
					if(!is_array($cv)) {
						$cv = base64_decode($cv);
					} else {
						foreach($cv as $i => $v) {
							$cv[$i] = $v;
						}
					}
					$_REQUEST[$cn] = $cv;
					$_POST[$cn] = $cv;
				}
				$_REQUEST['rollbacked'] = true;
				$_REQUEST['save-mode'] = getLabel('label-save');

				if($changed_module_inst = cmsController::getInstance()->getModule($changed_module)) {
					$element = umiHierarchy::getInstance()->getElement($element_id);

					if($element instanceof umiHierarchyElement) {
						$links = $changed_module_inst->getEditLink($element_id, $element->getMethod());
						if(sizeof($links) >= 2) {
							$edit_link = $links[1];
							$_REQUEST['referer'] = $edit_link;

							$edit_link = trim($edit_link, "/") . "/do";

							if(preg_match("/admin\/[A-z]+\/([^\/]+)\//", $edit_link, $out)) {
								if(isset($out[1])) {
									$changed_method = $out[1];
								}
							}
							$_REQUEST['path'] = $edit_link;
							$_REQUEST['param0'] = $element_id;
							$_REQUEST['param1'] = "do";
						}
					}

					return $changed_module_inst->cms_callMethod($changed_method, Array());
				} else {
					throw new requreMoreAdminPermissionsException("You can't rollback this action. No permission to this module.");
				}
			}

		}

		/**
			* Добавить сообщение в список изменений страницы $elementId без занесения самих изменений
			* @param Integer $elementId id страницы
		*/
		public function addLogMessage($elementId) {
			if(!regedit::getInstance()->getVal("//modules/backup/enabled")) {
				return false;
			}

			$this->restoreIncrement();

			$cmsController = cmsController::getInstance();
			$cuser_id = ($cmsController->getModule('users')) ? $cmsController->getModule('users')->user_id : 0;

			$time = time();
			$param = (int) $elementId;

			$sql = "INSERT INTO cms_backup (ctime, param, user_id, param0) VALUES('{$time}', '{$param}', '{$cuser_id}', '{$time}')";
			l_mysql_query($sql);
		}

		public function fakeBackup($elementId) {
			$element = selector::get('page')->id($elementId);
			if(is_null($element)) return false;
			$originalRequest = $_REQUEST;

			$object = $element->getObject();
			$type = selector::get('object-type')->id($object->getTypeId());

			$_REQUEST['name'] = $element->name;
			$_REQUEST['alt-name'] = $element->altName;
			$_REQUEST['active'] = $element->isActive;
			foreach($type->getAllFields() as $field) {
				$fieldName = $field->getName();
				$value = $this->fakeBackupValue($object, $field);
				if(is_null($value)) continue;
				$_REQUEST['data'][$object->id][$fieldName] = $value;
			}

			$this->save($elementId, $element->getModule());
			$_REQUEST = $originalRequest;
		}

		protected function fakeBackupValue(iUmiObject $object,  iUmiField $field) {
			$value = $object->getValue($field->getName());

			switch($field->getDataType()) {
				case 'file':
				case 'img_file':
				case 'swf_file':
					return ($value instanceof iUmiFile) ? $value->getFilePath() : '';

				case 'boolean':
					return $value ? '1' : '0';

				case 'date':
					return ($value instanceof umiDate) ? $value->getFormattedDate('U') : NULL;

				case 'tags':
					return is_array($value) ? implode(", ", $value) : NULL;

				default:
					return (string) $value;
			}
		}

		protected function restoreIncrement() {

			$result1 = l_mysql_query("SELECT max( id ) FROM `cms_backup`");
			$row1 = mysql_fetch_row($result1);
			$incrementToBe = $row1[0] + 1;

			$result = l_mysql_query("SHOW TABLE STATUS LIKE 'cms_backup'");
       		$row = mysql_fetch_array($result);
       		$increment = isset($row['Auto_increment']) ? (int) $row['Auto_increment'] : false;
			if($increment !== false && $increment != $incrementToBe){
				l_mysql_query("ALTER TABLE `cms_backup` AUTO_INCREMENT={$incrementToBe}");
			}
		}
	};


	/**
	 * @deprecated
	 * Используйте umiTemplater::create('XSLT');
	 */
	class xslTemplater extends singleton {
		protected function __construct() {}
		/**
		 * @static
		 * @param null $c
		 * @return umiTemplaterXSLT
		 */
		public static function getInstance($c = NULL) {
			return umiTemplater::create('XSLT', null);
		}
	}


	abstract class translatorWrapper {
		public $isFull = false;
		public static $showEmptyFields = false;
		
		abstract public function translate($data);
		
		final static public function get($object) {
			if(is_object($object) == false) {
				throw new coreException("Object required to apply class translation");
			}
			
			$className = self::getClassAlias($object);
			if($wrapper = self::loadWrapper($className)) {
				return $wrapper;
			} else {
				throw new coreException("Can't load translation wrapper for class \"{$className}\"");
			}
		}
		
		final static protected function loadWrapper($className) {
			static $loaded = array(), $config;
			
			if(isset($loaded[$className])) {
				return $loaded[$className];
			}
			
			if(is_null($config)) {
				$config = mainConfiguration::getInstance();
			}
			
			
			$wrapperClassName = $className . 'Wrapper';
			if (!class_exists($wrapperClassName)) {
				$filePath = $config->includeParam('system.kernel') . 'utils/translators/wrappers/' . $className . 'Wrapper.php';
				if(is_file($filePath) == false) {
					$loaded[$className] = false;
					throw new coreException("Can't load file \"{$filePath}\" to translate object of class \"{$className}\"");
				}
				
				require $filePath;
			}
			
			if(!class_exists($wrapperClassName)) {
				$loaded[$className] = false;
				throw new coreException("Translation wrapper class \"{$wrapperClassName}\" not found");
			}
			
			$wrapper = new $wrapperClassName($translator);
			
			if($wrapper instanceof translatorWrapper == false) {
				$loaded[$className] = false;
				throw new coreException("Translation wrapper class \"{$wrapperClassName}\" should be instance of translatorWrapper");
			}
			
			return $loaded[$className] = $wrapper;
		}
		
		protected static function getClassAlias($object) {
			$baseClasses = array(
				'baseRestriction', 'publicException'
			);
			
			$aliases = array(
				'umiObjectProperty' => array(
					'umiObjectPropertyPrice', 
					'umiObjectPropertyFloat', 
					'umiObjectPropertyTags', 
					'umiObjectPropertyBoolean', 
					'umiObjectPropertyImgFile', 
					'umiObjectPropertyRelation', 
					'umiObjectPropertyText', 
					'umiObjectPropertyDate', 
					'umiObjectPropertyInt', 
					'umiObjectPropertyString', 
					'umiObjectPropertyWYSIWYG', 
					'umiObjectPropertyFile', 
					'umiObjectPropertyPassword', 
					'umiObjectPropertySymlink',
					'umiObjectPropertyCounter', 
					'umiObjectPropertyOptioned'
				),
				
				'umiFile' => array(
					'umiImageFile'
				)
			);
			
			$className = get_class($object);
			
			foreach($aliases as $baseClassName => $alias) {
				if(in_array($className, $alias)) {
					return $baseClassName;
				}
			}
			
			foreach($baseClasses as $baseClass) {
				if(in_array($baseClass, class_parents($object))) {
					return $baseClass;
				}
			}

			
			return $className;
		}
	};


	class xmlTranslator implements iXmlTranslator {
		public static $showHiddenFieldGroups = false;
		public static $showUnsecureFields = false;

		protected	$domDocument = false;
		protected	$currentPageTranslated = false;
		protected	static $shortKeys = array(
			'@' => 'attribute',
			'#' => 'node',
			'+'	=> 'nodes',
			'%' => 'xlink',
			'*' => 'comment'
		);

		public function __construct(DOMDocument $domDocument) {
			$this->domDocument = $domDocument;
		}


		public function translateToXml(DOMElement $rootNode, $userData) {
			return $this->chooseTranslator($rootNode, $userData);
		}


		public function chooseTranslator(DOMElement $rootNode, $userData, $is_full = false) {
			switch(gettype($userData)) {
				case "array": {
					$this->translateArray($rootNode, $userData);
					break;
				}


				case "object": {
					$wrapper = translatorWrapper::get($userData);
					$wrapper->isFull = $is_full;
					$this->chooseTranslator($rootNode, $wrapper->translate($userData));
					break;
				}

				default: {
					$this->translateBasic($rootNode, $userData);
					break;
				}
			}
		}


		public static function executeMacroses($userData, $scopeElementId = false, $scopeObjectId = false) {
			$cmsController = cmsController::getInstance();

			if($cmsController->getCurrentMode() != "admin" &&
				(!defined('XML_MACROSES_DISABLE') || !XML_MACROSES_DISABLE)) {
				$userData = def_module::parseTPLMacroses($userData, $scopeElementId, $scopeObjectId);
			}

			return $userData;
		}


		protected function translateBasic(DOMElement $rootNode, $userData) {
			$dom = $this->domDocument;

			$userData = self::executeMacroses($userData);

			$element = $dom->createTextNode($userData);
			$rootNode->appendChild($element);
		}


		protected function translateArray(DOMElement $rootNode, $userData) {
			$dom = $this->domDocument;

			foreach($userData as $key => $val) {
				if($this->isKeySubnodes($key)) {
					$key = $this->getRealKey($key);
					$res[$key] = Array();
					$res[$key]['nodes:item'] = $val;
					$val = $res;
					unset($res);
				}

				switch(true) {
					case $this->isKeyANull($key): {
						break;
					}

					case $this->isKeyAFull($key): {
						$key = $this->getRealKey($key);

						if($key == false) {
							$element = $rootNode;
						} else {
							$element = $dom->createElement($key);
						}

						$this->chooseTranslator($element, $val, true);

						if($key != false) {
							$rootNode->appendChild($element);
						}
						break;
					}

					case $this->isKeyAnAttribute($key): {
						$key = $this->getRealKey($key);
						if($val === "" || is_null($val) || is_array($val)) break;
						$rootNode->setAttribute($key, $val);
						break;
					}


					case $this->isKeyANode($key): {
						$node = $dom->createTextNode((string) $val);
						$rootNode->appendChild($node);
						break;
					}


					case $this->isKeyNodes($key): {
						$key = $this->getRealKey($key);

						if(is_array($val)) {
							foreach($val as $cval) {
								$element = $dom->createElement($key);
								$this->chooseTranslator($element, $cval);
								$rootNode->appendChild($element);
							}
						}
						break;
					}

					case $this->isKeyXml($key): {
						$key = $this->getRealKey($key);

						$val = html_entity_decode($val, ENT_COMPAT, "utf-8");
						$val = str_replace('&', '&amp;', $val);

						$sxe = @simplexml_load_string($val); // try load xml. ignore warnings

						if($sxe !== false) {						
							if($dom_sxe = dom_import_simplexml($sxe)) {
								$dom_sxe = $dom->importNode($dom_sxe, true);
								$rootNode->appendChild($dom_sxe);
							}
							break;
						} else {
							$rootNode->appendChild($dom->createTextNode($val));
							break;
						}
					}



					case $this->isKeyXLink($key): {
						$key = $this->getRealKey($key);
						$rootNode->setAttribute("xlink:" . $key, $val);
						break;
					}

					case $this->isKeyComment($key): {
						$rootNode->appendChild(new DOMComment(' ' . $val . ' '));
						break;
					}

					default: {
						if($key === 0) {
							throw new coreException("Can't translate to xml key {$key} with value {$val}");
							break;
						}

						$element = $dom->createElement($key);
						$this->chooseTranslator($element, $val);
						$rootNode->appendChild($element);
						break;
					}
				}
			}
		}


		protected function isKeyANull($key) {
			return $this->getSubKey($key) == "void";
		}

		protected function isKeyAFull($key) {
			return $this->getSubKey($key) == "full";
		}


		protected function isKeyAnAttribute($key) {
			$subKey = $this->getSubKey($key);
			return ($subKey == "attr" || $subKey == "attribute");
		}


		protected function isKeyANode($key) {
			return ($this->getSubKey($key) == "node");
		}

		protected function isKeyNodes($key) {
			return ($this->getSubKey($key) == "nodes");
		}

		protected function isKeySubnodes($key) {
			return ($this->getSubKey($key) == "subnodes");
		}


		protected function isKeyXml($key) {
			return ($this->getSubKey($key) == "xml");
		}


		protected function isKeyXLink($key) {
			return ($this->getSubKey($key) == "xlink");
		}

		protected function isKeyComment($key) {
			return ($this->getSubKey($key) == "comment");
		}


		public static function getRealKey($key) {
			$first = substr($key, 0, 1);
			if(isset(self::$shortKeys[$first])) {
				return substr($key, 1);
			}

			if($pos = strpos($key, ":")) {
				++$pos;
			} else {
				$pos = 0;
			}
			return substr($key, $pos);
		}

		public static function getSubKey($key) {
			$first = substr($key, 0, 1);
			if(isset(self::$shortKeys[$first])) {
				return self::$shortKeys[$first];
			}

			if($pos = strpos($key, ":")) {
				return substr($key, 0, $pos);
			} else {
				return false;
			}
		}
	};


	class baseRestrictionWrapper extends translatorWrapper {
		public function translate($data) {
			return $this->translateData($data);
		}
		
		protected function translateData(baseRestriction $restriction) {
			return array(
				'attribute:id'				=> $restriction->getId(),
				'attribute:name'			=> $restriction->getClassName(),
				'attribute:field-type-id'	=> $restriction->getFieldTypeId(),
				'node:title'				=> $restriction->getTitle()
			);
		}
	};


	class domainMirrowWrapper extends translatorWrapper {
		public function translate($data) {
			return $this->translateData($data);
		}
		
		protected function translateData(iDomainMirrow $domainMirrow) {
			return array(
				'attribute:id'		=> $domainMirrow->getId(),
				'attribute:host'	=> $domainMirrow->getHost(),
			);
		}
	};


	class domainWrapper extends translatorWrapper {
		public function translate($data) {
			return $this->translateData($data);
		}

		protected function translateData(iDomain $domain) {
			return array(
				'attribute:id'		=> $domain->getId(),
				'attribute:host'	=> $domain->getHost(),
				'attribute:lang-id'	=> $domain->getDefaultLangId(),
				'attribute:is-default'=> $domain->getIsDefault()
			);
		}
	};


	class langWrapper extends translatorWrapper {
		public function translate($data) {
			return $this->translateData($data);
		}
		
		protected function translateData(iLang $lang) {
			$resultArray = array();
			$resultArray['attribute:id'] = $lang->getId();
			$resultArray['attribute:prefix'] = $lang->getPrefix();
			if ($lang->getIsDefault()) {
				$resultArray['attribute:is-default'] = 1;
			}
			
			$cmsController = cmsController::getInstance();
			$langId = $cmsController->getCurrentLang()->getId();
			if($langId == $lang->getId()) {
				$resultArray['attribute:is-current'] = 1;
			}
			
			$resultArray['node:title'] = $lang->getTitle();

			return $resultArray;
		}
	};


	class publicExceptionWrapper extends translatorWrapper {
		public function translate($data) {
			return $this->translateData($data);
		}
		
		protected function translateData(publicException $exception) {
			return array(
				'error' => array(
					'node:msg' => def_module::parseTPLMacroses($exception->getMessage())
				)
			);
		}
	};


	class templateWrapper extends translatorWrapper {
		public function translate($data) {
			return $this->translateData($data);
		}

		protected function translateData(iTemplate $template) {
			$resultArray = Array();
			$resultArray['attribute:id'] = $template->getId();
			$resultArray['attribute:title'] = $template->getTitle();
			$resultArray['attribute:name'] = $template->getName();
			$resultArray['attribute:type'] = $template->getType();
			$resultArray['attribute:filename'] = $template->getFilename();
			$resultArray['attribute:domain-id'] = $template->getDomainId();
			$resultArray['attribute:lang-id'] = $template->getLangId();

			if($template->getIsDefault()) {
				$resultArray['attribute:is-default'] = true;
			}

			return $resultArray;
		}
	};


	class umiDateWrapper extends translatorWrapper {
		public function translate($data) {
			return $this->translateData($data);
		}

		protected function translateData(iUmiDate $date) {
			return array(
				'attribute:unix-timestamp'	=> $date->getFormattedDate('U'),
				'attribute:rfc'				=> $date->getFormattedDate('r'),
				'attribute:formatted-date' 	=> $date->getFormattedDate("d.m.Y H:i"),
				'node:std'					=> $date->getFormattedDate()
			);
		}
	};


	class umiFieldsGroupWrapper extends translatorWrapper {
		public function translate($data) {
			return $this->translateData($data);
		}
		
		public function translateProperties(iUmiFieldsGroup $group, iUmiObject $object) {
			$groupId = $group->getId();
			$groupName = $group->getName();
			$groupTitle = $group->getTitle();

			$groupArray = array();
			$groupArray['attribute:id'] = $groupId;
			$groupArray['attribute:name'] = $groupName;
			$groupArray['title'] = $groupTitle;

			$fields = $group->getFields();
			$groupArray['nodes:property'] = Array();

			$i = 0;
			$hasFilledProps = false;
			foreach($fields as $fieldId => $field) {
				$fieldName = $field->getName();
				$property = $object->getPropByName($fieldName);

				if(is_null($property)) continue;

				$propArray = translatorWrapper::get($property)->translate($property);

				if(!empty($propArray)) {
					$hasFilledProps = true;
					$groupArray['nodes:property'][(getRequest('jsonMode') == "force" ? $i++ : ++$i)] = $propArray;
				}
			}

			return ($hasFilledProps) ? $groupArray : array();
		}
		
		protected function translateData(iUmiFieldsGroup $group) {
			$resultArray = array(
				'attribute:id'		=> $group->getId(),
				'attribute:name'	=> $group->getName(),
				'attribute:title'	=> $group->getTitle()
			);

			if($group->getIsVisible()) {
				$resultArray['attribute:visible'] = "visible";
			}

			if($group->getIsLocked()) {
				$resultArray['attribute:locked'] = "locked";
			}

			$resultArray['nodes:field'] = $group->getFields();

			return $resultArray;
		}
	};


	class umiFieldTypeWrapper extends translatorWrapper {
		public function translate($data) {
			return $this->translateData($data);
		}
		
		protected function translateData(iUmiFieldType $fieldType) {
			$resultArray = array(
				'attribute:id'			=> $fieldType->getId(),
				'attribute:name'		=> $fieldType->getName(),
				'attribute:data-type'	=> $fieldType->getDataType()
			);

			if($fieldType->getIsMultiple()) {
				$resultArray['attribute:multiple'] = "multiple";
			}

			return $resultArray;
		}
	};


	class umiFieldWrapper extends translatorWrapper {
		public function translate($data) {
			return $this->translateData($data);
		}
		
		public function translateData(iUmiField $field) {
			$resultArray = array(
				'attribute:id'				=> $field->getId(),
				'attribute:name'			=> $field->getName(),
				'attribute:title'			=> $field->getTitle(),
				'attribute:field-type-id'	=> $field->getFieldTypeId()
			);
			

			if($field->getIsVisible()) {
				$resultArray['attribute:visible'] = "visible";
			}

			if($field->getIsInheritable()) {
				$resultArray['attribute:inheritable'] = "inheritable";
			}

			if($field->getIsLocked()) {
				$resultArray['attribute:locked'] = "locked";
			}

			if($field->getIsInFilter()) {
				$resultArray['attribute:filterable'] = "filterable";
			}

			if($field->getIsInSearch()) {
				$resultArray['attribute:indexable'] = "indexable";
			}

			if($guide_id = $field->getGuideId()) {
				$resultArray['attribute:guide-id'] = $guide_id;
			}

			if($tip = $field->getTip()) {
				$resultArray['tip'] = $tip;
			}

			if($field->getIsRequired()) {
				$resultArray['attribute:required'] = "required";
			}

			if($restrictionId = $field->getRestrictionId()) {
				$resultArray['restriction'] = baseRestriction::get($restrictionId);
			}
			
			$resultArray['type'] = $field->getFieldType();

			return $resultArray;
		}
	};


	class umiFileWrapper extends translatorWrapper {
		public function translate($data) {
			return $this->translateData($data);
		}
		
		protected function translateData(iUmiFile $file) {
			$resultArray = array(
				'attribute:path'	=> $file->getFilePath(),
				'attribute:size'	=> $file->getSize(),
				'attribute:ext'		=> $file->getExt(),
				'node:src'			=> $file->getFilePath(true)
			);

			if(get_class($file) === "umiImageFile") {
				$resultArray['attribute:width'] = $file->getWidth();
				$resultArray['attribute:height'] = $file->getHeight();
			}
			
			return $resultArray;
		}
	};


	class umiHierarchyElementWrapper extends translatorWrapper {
		public function translate($data) {
			return $this->translateData($data);
		}
		
		protected function translateData(iUmiHierarchyElement $element) {
			$elementId = $element->getId();
			$resultArray = array();
			
			$cmsController = cmsController::getInstance();
			$hierarchy = umiHierarchy::getInstance();
			$hierarchyTypes = umiHierarchyTypesCollection::getInstance();
			$objectTypes = umiObjectTypesCollection::getInstance();
			$objects = umiObjectsCollection::getInstance();
			$regedit = regedit::getInstance();

			$resultArray['@id'] = $elementId;
			$resultArray['@parentId'] = $element->getParentId();
			$resultArray['@link'] = $hierarchy->getPathById($elementId);

			if($is_default = $element->getIsDefault()) {
				$resultArray['@is-default'] = $is_default;
			}

			if($is_visible = $element->getIsVisible()) {
				$resultArray['@is-visible'] = $is_visible;
			}

			if($is_active = $element->getIsActive()) {
				$resultArray['@is-active'] = $is_active;
			}
			
			if($is_deleted = $element->getIsDeleted()) {
				$resultArray['@is-deleted'] = $is_deleted;
			}
			
			$lockedId = $element->getObject()->getValue("lockuser");
			if($lockedId > 0) {
				$lockTime = $element->getObject()->getValue("locktime");
				$currentUser = $cmsController->getModule("users")->user_id;
				$lockDuration = $regedit->getVal("//settings/lock_duration");
				if ($lockTime && ($lockTime->timestamp + $lockDuration) > time()) {
					if ($currentUser!= $lockedId) {
						$lockInfo['user-id'] = $lockedId;
						$whoLocked = $objects->getObject($lockedId);
						$lockInfo['login'] = $whoLocked->getValue("login");
						$lockInfo['lname'] = $whoLocked->getValue("lname");
						$lockInfo['fname'] = $whoLocked->getValue("fname");
						$lockInfo['father-name'] = $whoLocked->getValue("father_name");
						$lockInfo ['locktime'] = $lockTime->getFormattedDate();
						$lockInfo ['@ts'] = $lockTime->timestamp;
						$resultArray['locked-by'] = $lockInfo;
					}
				} else {
					$object = $element->getObject();
					$object->setValue("lockuser", null);
					$object->setValue("locktime", null);
					$object->commit();
					$element->commit();
				}
			}
			$page = $element->getObject();
			$expirationTime = $page->getValue("expiration_date");

			$pubStatusId = $page->getValue("publish_status");
			$statusObject = $objects->getObject($pubStatusId);
			$status = array();
			if ($regedit->getVal("//settings/expiration_control")) {
				if ($statusObject) {
					$status['attribute:id'] = strlen($tmp = $statusObject->getValue("publish_status_id")) ? $tmp : 'page_status_publish';
					$status['node:name'] = $statusObject->getName();
					$expiration['status'] = $status;
					if ($expirationTime) {
						$expiration['attribute:ts'] = $expirationTime->timestamp;
						$expiration['date'] = $expirationTime->getFormattedDate();
						$expiration['comments'] = $page->getValue("publish_comments");
					}
				}else {
					$status['@id'] = 'page_status_publish';
					$status['#name'] = getLabel ('object-status-publish');
					$expiration['status'] = $status;
					$expiration['@ts'] = "";

				}
				$resultArray['expiration'] = $expiration;
			}
			if(!is_null(getRequest('virtuals'))) {
				$aVirtuals = $hierarchy->checkIsVirtual(array($elementId => false));
				if(isset($aVirtuals[$elementId]) && $aVirtuals[$elementId]) {
					$resultArray['virtual-copy'] = array('attribute:count' => $aVirtuals[$elementId]);
				}
			}

			$resultArray['@object-id'] = $element->getObject()->getId();
			$resultArray['@object-guid'] = $element->getObject()->getGUID();
			$resultArray['@type-id'] = $element->getObject()->getTypeId();
			$resultArray['@type-guid'] = $element->getObject()->getTypeGUID();
			$resultArray['@update-time'] = $element->getUpdatetime();
			$resultArray['@alt-name'] = $element->getAltName();



			if(!is_null(getRequest('templates'))) {
				$resultArray['@template-id'] = $element->getTplId();
				$resultArray['@domain-id'] = $element->getDomainId();
				$resultArray['@lang-id'] = $element->getLangId();
			}

			if(!is_null(getRequest('childs'))) {
				$childs = $hierarchy->getChildsCount($elementId, true, true, 1);
				$resultArray['childs'] = $childs;
			}

			if(!is_null(getRequest('permissions'))) {
				$permissionsColletion = permissionsCollection::getInstance();
				$permissionsLevel = $permissionsColletion->isAllowedObject($permissionsColletion->getUserId(), $elementId);
				$resultArray['permissions'] = ($permissionsLevel[4] ? 16 : 0) |
											  ($permissionsLevel[3] ?  8 : 0) |
											  ($permissionsLevel[2] ?  4 : 0) |
											  ($permissionsLevel[1] ?  2 : 0) |
											  ($permissionsLevel[0] ?  1 : 0);
			}

			$hierarchy_type_id = $element->getTypeId();
			$hierarchy_type = $hierarchyTypes->getType($hierarchy_type_id);

			if(!is_null(getRequest('links')) && !$element->isDeleted) {
				$elementModuleName = $hierarchy_type->getName();
				if($elementModuleInstance = $cmsController->getModule($elementModuleName)) {
					$links = $elementModuleInstance->getEditLink($elementId, $hierarchy_type->getExt());

					if(is_array($links)) {
						if($links[0]) {
							$resultArray['create-link'] = $links[0];
						}

						if($links[1]) {
							$resultArray['edit-link'] = $links[1];
						}
					}
				}
			}

			if($hierarchy_type instanceof iUmiHierarchyType) {
				$resultArray['basetype'] = $hierarchy_type;
			}

			$resultArray['name'] = str_replace(array("<",">"), array('&lt;', '&gt;'),$element->getName());


			if($this->isFull == false) {
				$resultArray['xlink:href'] = "upage://" . $elementId;
				return $resultArray;
			}


			$object = $element->getObject();
			$objectTypeId = $object->getTypeId();
			$objectType = $objectTypes->getType($objectTypeId);
			$objectFieldsGroupsList = $objectType->getFieldsGroupsList();

			$resultArray['properties'] = array('nodes:group' => array());

			$i = 0;
			foreach($objectFieldsGroupsList as $group) {
				$groupWrapper = translatorWrapper::get($group);
				$grouparray = $groupWrapper->translateProperties($group, $object);
				if(!empty($grouparray)) {
					$resultArray['properties']['nodes:group'][(getRequest('jsonMode') == "force" ? $i++ : ++$i)] = $grouparray;
				}
			}

			return $resultArray;
		}
	}


	class umiHierarchyTypeWrapper extends translatorWrapper {
		public function translate($data) {
			return $this->translateData($data);
		}
		
		protected function translateData(iUmiHierarchyType $type) {
			return array(
				'attribute:id'		=> $type->getId(),
				'attribute:module'	=> $type->getName(),
				'attribute:method'	=> $type->getExt(),
				'node:title'		=> $type->getTitle()
			);
		}
	}


	class umiObjectPropertyWrapper extends translatorWrapper {
		public static $showEmptyFields = false;

		public function translate($data) {
			return $this->translateData($data);
		}

		protected function translateData(iUmiObjectProperty $property) {
			$resultArray = array();

			$value = $property->getValue();
			$field = $property->getField();

			$fieldId = $field->getId();
			$fieldName = $field->getName();
			$fieldTitle = $field->getTitle();
			$fieldType = $field->getFieldType();
			$fieldDataType = $fieldType->getDataType();

			if(($fieldDataType == "password" && !xmlTranslator::$showUnsecureFields) || (in_array($fieldName, array('user_dock', 'user_settings_data', 'activate_code')) && !xmlTranslator::$showUnsecureFields)) {
				return false;
			}


			$has_value = (is_object($value)) || (is_array($value) && !empty($value)) || (!is_array($value) && strlen($value));

			if($has_value || self::$showEmptyFields || translatorWrapper::$showEmptyFields) {
				$resultArray['@id'] = $fieldId;
				$resultArray['@name'] = $fieldName;
				$resultArray['@type'] = $fieldDataType;

				if($fieldDataType == 'relation' && $field->getFieldType()->getIsMultiple()) {
					$resultArray['@multiple'] = 'multiple';
				}

				$resultArray['title'] = $fieldTitle;
				if ($fieldDataType == 'price') {

					$eshopCur = regedit::getInstance()->getVal("//modules/eshop/default_currency_code");
					if ($eshopCur) {
						$currencyId = umiBasket::getInstance()->getCurrencyIdBySId($eshopCur);
						if ($currencyId) {
							$currency = umiObjectsCollection::getInstance()->getObject($currencyId);
							if ($currency) {
								$resultArray['currency'] = array(
									'@id' => $currencyId,
									'@code' => $currency->getValue('eshop_currency_letter_code'),
									'@symbol' => $currency->getValue('eshop_currency_symbol'),
									'@rate' => $currency->getValue('eshop_currency_exchange_rate')
								);
								$resultArray['curSymb'] = $currency->getValue("eshop_currency_symbol"); //For previous versions
							}
						}
					}
				}

				$resultArray['value'] = array();

				switch($fieldDataType) {
					case "symlink": {
						$resultArray['value']['nodes:page'] = array();
						foreach($value as $element) {
							$resultArray['value']['nodes:page'][] = $element;
						}
						break;
					}


					case "relation": {
						$objects = umiObjectsCollection::getInstance();
						$resultArray['value']['nodes:item'] = array();

						if(is_array($value)) {
							foreach($value as $objectId) {
								$resultArray['value']['nodes:item'][] = $objects->getObject($objectId);
							}
						} else {
							$resultArray['value']['item'] = $objects->getObject($value);
						}
						break;
					}

					case "date": {
						if($value instanceof iUmiDate) {
							$magicMethods = array('get_editable_region', 'save_editable_region');
							$cmsController = cmsController::getInstance();
							$format = (in_array($cmsController->getCurrentMethod (), $magicMethods)) ? false : 'r';

							$resultArray['value']['@formatted-date'] = $value->getFormattedDate("d.m.Y H:i");
							$resultArray['value']['@unix-timestamp'] = $value->getFormattedDate("U");
							$resultArray['value']['#rfc'] = $value->getDateTimeStamp() > 0 ? $value->getFormattedDate($format) : "";
						}

						break;
					}

					case "optioned": {
						$options = array();
						$hierarchy = umiHierarchy::getInstance();
						$objects = umiObjectsCollection::getInstance();

						foreach($value as $val) {
							$optionInfo = array();

							foreach($val as $type => $sval) {
								switch ($type) {
									case "tree": {
										$element = $hierarchy->getElement($sval);
										if($element instanceof iUmiHierarchyElement) {
											$optionInfo['page'] = $element;
										}
										break;
									}

									case "rel": {
										$object = $objects->getObject($sval);
										if($object instanceof iUmiObject) {
											$optionInfo['object'] = $object;
										}
										break;
									}

									default:
										$optionInfo['@' . $type] = $sval;
								}
							}


							$options[] = $optionInfo;
						}
						$resultArray['value']['nodes:option'] = $options;
						break;
					}

					case "price":
						$resultArray['value']['xlink:href'] = 'udata://emarket/price/' . $property->getObjectId();
					default: {
						if(is_array($value)) {
							unset($resultArray['value']);
							$resultArray['nodes:value'] = $value;
							if($fieldDataType == 'tags') {
								$resultArray['combined'] = implode(', ', $value);;
							}
						} else {
							$cmsController = cmsController::getInstance();
							//$value = system_parse_short_calls($value, false, $property->getObjectId());
							$value = xmlTranslator::executeMacroses($value, false, $property->getObjectId());

							if(defined("XML_PROP_VALUE_MODE") && $fieldDataType == "wysiwyg" && $cmsController->getCurrentMode() != "admin") {
								if(XML_PROP_VALUE_MODE == "XML") {
									$resultArray['value'] = Array("xml:xvalue" => "<xvalue>" . $value . "</xvalue>");
									break;
								}
							}

							if($value && in_array($fieldDataType, array('img_file', 'swf_file', 'file'))) {
								$value = $value->getFilePath(true);
								$info = getPathInfo($value);

								$regexp = "|^".CURRENT_WORKING_DIR."|";
								$value  = preg_replace($regexp, "", $value);

								$resultArray['value']['@path'] = '.' . $value;
								$resultArray['value']['@folder'] = preg_replace($regexp, "", $info['dirname']);
								$resultArray['value']['@name'] = $info['filename'];
								$resultArray['value']['@ext'] = $info['extension'];

								if(in_array($fieldDataType, array('img_file', 'swf_file'))) {
									$arr = getimagesize('.' . $value);
									if(is_array($arr)) {
										$resultArray['value']['@width'] = $arr[0];
										$resultArray['value']['@height'] = $arr[1];
									}
								}
							}

							$resultArray['value']['#value'] = $value;
						}
						break;
					}
				}
			}
			return $resultArray;
		}
	};


	class umiObjectTypeWrapper extends translatorWrapper {
		public function translate($data) {
			return $this->translateData($data);
		}
		
		protected function translateData(iUmiObjectType $type) {
			$resultArray = Array();
			$resultArray['attribute:id'] = $type->getId();
			$resultArray['attribute:guid'] = $type->getGUID();
			$resultArray['attribute:title'] = $type->getName();
			$resultArray['attribute:parent-id'] = $type->getParentId();
			
			if(!is_null(getRequest('childs'))) {
				$resultArray['attribute:parentId'] = $type->getParentId();
			}

			if($type->getIsGuidable()) {
				$resultArray['attribute:guide'] = "guide";
			}

			if($type->getIsPublic()) {
				$resultArray['attribute:public'] = "public";
			}

			if($type->getIsLocked()) {
				$resultArray['attribute:locked'] = "locked";
			}

			$hierarchyTypeId = $type->getHierarchyTypeId();
			$hierarchyType = umiHierarchyTypesCollection::getInstance()->getType($hierarchyTypeId);
			$resultArray['base'] = $hierarchyType;
			
			if(!is_null(getRequest('childs'))) {
				$childs = umiObjectTypesCollection::getInstance()->getSubTypesList($type->getId());
				$resultArray['childs'] = sizeof($childs);
			}
			
			if(!is_null(getRequest('links'))) {
				
				$cmsController = cmsController::getInstance();
				$currentModuleName = $cmsController->getCurrentModule();
				$module = $cmsController->getModule($currentModuleName);
				if($module instanceof def_module) {
					$links = $module->getObjectTypeEditLink($type->getId());
					$resultArray['create-link'] = $links['create-link'];
					$resultArray['edit-link'] = $links['edit-link'];
				}
			}

			if($this->isFull) {
				$groupsArray = Array();
				$groupsArray['nodes:group'] = $type->getFieldsGroupsList(xmlTranslator::$showHiddenFieldGroups);
				$resultArray['fieldgroups'] = $groupsArray;
			}

			return $resultArray;
		}
	};


	class umiObjectWrapper extends translatorWrapper {
		public function translate($data) {
			return $this->translateData($data);
		}

		protected function translateData(iUmiObject $object) {
			$objectId = $object->getId();
			$resultArray = Array();

			$resultArray['attribute:id'] = $objectId;
			$resultArray['attribute:guid'] = $object->getGUID();
			$resultArray['attribute:name'] = $object->getName();
			$resultArray['attribute:type-id'] = $object->getTypeId();
			$resultArray['attribute:type-guid'] = $object->getTypeGUID();

			$ownerId = $object->getOwnerId();
			if($ownerId) {
				$resultArray['attribute:ownerId'] = $ownerId;
			}
			if($this->isFull === false) {
				$resultArray['xlink:href'] = "uobject://" . $objectId;
				return $resultArray;
			}

			$objectTypeId = $object->getTypeId();
			$objectType = umiObjectTypesCollection::getInstance()->getType($objectTypeId);
			$objectFieldsGroupsList = $objectType->getFieldsGroupsList();


			if(!is_null(getRequest('links'))) {
				$cmsController = cmsController::getInstance();
				$hierarchyTypesColleciton = umiHierarchyTypesCollection::getInstance();
				$objectTypesCollection    = umiObjectTypesCollection::getInstance();
				$workType = $objectType;

				$i = 0;
				do {
					$hierarchyTypeId = $workType->getHierarchyTypeId();
					$hierarchyType   = $hierarchyTypesColleciton->getType($hierarchyTypeId);
					if($workType->getParentId()) {
						$workType = $objectTypesCollection->getType($workType->getParentId());
						break;
					}
					if($workType->getParentId() == 0) break;
				} while(!$hierarchyType && $workType);

				if($hierarchyType instanceof iUmiHierarchyType) {
					$moduleName = $hierarchyType->getName();
					$methodName = $hierarchyType->getExt();

					if($objectModuleInstance = $cmsController->getModule($moduleName)) {
						$link = $objectModuleInstance->getObjectEditLink($objectId, $methodName);

						if($link !== false) {
							$resultArray['edit-link'] = $link;
						}
					}
				}

				if(!isset($resultArray['edit-link']) &&
				$cmsController->getCurrentModule() == 'data' && $cmsController->getCurrentMethod() == 'guide_items') {
					$dataModuleInstance = $cmsController->getModule('data');
					$resultArray['edit-link'] = $dataModuleInstance->getObjectEditLink($objectId);
				}
			}


			$resultArray['properties'] = Array();
			$resultArray['properties']['nodes:group'] = Array();
			$i = 0;
			foreach($objectFieldsGroupsList as $group) {
				$groupArray = Array();

				$groupWrapper = translatorWrapper::get($group);
				$groupArray = $groupWrapper->translateProperties($group, $object);

				if(!empty($groupArray)) {
					$resultArray['properties']['nodes:group'][(getRequest('jsonMode') == "force" ? $i++ : ++$i)] = $groupArray;
				}
			}

			if(sizeof($resultArray['properties']['nodes:group']) == 0) {
				unset($resultArray['properties']);
			}

			return $resultArray;
		}
	};


	interface iUmiExporter {
		public function __construct($type);
		static public function get($className);
		public function getFileExt();
	}



	abstract class umiExporter implements iUmiExporter {
		protected $type = "";
		protected $file_path = false;
		protected $complete = false;
		protected $source_name = false;
		protected $completed = true;

		abstract public function export($stems);
		abstract public function setOutputBuffer();

		final static public function get($className) {
			if($wrapper = self::loadWrapper($className)) {
				return $wrapper;
			} else {
				throw new publicException("Can't load exporter for type \"{$className}\"");
			}
		}

		public function __construct($type) {
			$this->type = $type;
		}

		public function getFileExt() {
			return "xml";
		}

		public function setSourceName($source_name = false) {
			$this->source_name = $source_name;
		}

		public function getSourceName() {
			return $this->source_name ? $this->source_name : $this->type;
		}

		public function getIsCompleted() {
			return $this->completed;
		}


		final static private function loadWrapper($className) {
			static $loaded = array(), $config;

			if(isset($loaded[$className])) {
				return $loaded[$className];
			}

			if(is_null($config)) {
				$config = mainConfiguration::getInstance();
			}


			$wrapperClassName = $className . 'Exporter';
			$filePath = $config->includeParam('system.kernel') . 'subsystems/export/exporters/' . $wrapperClassName . '.php';
			if(is_file($filePath) == false) {
				$loaded[$className] = false;
				throw new publicException("Can't load exporter \"{$filePath}\" for \"{$className}\" file type");
			}

			require $filePath;

			if(!class_exists($wrapperClassName)) {
				$loaded[$className] = false;
				throw new publicException("Exporter class \"{$wrapperClassName}\" not found");
			}

			$wrapper = new $wrapperClassName($className);

			if($wrapper instanceof self == false) {
				$loaded[$className] = false;
				throw new publicException("Exporter class \"{$wrapperClassName}\" should be instance of umiExporter");
			}

			return $loaded[$className] = $wrapper;

		}

		protected function getUmiDump($branches, $source_name = false) {
			if (!$source_name) {
				$source_name = $this->getSourceName();
			}
			$exporter = new xmlExporter($source_name);
			$exporter->addBranches($branches);
			$exporter->setIgnoreRelations();
			$result = $exporter->execute();

			return $result->saveXML();
		}

		protected function getUmiDumpObjects($objects, $source_name = false) {
			if (!$source_name) {
				$source_name = $this->getSourceName();
			}
			$exporter = new xmlExporter($source_name);
			$exporter->addObjects($objects);
			$exporter->setIgnoreRelations();
			$result = $exporter->execute();

			return $result->saveXML();
		}


	}




	interface iXmlExporter {
		
	}



	class xmlExporter implements iXmlExporter {

		const VERSION = "2.0";

		protected static $ROOT_PAGE_TYPE_ID; // id корневого типа "Раздел сайта"

		protected $source_id, $source_name;
		protected $files, $types, $langs, $domains, $templates, $elements, $branches, $objects, $restrictions, $registry, $data_types, $directories;
		protected $exported_files = array(), $exported_types = array(), $exported_langs = array(), $exported_domains = array(), $exported_templates = array(), $exported_elements = array(), $exported_objects = array(), $exported_restrictions = array(), $exported_registry_items = array(), $restricted_fields = array(), $exported_data_types = array(), $exported_dirs = array();
		protected $limit, $position = 0, $break = false;
		protected $translator;
		protected $destination;
		protected $completed = false;

		protected $doc;
		protected $root;
		protected $meta_container, $files_container, $types_container, $data_types_container, $pages_container, $objects_container, $relations_container, $restrictions_container, $registry_container, $dirs_container, $hierarchy_container;

		protected	$export_log = array();

		protected $showAllFields = false;

		protected $ignoreRelations = false;
		protected $saveRelations = array(); //files, langs, domains, templates, objects, fields_relations, restrictions, permissions, hierarchy
		protected $oldGetLinks = NULL;

		public function __construct($source_name, $entities_limit = false) {
			$this->relations = umiImportRelations::getInstance();
			$this->source_name = $source_name;
			$this->source_id = $this->relations->addNewSource($source_name);
			$this->limit = is_numeric($entities_limit) ? $entities_limit : false;

			self::$ROOT_PAGE_TYPE_ID = umiObjectTypesCollection::getInstance()->getTypeIdByGUID('root-pages-type');
		}

		public function setIgnoreRelations($saveRelations = array()) {
			$this->ignoreRelations = true;
			$this->saveRelations = $saveRelations;
		}

		public function setShowAllFields($showAllFields = false) {
			$this->showAllFields = $showAllFields;
		}

		public function getExportLog() {
			return $this->export_log;
		}

		protected function writeLog($message) {
			if (defined('UMICMS_CLI_MODE') && UMICMS_CLI_MODE) echo $message . "\n\r";
			else $this->export_log[] = $message;
		}

		protected function reportError($error) {
			if (defined('UMICMS_CLI_MODE') && UMICMS_CLI_MODE) echo $error . "\n\r";
			else $this->export_log[] = "<font style='color:red''>" . $error . "</font>";
		}

		protected function saveState () {

			if (file_exists(CURRENT_WORKING_DIR . '/sys-temp/runtime-cache/' . md5($this->source_name)) && $this->break === false) {
				unlink(CURRENT_WORKING_DIR . '/sys-temp/runtime-cache/' . md5($this->source_name));
			}

			if ($this->break === true) {

				$keys = array_keys($this->exported_types, 'found');
				foreach ($keys as $key => $value) {
					unset($this->exported_types[$value]);
				}

				$keys = array_keys($this->exported_elements, 'found');
				foreach ($keys as $key => $value) {
					unset($this->exported_elements[$value]);
				}

				$keys = array_keys($this->exported_objects, 'found');
				foreach ($keys as $key => $value) {
					unset($this->exported_objects[$value]);
				}

				$array = array(
					'exported_files' => $this->exported_files,
					'exported_types' => $this->exported_types,
					'exported_langs' => $this->exported_langs,
					'exported_domains' => $this->exported_domains,
					'exported_templates' => $this->exported_templates,
					'exported_elements' => $this->exported_elements,
					'exported_objects' => $this->exported_objects,
					'restricted_fields' =>$this->restricted_fields,
					'restrictions' => $this->restrictions,
					'exported_restrictions' => $this->exported_restrictions,
					'exported_registry_items'=> $this->exported_registry_items,
					'exported_data_types'=> $this->exported_data_types,
					'exported_dirs'=> $this->exported_dirs
				);

				file_put_contents(CURRENT_WORKING_DIR . '/sys-temp/runtime-cache/' . md5($this->source_name),  serialize($array));
			}
		}

		public function addElements($elements) {
			foreach ($elements as $el) {
				if ($el instanceof umiHierarchyElement) $el = $el->getId();
				$this->elements[] = $el;
			}
		}

		public function addBranches($branches) {
			foreach ($branches as $el) {
				if ($el instanceof umiHierarchyElement) $el = $el->getId();
				$this->branches[] = $el;
			}
		}

		public function addObjects($objects) {
			foreach ($objects as $obj) {
				if ($obj instanceof umiObject) $obj = $obj->getId();
				if ($obj) $this->objects[] = $obj;
			}
		}

		public function addTypes($types) {
			foreach ($types as $type) {
				if ($type instanceof umiObjectType) $type = $type->getId();
				$this->types[] = $type;
			}
		}

		public function addRestrictions($restrictions) {
			foreach ($restrictions as $restriction) {
				if ($restriction instanceof baseRestriction) $restriction = $restriction->getId();
				$this->restrictions[] = $restriction;
			}
		}

		public function addRegistry($paths = array()) {
			foreach ($paths as $path) {
				$this->registry[] = $path;
			}
		}

		public function setDestination($destination) {
			if (!is_dir($destination)) {
				$this->reportError("Destination folder does not exist");
				return false;
			}
			$this->destination = $destination;
		}

		public function addFiles($fsObjects = array()) {
			foreach ($fsObjects as $fsObject) {
				if (is_file($fsObject)) $this->files[] = new umiFile($fsObject);
				else {
				$this->reportError("File {$fsObject} doesn't exist");
				}
			}
		}

		public function addDirs($fsObjects = array()) {
			foreach ($fsObjects as $fsObject) {
				if (is_dir($fsObject)) $this->directories[] = new umiDirectory($fsObject);
				else {
				$this->reportError("Folder {$fsObject} doesn't exist");
				}
			}
		}

		public function addDomains($domains = array()) {
			foreach ($domains as $domain) {
				if($domain instanceof domain) $this->domains[] = $domain;
			}
		}

		public function addLangs($langs = array()) {
			foreach ($langs as $lang) {
				if($lang instanceof lang) $lang = $lang->getId();
				$this->langs[] = $lang;
			}
		}

		public function addTemplates($templates = array()) {
			foreach ($templates as $template) {
				if($template instanceof template) $this->templates[] = $template;
			}
		}

		public function addDataTypes($data_types = array()) {
			foreach ($data_types as $data_type) {
				if($data_type instanceof umiFieldType) $this->data_types[] = $data_type->getId();
			}
		}

		public function isCompleted() {
			return $this->completed;
		}

		public function execute() {

			if(!is_null(getRequest('links'))) {
				$this->oldGetLinks = getRequest('links');
				unset($_REQUEST['links']);
			}

			$this->position = 0;
			$this->break = false;
			$doc = new DOMDocument("1.0", "utf-8");
			$doc->formatOutput = XML_FORMAT_OUTPUT;
			$root = $doc->createElement("umidump");
			$root->setAttribute('xmlns:xlink', 'http://www.w3.org/TR/xlink');

			$a = $doc->createAttribute("version");
			$a->appendChild($doc->createTextNode(self::VERSION));
			$root->appendChild($a);

			$doc->appendChild($root);

			$this->translator = new xmlTranslator($doc);

			if ($this->showAllFields) {
				$oldshowHiddenFieldGroups = xmlTranslator::$showHiddenFieldGroups;
				xmlTranslator::$showHiddenFieldGroups = true;
				$oldshowUnsecureFields = xmlTranslator::$showUnsecureFields;
				xmlTranslator::$showUnsecureFields = true;
			}

			$oldIgnoreCache = umiObjectProperty::$IGNORE_CACHE;
			umiObjectProperty::$IGNORE_CACHE = true;

			$this->doc = $doc;
			$this->root = $root;

			if (file_exists(CURRENT_WORKING_DIR . '/sys-temp/runtime-cache/' . md5($this->source_name))) {
				$array = unserialize(file_get_contents(CURRENT_WORKING_DIR . '/sys-temp/runtime-cache/' . md5($this->source_name)));
				$this->exported_files = $array['exported_files'];
				$this->exported_types = $array['exported_types'];
				$this->exported_langs = $array['exported_langs'];
				$this->exported_domains = $array['exported_domains'];
				$this->exported_templates = $array['exported_templates'];
				$this->exported_elements = $array['exported_elements'];
				$this->exported_objects = $array['exported_objects'];
				$this->exported_restrictions = $array['exported_restrictions'];
				$this->restricted_fields = $array['restricted_fields'];
				$this->restrictions = $array['restrictions'];
				$this->exported_registry_items = $array['exported_registry_items'];
				$this->exported_data_types = $array['exported_data_types'];
				$this->exported_dirs = $array['exported_dirs'];
			}

			$this->createGrid();

			if ($this->directories && !$this->break) $this->exportDirs();
			if ($this->files && !$this->break) $this->exportFiles();
			if ($this->langs && !$this->break) $this->exportLangs();
			if ($this->domains && !$this->break) $this->exportDomains();
			if ($this->templates && !$this->break) $this->exportTemplates();
			if ($this->data_types && !$this->break) $this->exportDataTypes();
			if ($this->types && !$this->break) $this->exportTypes();
			if ($this->objects && !$this->break) $this->exportObjects();
			if ($this->elements && !$this->break) $this->exportElements();
			if ($this->branches && !$this->break) $this->exportBranches();
			if ($this->restrictions && !$this->break) $this->exportRestrictions();
			if ($this->registry && !$this->break) $this->exportRegs();

			$d = $this->doc;
			$m = $this->meta_container;

			$this->completed = !$this->break;

			if (count($this->branches) && $this->completed) {
				// check branch id by relation
				$branches = array();
				foreach ($this->branches as $branch_id) {
					if (isset($this->exported_elements[$branch_id]) && $this->exported_elements[$branch_id] != 'found') {
						$branch_id = $this->exported_elements[$branch_id];
					}
					$branches[] = $branch_id;
				}
				$n = $d->createElement('branches');
				$this->translateEntity(array('nodes:id' => $branches), $n);
				$m->appendChild($n);
			}

			$this->saveState();

			if ($this->showAllFields) {
				xmlTranslator::$showHiddenFieldGroups = $oldshowHiddenFieldGroups;
				xmlTranslator::$showUnsecureFields = $oldshowUnsecureFields;
			}

			umiObjectProperty::$IGNORE_CACHE = $oldIgnoreCache;

			if(!is_null($this->oldGetLinks)) $_REQUEST['links'] = $this->oldGetLinks;

			return $this->doc;

		}


		protected function createDateSection($timestamp, DOMElement $container) {
			$d = $this->doc;
			$date = new umiDate($timestamp);

			$n = $d->createElement('timestamp');
			$n->appendChild($d->createTextNode($date->getFormattedDate("U")));
			$container->appendChild($n);

			$n = $d->createElement('rfc');
			$n->appendChild($d->createTextNode($date->getFormattedDate("r")));
			$container->appendChild($n);

			$n = $d->createElement('utc');
			$n->appendChild($d->createTextNode($date->getFormattedDate(DATE_ATOM)));
			$container->appendChild($n);

			return $container;
		}

		protected function createGrid() {
			// meta container
			$d = $this->doc;
			$m = $d->createElement("meta");

			$cmsController = cmsController::getInstance();
			$regedit = regedit::getInstance();
			$domain = $cmsController->getCurrentDomain();
			$lang = $cmsController->getCurrentLang();

			$n = $d->createElement('site-name');
			$n->appendChild($d->createCDATASection($regedit->getVal("//settings/site_name")));
			$m->appendChild($n);

			$n = $d->createElement('domain');
			$n->appendChild($d->createCDATASection($domain->getHost()));
			$m->appendChild($n);

			$n = $d->createElement('lang');
			$n->appendChild($d->createCDATASection($lang->getPrefix()));
			$m->appendChild($n);

			$n = $d->createElement('source-name');
			$val = strlen($this->source_name) ? $this->source_name : md5($domain->getId() . $lang->getId());
			$n->appendChild($d->createCDATASection($val));
			$m->appendChild($n);

			$n = $d->createElement('generate-time');
			$this->createDateSection(time(), $n);
			$m->appendChild($n);

			$this->root->appendChild($m);
			$this->meta_container = $m;

			// registry container
			$this->registry_container = $d->createElement('registry');
			$this->root->appendChild($this->registry_container);
			// directories container
			$this->dirs_container = $d->createElement('directories');
			$this->root->appendChild($this->dirs_container);
			// files container
			$this->files_container = $d->createElement('files');
			$this->root->appendChild($this->files_container);
			// langs container
			$this->langs_container = $d->createElement('langs');
			$this->root->appendChild($this->langs_container);
			// domains container
			$this->domains_container = $d->createElement('domains');
			$this->root->appendChild($this->domains_container);
			// templates container
			$this->templates_container = $d->createElement('templates');
			$this->root->appendChild($this->templates_container);
			// data_types container
			$this->data_types_container = $d->createElement('datatypes');
			$this->root->appendChild($this->data_types_container);
			// types container
			$this->types_container = $d->createElement('types');
			$this->root->appendChild($this->types_container);
			// objects container
			$this->objects_container = $d->createElement('objects');
			$this->root->appendChild($this->objects_container);
			// pages container
			$this->pages_container = $d->createElement('pages');
			$this->root->appendChild($this->pages_container);
			// relations container
			$this->relations_container = $d->createElement('relations');
			$this->root->appendChild($this->relations_container);
			// options container
			$this->options_container = $d->createElement('options');
			$this->root->appendChild($this->options_container);
			// restrictions container
			$this->restrictions_container = $d->createElement('restrictions');
			$this->root->appendChild($this->restrictions_container);
			// permissions container
			$this->permissions_container = $d->createElement('permissions');
			$this->root->appendChild($this->permissions_container);
			// hierarchy container
			$this->hierarchy_container = $d->createElement('hierarchy');
			$this->root->appendChild($this->hierarchy_container);

		}

		protected function translateEntity($entity, $container) {
			$result = $this->translator->chooseTranslator($container, $entity, true);
		}

		protected function exportFile(umiFile $file) {

			$path = $file->getFilePath();

			if (isset($this->exported_files[$path])) return false;

			if ($this->limit) {
				if ($this->position >= $this->limit) {
					 $this->break = true;
					 return false;
				}
			}

			$fileName = $file->getFileName();

			$c = $this->doc->createElement('file');
			$this->files_container->appendChild($c);
			$this->translateEntity($file, $c);

			$hash = md5_file($path);
			//set hash
			$hashAttribute = $this->doc->createAttribute("hash");
			$c->appendChild($hashAttribute);
			$hashText = $this->doc->createTextNode("{$hash}");
			$hashAttribute->appendChild($hashText);

			$fileName = $file->getFileName();
			$nameAttribute = $this->doc->createAttribute("name");
			$c->appendChild($nameAttribute);
			$nameText = $this->doc->createTextNode("{$fileName}");
			$nameAttribute->appendChild($nameText);

			if ($this->destination) {
				$filePath = $this->destination . $file->getFilePath(true);
				$filePathDir = dirname($filePath);

				if (!file_exists($filePathDir)) mkdir($filePathDir, 0777, true);
				if (copy($path, $filePath)) {
					chmod($filePath, 0777);
				} else {
					$this->reportError("File \"{$path} \" cannot be copied to \"{$filePath}\"");
				}
			} else {
				$this->reportError('Files cannot be copied because destination folder isn\'t defined');
			}

			$this->exported_files[$path] = $path;
			$this->position++;
			return true;
		}

		protected function exportDir(umiDirectory $directory) {

			$path = $directory->getPath();
			$nodeValue = ltrim($path, '.');

			if (isset($this->exported_dirs[$path])) return false;

			if ($this->limit) {
				if ($this->position >= $this->limit) {
					 $this->break = true;
					 return false;
				}
			}

			$c = $this->doc->createElement('directory', $nodeValue);
			$this->dirs_container->appendChild($c);

			$c->setAttribute('path', $path);
			$c->setAttribute('name', $directory->getName());

			$this->exported_dirs[$path] = $path;
			$this->position++;
			return true;
		}

		protected function exportFiles() {
			foreach ($this->files as $file) {
				$this->exportFile($file);
			}

			if ($this->destination) {
				$newDirectory = new umiDirectory($this->destination);
				$newDirectoryDirs = $newDirectory->getFSObjects(2);
				foreach ($newDirectoryDirs as $key => $dir) {
					chmod($dir, 0777);
				}
			}
		}

		protected function exportDirs() {
			foreach ($this->directories as $directory) {
				$this->exportDir($directory);
			}
		}

		protected function exportLang($langId) {
			if (isset($this->exported_langs[$langId])) return false;

			if ($this->limit) {
				if ($this->position >= $this->limit) {
					 $this->break = true;
					 return false;
				}
			}

			$lang = langsCollection::getInstance()->getLang($langId);

			$c = $this->doc->createElement('lang');
			$this->translateEntity($lang, $c);

			$rel_lang_id = $this->relations->getOldLangIdRelation($this->source_id, $langId);
			if ($rel_lang_id === false) {
				$this->relations->setLangIdRelation($this->source_id, $langId, $langId);
				$rel_lang_id = $langId;
			} else {
				$c->setAttribute('id', $rel_lang_id);
			}

			$this->langs_container->appendChild($c);
			$this->exported_langs[$langId] = $rel_lang_id;
			$this->position++;
			return true;
		}

		protected function exportLangs() {
			foreach ($this->langs as $lang) {
				$this->exportLang($lang);
			}
		}

		protected function exportDomain(domain $domain) {
			$domainId = $domain->getId();
			if (isset($this->exported_domains[$domainId])) return false;

			if ($this->limit) {
				if ($this->position >= $this->limit) {
					 $this->break = true;
					 return false;
				}
			}

			$c = $this->doc->createElement('domain');
			$this->translateEntity($domain, $c);

			$rel_domain_id = $this->relations->getOldDomainIdRelation($this->source_id, $domainId);
			if ($rel_domain_id === false) {
				$this->relations->setDomainIdRelation($this->source_id, $domainId, $domainId);
				$rel_domain_id = $domainId;
			} else {
				$c->setAttribute('id', $rel_domain_id);
			}

			//set lang
			$langId = $domain->getDefaultLangId();

			if ($this->exportLang($langId)) {
				if ($this->limit && $this->position >= $this->limit) {
					$this->break = true;
					return true;
				}
			}
			$rel_lang_id = $this->relations->getOldLangIdRelation($this->source_id, $langId);
			$c->setAttribute('lang-id', $rel_lang_id);

			$domainMirrors = $domain->getMirrowsList();
			foreach ($domainMirrors as $domainMirror) {

				$m = $this->doc->createElement('domain-mirror');
				$c->appendChild($m);
				$this->translateEntity($domainMirror, $m);

				$mirror_id = $domainMirror->getId();

				$rel_mirror_id = $this->relations->getOldDomainMirrorIdRelation($this->source_id, $mirror_id);
				if ($rel_mirror_id === false) {
					$this->relations->setDomainMirrorIdRelation($this->source_id, $mirror_id, $mirror_id);
					$rel_mirror_id = $mirror_id;
				} else {
					$m->setAttribute('id', $rel_mirror_id);
				}
			}

			$this->domains_container->appendChild($c);
			$this->exported_domains[$domainId] = $rel_domain_id;
			$this->position++;
			return true;
		}

		protected function exportDomains() {
			foreach ($this->domains as $domain) {
				$this->exportDomain($domain);
			}
		}

		protected function exportTemplate(template $template) {

			$templateId = $template->getId();

			if (isset($this->exported_templates[$templateId])) return false;

			if ($this->limit) {
				if ($this->position >= $this->limit) {
					 $this->break = true;
					 return false;
				}
			}

			$c = $this->doc->createElement('template');
			$this->translateEntity($template, $c);

			$rel_template_id = $this->relations->getOldTemplateIdRelation($this->source_id, $templateId);
			if ($rel_template_id === false) {
				$this->relations->setTemplateIdRelation($this->source_id, $templateId, $templateId);
				$rel_template_id = $templateId;
			} else {
				$c->setAttribute('id', $rel_template_id);
			}

			//set lang
			$langId = $template->getLangId();
			
			if($this->exportLang($langId)) {
				if ($this->limit && $this->position >= $this->limit) {
					$this->break = true;
					return true;
				}
			}
			$rel_lang_id = $this->relations->getOldLangIdRelation($this->source_id, $langId);
			$c->setAttribute('lang-id', $rel_lang_id);

			//set domain
			$domainId = $template->getDomainId();
			$domain = domainsCollection::getInstance()->getDomain($domainId);
			if ($this->exportDomain($domain)) {
				if ($this->limit && $this->position >= $this->limit) {
					$this->break = true;
					return true;
				}
			}
			$rel_domain_id = $this->relations->getOldDomainIdRelation($this->source_id, $domainId);
			$c->setAttribute('domain-id', $rel_domain_id);

			$this->templates_container->appendChild($c);
			$this->exported_templates[$templateId] = $rel_template_id;
			$this->position++;
			return true;
		}

		protected function exportTemplates() {
			foreach ($this->templates as $template) {
				$this->exportTemplate($template);
			}
		}

		protected function exportDataType($type_id) {
			$type = umiFieldTypesCollection::getInstance()->getFieldType($type_id);
			if (!$type instanceof umiFieldType) return false;

			if (isset($this->exported_data_types[$type_id])) return false;

			if ($this->limit) {
				if ($this->position >= $this->limit) {
					 $this->break = true;
					 return false;
				}
			}

			$c = $this->doc->createElement('datatype');
			$this->data_types_container->appendChild($c);
			$this->translateEntity($type, $c);

			$c->removeAttribute('id');

			$this->exported_data_types[$type_id] = $type_id;
		}

		protected function exportType($type_id) {
			$type = umiObjectTypesCollection::getInstance()->getType($type_id);
			if (!$type instanceof umiObjectType) return false;

			if (isset($this->exported_types[$type_id])) return false;

			if ($this->limit) {
				if ($this->position >= $this->limit) {
					 $this->break = true;
					 return false;
				}
			}

			$this->exported_types[$type_id] = 'found';

			// export parent type
			$parent_type_id = $type->getParentId();
			if ($parent_type_id) {
				if ($this->exportType($parent_type_id)){
					if ($this->limit && $this->position >= $this->limit) {
						$this->break = true;
						return true;
					}
				}
			}

			$c = $this->doc->createElement('type');
			$this->translateEntity($type, $c);

			// check type relation
			$rel_type_id = $this->relations->getOldTypeIdRelation($this->source_id, $type_id);
			if (!$rel_type_id) {
				$rel_type_id = ($type_id == self::$ROOT_PAGE_TYPE_ID) ? '{root-pages-type}' : $type_id;
				$this->relations->setTypeIdRelation($this->source_id, $rel_type_id, $type_id);
			}
			$c->setAttribute('id', $rel_type_id);

			// check parent type relations
			$parent_type_id = $type->getParentId();
			if ($parent_type_id) {
				$rel_parent_type_id = $this->relations->getOldTypeIdRelation($this->source_id, $parent_type_id);
				if ($rel_parent_type_id === false) {
					$rel_parent_type_id = ($parent_type_id == self::$ROOT_PAGE_TYPE_ID) ? '{root-pages-type}' : $parent_type_id;
					$this->relations->setTypeIdRelation($this->source_id, $rel_parent_type_id, $parent_type_id);
				}
				$c->setAttribute('parent-id', $rel_parent_type_id);
			}

			$parser = new DOMXPath($this->doc);

			if($parser->evaluate("base", $c)->length) {
				$base = $parser->evaluate("base", $c)->item(0);
				$base->removeAttribute('id');
			}

			// check fields relations
			if($parser->evaluate("fieldgroups/group", $c)->length) {
				foreach($parser->evaluate("fieldgroups/group", $c) as $group) {
					$groupId = $group->getAttribute('id');
					$typeGroup = $type->getFieldsGroup($groupId, true);
					if ($typeGroup->getIsActive()) {
						$group->setAttribute('active', 'active');
					} else {
						$group->setAttribute('active', '0');
					}
					if(!$typeGroup->getIsVisible()) {
						$group->setAttribute('visible', '0');
					}
					$group->removeAttribute('id');
				}
			}

			$relationsToExport = array();
			$fieldsCollection = umiFieldsCollection::getInstance();
			$nl = $parser->evaluate("fieldgroups/group/field", $c);
			foreach ($nl as $field) {
				$field_id = intval($field->getAttribute('id'));
				$field_name = $field->getAttribute('name');
				$rel_field_name = $this->relations->getOldFieldName($this->source_id, $type_id, $field_id);

				if ($rel_field_name === false) {
					$this->relations->setFieldIdRelation($this->source_id, $type_id, $field_name, $field_id);
					$rel_field_name = $field_name;
				} else {
					$field->setAttribute('name', $rel_field_name);
				}

				if($field->getElementsByTagName('restriction')->length) {
					$field_restriction = $field->getElementsByTagName('restriction')->item(0);
					$restriction_id = $field_restriction->getAttribute('id');

					$this->restrictions[] = $restriction_id;
					$this->restricted_fields[] = array(
						'restriction-id' => $restriction_id,
						'field-name' => $rel_field_name,
						'type-id' => $rel_type_id
					);
					$field_restriction->removeAttribute('field-type-id');
				}

				$guide_id = $field->hasAttribute('guide-id') ? $field->getAttribute('guide-id') : false;

				if ($guide_id && (!$this->ignoreRelations || in_array('guides', $this->saveRelations))) {
					if ($this->exportType($guide_id)){
						if ($this->limit && $this->position >= $this->limit) {
							$this->break = true;
							return true;
						}
					}

					$sel = new selector('objects');
					$sel->types('object-type')->id($guide_id);
					$sel->option('return')->value('id');

					foreach ($sel->result as $res) {
						if ($this->exportObject($res['id'])) {
							if ($this->limit && $this->position >= $this->limit) {
								$this->break = true;
								return true;
							}
						}
					}

					$new_guide_id = $this->relations->getOldTypeIdRelation($this->source_id, $guide_id);
					$field->setAttribute('guide-id', $new_guide_id);

					$r = $this->doc->createElement('relation');
					$r->setAttribute('type-id', $rel_type_id);
					$r->setAttribute('field-name', $rel_field_name);
					$g = $this->doc->createElement('guide');
					$g->setAttribute('id', $new_guide_id);
					$r->appendChild($g);
					$relationsToExport[] = $r;
				}

				if ($field->getElementsByTagName('type')->length){
					$field_type = $field->getElementsByTagName('type')->item(0);
					$field_type->removeAttribute('id');
				}

				$typeField = $fieldsCollection->getField($field_id);
				if ($typeField->getIsSystem()) {
					$field->setAttribute('system', 'system');
				}
				//$field->removeAttribute('id');
				$field->removeAttribute('field-type-id');

			}

			foreach ($relationsToExport as $r) {
				$this->relations_container->appendChild($r);
			}

			$this->types_container->appendChild($c);
			$this->exported_types[$type_id] = $rel_type_id;
			$this->position++;
			return true;
		}

		protected function exportRestriction($restriction_id) {

			if (isset($this->exported_restrictions[$restriction_id])) return false;

			$restriction = baseRestriction::get($restriction_id);
			if (!$restriction instanceof baseRestriction) return false;

			$restriction_prefix = $restriction->getClassName();
			$restriction_title = $restriction->getTitle();
			$type_id = $restriction->getFieldTypeId();
			$type = umiFieldTypesCollection::getInstance()->getFieldType($type_id);
			$data_type = $type->getDataType();
			$is_multiple = $type->getIsMultiple();

			$rel_restriction_id = $this->relations->getOldRestrictionIdRelation($this->source_id, $restriction_id);
			if (!$rel_restriction_id) {
				$this->relations->setRestrictionIdRelation($this->source_id, $restriction_id, $restriction_id);
				$rel_restriction_id = $restriction_id;
			}

			$o = $this->doc->createElement('restriction');
			$o->setAttribute('id', $rel_restriction_id);
			$o->setAttribute('prefix', $restriction_prefix);
			$o->setAttribute('title', $restriction_title);
			$o->setAttribute('field-type', $data_type);
			$o->setAttribute('is-multiple', $is_multiple);

			foreach ($this->restricted_fields as $key => $value) {
				if ($value['restriction-id'] == $restriction_id) {
					$f = $this->doc->createElement('field');
					$f->setAttribute('field-name', $value['field-name']);
					$f->setAttribute('type-id', $value['type-id']);
					$o->appendChild($f);
				}
			}

			$this->restrictions_container->appendChild($o);
			$this->exported_restrictions[$restriction_id] = $rel_restriction_id;
			$this->position++;
			return true;
		}

		protected function exportReg($path) {

			if (isset($this->exported_registry_items[$path])) return false;

			if ($this->limit) {
				if ($this->position >= $this->limit) {
					 $this->break = true;
					 return false;
				}
			}

			$regedit = regedit::getInstance();
			$path = trim($path, "/");

			$key = $regedit->getKey($path);
			$val = $regedit->getVal($path);
			if (!$key) return false;

			if(strrpos($path, '/') != false) {
				$parent_path = substr_replace($path, '', strrpos($path, '/'));
				if ($this->exportReg($parent_path)) {
					if ($this->limit && $this->position >= $this->limit) {
						$this->break = true;
						return true;
					}
				}
			}

			$i = $this->doc->createElement('key');
			$this->registry_container->appendChild($i);
			$i->setAttribute('path', $path);
			$i->setAttribute('val', $val);

			$this->exported_registry_items[$path] = $path;
			$this->position++;
			return true;

		}

		protected function exportRestrictions() {
			if (!$this->ignoreRelations || in_array('restrictions', $this->saveRelations)){
			foreach ($this->restrictions as $restriction) {
				$this->exportRestriction($restriction);
			}
		}
		}

		protected function exportTypes() {
			foreach ($this->types as $type) {
				$this->exportType($type);
			}
		}

		protected function exportBranches() {

			foreach ($this->branches as $branch) {
				if ($this->break) break;
				$this->exportBranch($branch);
			}
		}

		protected function exportBranch($element_id) {
			$this->exportElement($element_id);
			$childs = umiHierarchy::getInstance()->getChilds($element_id, true, true, 1);
			foreach ($childs as $child_id => $tmp) {
				if ($this->break) return false;
				$this->exportElement($child_id);
				$this->exportBranch($child_id);
			}
		}

		protected function exportElement($element_id) {

			umiHierarchy::getInstance()->clearCache();

			if (isset($this->exported_elements[$element_id])) return false;

			if ($this->limit) {
				if ($this->position >= $this->limit) {
					 $this->break = true;
					 return false;
				}
			}

			$this->exported_elements[$element_id] = 'found';

			$element = umiHierarchy::getInstance()->getElement($element_id, true, true);
			if (!$element instanceof umiHierarchyElement) return false;

			$type_id = $element->getObjectTypeId();
			if ($this->exportType($type_id)) {
				if ($this->limit && $this->position >= $this->limit) {
					$this->break = true;
					return true;
				}
			}

			$c = $this->doc->createElement('page');
			$this->translateEntity($element, $c);

			$c->removeAttribute('update-time');

			//set lang
			$langId = $element->getLangId();
			if (!$this->ignoreRelations || in_array('langs', $this->saveRelations)) {
				if ($this->exportLang($langId)) {
					if ($this->limit && $this->position >= $this->limit) {
						$this->break = true;
						return true;
					}
				}
				$rel_lang_id = $this->relations->getOldLangIdRelation($this->source_id, $langId);
			} else {
				$rel_lang_id = $this->relations->getOldLangIdRelation($this->source_id, $langId);
				if ($rel_lang_id === false) {
					$this->relations->setLangIdRelation($this->source_id, $langId, $langId);
					$rel_lang_id = $langId;
				}
			}
			$c->setAttribute('lang-id', $rel_lang_id);

			//set domain
			$domainId = $element->getDomainId();

			if (!$this->ignoreRelations || in_array('domains', $this->saveRelations)) {
				$domain = domainsCollection::getInstance()->getDomain($domainId);
				if ($this->exportDomain($domain)){
					if ($this->limit && $this->position >= $this->limit) {
						$this->break = true;
						return true;
					}
				}
				$rel_domain_id = $this->relations->getOldDomainIdRelation($this->source_id, $domainId);
			} else {
				$rel_domain_id = $this->relations->getOldDomainIdRelation($this->source_id, $domainId);
				if ($rel_domain_id === false) {
					$this->relations->setDomainIdRelation($this->source_id, $domainId, $domainId);
					$rel_domain_id = $domainId;
				}
			}
			$c->setAttribute('domain-id', $rel_domain_id);


			// export template
			$tpl_id			= $element->getTplId();

			if (!$this->ignoreRelations || in_array('templates', $this->saveRelations)) {
				$template = templatesCollection::getInstance()->getTemplate($tpl_id);
				if ($this->exportTemplate($template)) {
					if ($this->limit && $this->position >= $this->limit) {
						$this->break = true;
						return true;
					}
				}
				$rel_template_id = $this->relations->getOldTemplateIdRelation($this->source_id, $tpl_id);
			} else {
				$rel_template_id = $this->relations->getOldTemplateIdRelation($this->source_id, $tpl_id);
				if ($rel_template_id === false) {
					$this->relations->setTemplateIdRelation($this->source_id, $tpl_id, $tpl_id);
					$rel_template_id = $tpl_id;
				}
			}

			$tpl_path		= templatesCollection::getInstance()->getTemplate($tpl_id)->getFilename();
			$tpl_node = $this->doc->createElement('template');
			$tpl_node->setAttribute("id", $rel_template_id);
			$tpl_node->appendChild($this->doc->createTextNode($tpl_path));
			$c->appendChild($tpl_node);

			// check relation
			$rel_element_id = $this->relations->getOldIdRelation($this->source_id, $element_id);
			if ($rel_element_id === false) {
				$this->relations->setIdRelation($this->source_id, $element_id, $element_id);
				$rel_element_id = $element_id;
			} else {
				$c->setAttribute('id', $rel_element_id);
			}

			// check parent relation
			$parent_id = $element->getParentId();
			if ($parent_id) {
				$rel_parent_id = $this->relations->getOldIdRelation($this->source_id, $parent_id);
				if ($rel_parent_id === false) {
					$this->relations->setIdRelation($this->source_id, $parent_id, $parent_id);
					$rel_parent_id = $parent_id;
				}
					$c->setAttribute('parentId', $rel_parent_id);
			}

			$parser = new DOMXPath($this->doc);

			if($parser->evaluate("basetype", $c)->length) {
				$base = $parser->evaluate("basetype", $c)->item(0);
				$base->removeAttribute('id');
			}

			// set type-id by releation
			$rel_type_id = $this->relations->getOldTypeIdRelation($this->source_id, $type_id);
			$c->setAttribute('type-id', $rel_type_id);

			// set object-id by releation
			$object_id = $c->getAttribute('object-id');

			if (!$this->ignoreRelations || in_array('objects', $this->saveRelations)) {

				if ($this->exportObject($object_id)) {
					if ($this->limit && $this->position >= $this->limit) {
						$this->break = true;
						return true;
					}
				}
				$rel_object_id = $this->relations->getOldObjectIdRelation($this->source_id, $object_id);

			} else {
				$rel_object_id = $this->relations->getOldObjectIdRelation($this->source_id, $object_id);
				if ($rel_object_id === false) {
					$this->relations->setObjectIdRelation($this->source_id, $object_id, $object_id);
					$rel_object_id = $object_id;
				}
			}

			$c->setAttribute('object-id', $rel_object_id);

			// set fields id by relations
			if($parser->evaluate("properties/group", $c)->length) {

				foreach($parser->evaluate("properties/group", $c) as $group)
					if($group->hasAttribute('id')) $group->removeAttribute('id');
			}
			$nl = $parser->evaluate("properties/group/property", $c);

			$relationsToExport = array();
			$optionsToExport = array();
			foreach ($nl as $field) {
				$field_id = intval($field->getAttribute('id'));
				$rel_field_name = $this->relations->getOldFieldName($this->source_id, $type_id, $field_id);

				if ($rel_field_name) {
					$field->setAttribute('name', $rel_field_name);
				}

				$field_type = $field->getAttribute('type');

				if (!$this->ignoreRelations || in_array('fields_relations', $this->saveRelations)) {

					if ($field_type == 'relation') {
						$r = $this->doc->createElement('relation');
						$r->setAttribute('page-id', $rel_element_id );
						$r->setAttribute('field-name', $rel_field_name);
						if (!$this->exportRelation($r, $field)) return true;
						$relationsToExport[] = $r;
					}
					if ($field_type == 'symlink') {
						$r = $this->doc->createElement('relation');
						$r->setAttribute('page-id', $rel_element_id);
						$r->setAttribute('field-name', $rel_field_name);
						if (!$this->exportRelation($r, $field)) return true;
						$relationsToExport[] = $r;
					}
					if($field_type == 'optioned') {
						$e  = $this->doc->createElement('entity');
						$e->setAttribute('page-id', $rel_element_id);
						$e->setAttribute('field-name', $rel_field_name);
						if (!$this->exportOption($field, $e)) return true;
						$optionsToExport[] = $e;
					}
				}

				if (!$this->ignoreRelations || in_array('files', $this->saveRelations)) {

				if($field_type == 'file' || $field_type == 'swf_file' || $field_type == 'img_file') {
					$file_path = $field->getElementsByTagName('value')->item(0)->nodeValue;
					if (file_exists(CURRENT_WORKING_DIR . $file_path)) {
						$file = new umiFile(CURRENT_WORKING_DIR . $file_path);
						$this->exportFile($file);
					} elseif (file_exists('./' . $file_path)) {
						$file = new umiFile('./' . $file_path);
						$this->exportFile($file);
					}
				}

			}

				//$field->removeAttribute('id');
			}

			$permissionsToExport = array();

			if (!$this->ignoreRelations || in_array('permissions', $this->saveRelations)) {
				$permissions = permissionsCollection::getInstance()->getRecordedPermissions($element_id);
				if(is_array($permissions)) {
					$p = $this->doc->createElement('permission');
					$p->setAttribute('page-id', $rel_element_id);
					foreach ($permissions as $key => $value) {
						$o = $this->doc->createElement('owner');
						if ($this->exportObject($key)){
							if ($this->limit && $this->position >= $this->limit) {
								$this->break = true;
								return true;
							}
						}
						$rel_key = $this->relations->getOldObjectIdRelation($this->source_id, $key);
						$o->setAttribute('id', $rel_key);
						$o->setAttribute('level', $value);
						$p->appendChild($o);
					}
					$permissionsToExport[] = $p;
				}
			}

			foreach ($relationsToExport as $r) {
				$this->relations_container->appendChild($r);
			}
			foreach ($optionsToExport as $e) {
				$this->options_container->appendChild($e);
			}
			foreach ($permissionsToExport as $p) {
				$this->permissions_container->appendChild($p);
			}

			if (!$this->ignoreRelations || in_array('hierarchy', $this->saveRelations)) {

				$ord = $element->getOrd();
				$h = $this->doc->createElement('relation');
				$h->setAttribute('id', $rel_element_id);
				$h->setAttribute('ord', $ord);
				if($parent_id) {
					$h->setAttribute('parent-id', $rel_parent_id);
				} else {
					$h->setAttribute('parent-id', 0);
				}
				$this->hierarchy_container->appendChild($h);
			}

			$this->pages_container->appendChild($c);
			$this->exported_elements[$element_id] = $rel_element_id;
			$this->position++;

			return true;

		}

		protected function exportRelation($r, $field) {

			$pages = $field->getElementsByTagName('page');
			foreach ($pages as $page) {
				if ($this->exportElement($page->getAttribute('id'))){
					if ($this->limit && $this->position >= $this->limit) {
						$this->break = true;
						return false;
					}
				}

				$page_id = $this->relations->getOldIdRelation($this->source_id, $page->getAttribute('id'));
				$g = $this->doc->createElement('page');
				$g->setAttribute('id', $page_id);
				$page->setAttribute('id', $page_id);
				if ($this->exportType($page->getAttribute('type-id'))){
					if ($this->limit && $this->position >= $this->limit) {
						$this->break = true;
						return false;
					}
				}
				$type_id = $this->relations->getOldTypeIdRelation($this->source_id, $page->getAttribute('type-id'));
				$page->setAttribute('type-id', $type_id);

				$parent_id = $page->getAttribute('parentId');
				if ($this->exportElement($parent_id)) {
					if ($this->limit && $this->position >= $this->limit) {
						$this->break = true;
						return false;
					}
				}
				$rel_parent_id = $this->relations->getOldIdRelation($this->source_id, $parent_id);
				$page->setAttribute('parentId', $rel_parent_id);

				$object_id = $page->getAttribute('object-id');
				if ($this->exportObject($object_id)){
					if ($this->limit && $this->position >= $this->limit) {
						$this->break = true;
						return false;
					}
				}
				$rel_object_id = $this->relations->getOldObjectIdRelation($this->source_id, $object_id);
				$page->setAttribute('object-id', $rel_object_id);

				$page->removeAttribute('xlink:href');
				$page->removeAttribute('update-time');
				if($page->getElementsByTagName('basetype')->length){
					$base = $page->getElementsByTagName('basetype')->item(0);
					$base->removeAttribute('id');
				}

				$r->appendChild($g);
			}

			$items = $field->getElementsByTagName('item');
			foreach ($items as $item) {
				$item_id = $item->getAttribute('id');
				if ($this->exportObject($item_id)) {
					if ($this->limit && $this->position >= $this->limit) {
						$this->break = true;
						return false;
					}
				}
				$rel_item_id = $this->relations->getOldObjectIdRelation($this->source_id, $item_id);
				$item->setAttribute('id', $rel_item_id);

				$item_type = $item->getAttribute('type-id');
				if ($this->exportType($item_type)) {
					if ($this->limit && $this->position >= $this->limit) {
						$this->break = true;
						return false;
					}
				}
				$rel_item_type = $this->relations->getOldTypeIdRelation($this->source_id, $item_type);
				$item->setAttribute('type-id', $rel_item_type);
				if ($item->hasAttribute('ownerId')) {
					$item_owner_id = $item->getAttribute('ownerId');
					if ($this->exportObject($item_owner_id)) {
						if ($this->limit && $this->position >= $this->limit) {
							$this->break = true;
							return false;
						}
					}
					$rel_item_owner_id = $this->relations->getOldObjectIdRelation($this->source_id, $item_owner_id);
					$item->setAttribute('ownerId', $rel_item_owner_id);
				}

				$item->removeAttribute('xlink:href');
				$g = $this->doc->createElement('object');
				$g->setAttribute('id', $rel_item_id);
				$r->appendChild($g);
			}
			return true;
		}

		protected function exportObject($object_id) {

			if (isset($this->exported_objects[$object_id])) return false;

			if ($this->limit) {
				if ($this->position >= $this->limit) {
					 $this->break = true;
					 return false;
				}
			}

			$this->exported_objects[$object_id] = 'found';

			$object = umiObjectsCollection::getInstance()->getObject($object_id);
			if (!$object instanceof umiObject) return false;

			$type_id = $object->getTypeId();
			if ($this->exportType($type_id)) {
				if ($this->limit && $this->position >= $this->limit) {
					$this->break = true;
					return true;
				}
			}

			$c = $this->doc->createElement('object');
			$this->translateEntity($object, $c);

			// check object relation
			$rel_object_id = $this->relations->getOldObjectIdRelation($this->source_id, $object_id);
			if ($rel_object_id === false) {
				$this->relations->setObjectIdRelation($this->source_id, $object_id, $object_id);
				$rel_object_id = $object_id;
			} else {
				$c->setAttribute('id', $rel_object_id);
			}

			$parser = new DOMXPath($this->doc);

			// set type-id by releation
			$rel_type_id = $this->relations->getOldTypeIdRelation($this->source_id, $type_id);
			$c->setAttribute('type-id', $rel_type_id);

			// set fields id by relations
			if($parser->evaluate("properties/group", $c)->length) {

				foreach($parser->evaluate("properties/group", $c) as $group)
					if($group->hasAttribute('id')) $group->removeAttribute('id');
			}

			$relationsToExport = array();
			$optionsToExport = array();

			$nl = $parser->evaluate("properties/group/property", $c);
			foreach ($nl as $field) {
				$field_id = intval($field->getAttribute('id'));
				$rel_field_name = $this->relations->getOldFieldName($this->source_id, $type_id, $field_id);

				if ($rel_field_name) {
					$field->setAttribute('name', $rel_field_name);
				}

				if(!$this->ignoreRelations || in_array('fields_relations', $this->saveRelations)) {

					if ($field->getAttribute('type') == 'relation') {
						$r = $this->doc->createElement('relation');
						$r->setAttribute('object-id', $rel_object_id);
						$r->setAttribute('field-name', $rel_field_name);
						if (!$this->exportRelation($r, $field)) return true;
						$relationsToExport[] = $r;

					}
					if ($field->getAttribute('type') == 'symlink') {
						$r = $this->doc->createElement('relation');
						$r->setAttribute('object-id', $rel_object_id);
						$r->setAttribute('field-name', $rel_field_name);
						if (!$this->exportRelation($r, $field)) return true;
						$relationsToExport[] = $r;
					}

					if($field->getAttribute('type') == 'optioned') {
						$e = $this->doc->createElement('entity');
						$e->setAttribute('object-id', $rel_object_id);
						$e->setAttribute('field-name', $rel_field_name);
						if (!$this->exportOption($field, $e)) return true;
						$optionsToExport[] = $e;
					}
				}

				//$field->removeAttribute('id');
			}

			$permissionsToExport = array();
			if(!$this->ignoreRelations || in_array('permissions', $this->saveRelations)) {

				$p = $this->doc->createElement('permission');

				$sql = "SELECT `module`, `method`, `allow` FROM cms_permissions WHERE owner_id = '{$object_id}'";
				$result = l_mysql_query($sql);
				while(list($module, $method, $allow) = mysql_fetch_row($result)) {
					$m = $this->doc->createElement('module');
					$m->setAttribute('name', $module);
					$m->setAttribute('method', $method);
					$m->setAttribute('allow', $allow);
					$p->appendChild($m);
				}

				$p->setAttribute('object-id', $rel_object_id);

				if ($c->hasAttribute('ownerId')) {

					$owner_id = $object->getOwnerId();

					if ($this->exportObject($owner_id)) {
						if ($this->limit && $this->position >= $this->limit) {
							$this->break = true;
							return true;
						}
					}

					$rel_owner_id = $this->relations->getOldObjectIdRelation($this->source_id, $owner_id);
					$c->setAttribute('ownerId', $rel_owner_id);
					$o = $this->doc->createElement('owner');
					$o->setAttribute('id', $rel_owner_id);
					$p->appendChild($o);
				}

				$permissionsToExport[] = $p;
			}

			foreach ($relationsToExport as $r) {
				$this->relations_container->appendChild($r);
			}
			foreach ($optionsToExport as $e) {
				$this->options_container->appendChild($e);
			}
			foreach ($permissionsToExport as $p) {
				$this->permissions_container->appendChild($p);
			}

			$this->objects_container->appendChild($c);
			$this->exported_objects[$object_id] = $object_id;
			$this->position++;
			return true;
		}

		protected function exportOption($field, $e) {
			$options = $field->getElementsByTagName('option');
			foreach ($options as $option) {
				$o = $this->doc->createElement('option');
				if($option->hasAttributes()) {
					$attributes = $option->attributes;
					if(!is_null($attributes)) {
						foreach ($attributes as $index => $attribute) {
						    $o->setAttribute($attribute->name, $attribute->value);
						}
					}
				}
				if($option->getElementsByTagName('object')->length) {
					$object = $option->getElementsByTagName('object')->item(0);
					if ($this->exportObject($object->getAttribute('id'))) {
						if ($this->limit && $this->position >= $this->limit) {
							$this->break = true;
							return false;
						}
					}
					$id = $this->relations->getOldObjectIdRelation($this->source_id, $object->getAttribute('id'));
					$o->setAttribute('object-id' , $id);
					$object->setAttribute('id', $id);
					if ($this->exportType($object->getAttribute('type-id'))) {
						if ($this->limit && $this->position >= $this->limit) {
							$this->break = true;
							return false;
						}
					}
					$type_id = $this->relations->getOldTypeIdRelation($this->source_id, $object->getAttribute('type-id'));
					$object->setAttribute('type-id', $type_id);
					if ($object->hasAttribute('ownerId')) {
						if ($owner_id = $object->getAttribute('ownerId')){
							if ($this->limit && $this->position >= $this->limit) {
								$this->break = true;
								return false;
							}
						}
						$this->exportObject($owner_id);
						$rel_owner_id = $this->relations->getOldObjectIdRelation($this->source_id, $owner_id);
						$object->setAttribute('ownerId', $rel_owner_id);
						$object->removeAttribute('xlink:href');
					}

				}
				if($option->getElementsByTagName('page')->length) {
					$page = $option->getElementsByTagName('page')->item(0);
					if ($this->exportPage($page->getAttribute('id'))) {
						if ($this->limit && $this->position >= $this->limit) {
							$this->break = true;
							return false;
						}
					}
					$id = $this->relations->getOldIdRelation($this->source_id, $page->getAttribute('id'));
					$o->setAttribute('page-id' , $id);
					$page->setAttribute('id', $id);
					if ($this->exportType($page->getAttribute('type-id'))) {
						if ($this->limit && $this->position >= $this->limit) {
							$this->break = true;
							return false;
						}
					}
					$type_id = $this->relations->getOldTypeIdRelation($this->source_id, $page->getAttribute('type-id'));
					$page->setAttribute('type-id', $type_id);
					$page->removeAttribute('xlink:href');
					$page->removeAttribute('update-time');
				}
				$e->appendChild($o);
			}
			return true;
		}

		protected function exportElements() {
			foreach ($this->elements as $element_id) {
				if ($this->break) return;
				$this->exportElement($element_id);
			}

		}

		protected function exportObjects() {
			foreach ($this->objects as $object_id) {
				if ($this->break) return;
				$this->exportObject($object_id);
			}
		}

		protected function exportRegs() {
			foreach ($this->registry as $reg) {
				if ($this->break) return;
				$this->exportReg($reg);
			}
		}

		protected function exportDataTypes() {
			foreach ($this->data_types as $data_type) {
				if ($this->break) return;
				$this->exportDataType($data_type);
			}
		}

	}



	interface iUmiXmlExporter {
		public function __construct();

		public function setElements($elements);
		public function setObjects($objects);

		public function run();

		public function getResultFile();
		public function saveResultFile($filePath);
	};


/**
	* Утилитарный класс, используется для экспорта данных из разделов сайта в формате XML.
	* Работает преимущественно с объектами umiHierarchyElement, но может экспортировать и umiObject.
	* Если в экспортированными данными связаны другие объекты сайта, они тоже попадут в результирующий XML.
*/
	class umiXmlExporter implements iUmiXmlExporter {
		private $objects, $elements, $dump, $source_id;

		public function __construct() {
			$this->source_id =  umiImportRelations::getInstance()->addNewSource(strtoupper(md5($this->getSiteName())));
		}

		/**
			* Установить список элементов (класс umiHierarchyElement), которые необходимо экспортировать
			* @param Array $elements_arr массив, состоящий из id страниц, которые будут экспортированы
			* @return Boolean true, если не возникло ошибок
		*/
		public function setElements($elements_arr) {
			if(is_array($elements_arr)) {
				foreach ($elements_arr as $el) $this->elements[] = ($el instanceof umiHierarchyElement) ? $el->getId() : $el;
				$this->fillObjects($this->elements);
				return true;
			} else {
				trigger_error("First argument must be an array.", E_USER_WARNING);
				return false;
			}
		}

		/**
			* Установить список объектов, которые необходимо экспортировать
			* @param Array $objects_arr массив, состоящий из id объектов (класс umiObject), которые необходимо экспортировать
			* @return Boolean true, если не возникло ошибок
		*/
		public function setObjects($objects_arr) {
			if(is_array($objects_arr)) {
				foreach ($objects_arr as $obj) $this->objects[] = ($obj instanceof umiObject) ? $obj->getId() : $obj;
				return true;
			} else {
				trigger_error("First argument must be an array.", E_USER_WARNING);
				return false;
			}
		}

		/**
			* Выполнить экспорт указанных в методе setElements()/setObjects() данных.
			* После выполнения, можно получить результат экспорта методами getResultFile()/saveResultFile()
		*/
		public function run() {
			if (is_array($this->elements)) {
				$elements = $this->parseElements();
			} else {
				$elements = "";
			}
			$objects = $this->parseObjects();

			$domain		= $this->getDomainPath() . "/";
			$site_name	= $this->getSiteName();
			$source_id = strtoupper(md5($site_name));
			$generatetime	= new umiDate(time());
			$generatetime_timestamp	= $generatetime->getFormattedDate("U");
			$generatetime_rfc		= $generatetime->getFormattedDate("r");
			$generatetime_utc		= $generatetime->getFormattedDate(DATE_ATOM);




			$dump = '<' . '?xml version="1.0" encoding="utf-8"?' . '>';
			$dump .= <<<END

<umicmsDump>
	<siteName><![CDATA[{$site_name}]]></siteName>
	<domain>{$domain}</domain>
	<sourceId><![CDATA[{$source_id}]]></sourceId>

	<generateTime>
			<timestamp><![CDATA[{$generatetime_timestamp}]]></timestamp>
			<RFC><![CDATA[{$generatetime_rfc}]]></RFC>
			<UTC><![CDATA[{$generatetime_utc}]]></UTC>
	</generateTime>

{$elements}

{$objects}

</umicmsDump>
END;
//			$this->dump = iconv("CP1251", "UTF-8//IGNORE", $dump);
			$this->dump = $dump;
		}

		/**
			* Получить в текстовом виде xml - результат экспорта данных
			* @return String Код xml - результат экспорта
		*/
		public function getResultFile() {
			return $this->dump;
		}

		/**
			* Сохранить полученый в результате экспорта XML в файл
			* @param String $filepath путь до файла, в который нужно сохранить XML
		*/
		public function saveResultFile($filepath) {
			file_put_contents($filepath, $this->dump);
			chmod($filepath, 0777);
		}



		protected function parseObjects() {
			$objects = "";
			static $inc = 0;
			if(is_null($this->objects)) {
				return $objects;
			}
			foreach ($this->objects as $i => $object_id){
				$objects .= $this->parseObject($object_id);
				umiObjectsCollection::getInstance()->unloadObject($object_id);
			}
			return $objects;
		}

		protected function parseObject($object_id) {
			if(!($object = umiObjectsCollection::getInstance()->getObject($object_id))) {
				trigger_error("Can't load object #{$object_id}", E_USER_WARNING);
				return false;
			}

			$object_name		= $object->getName();
			$object_type_id		= $object->getTypeId();
			$object_is_locked	= (int) $object->getIsLocked();

			$properties_blocks = $this->parsePropertyBlocks($object);
			$stores_block = $this->parseStoresBlock($object);
			$object_str = <<<END
	<object id="{$object_id}" typeId="{$object_type_id}" isLocked="{$object_is_locked}">
		<name><![CDATA[{$object_name}]]></name>

{$properties_blocks}
{$stores_block}

	</object>


END;
			unset($properties_blocks);
			unset($object);
			return $object_str;
		}


		protected function parsePropertyBlocks(umiObject $object) {
			$object_type_id = $object->getTypeId();

			if(!$object_type_id) return false;

			$object_type = umiObjectTypesCollection::getInstance()->getType($object_type_id);

			$groups = $object_type->getFieldsGroupsList();
			$groups_block = "";

			foreach($groups as $group) {
				$group_name		= $group->getName();
				$group_title		= $group->getTitle();
				$group_is_locked	= (int) $group->getIsLocked();
				$group_is_public	= (int) $group->getIsVisible();
				
				if (in_array($group_name, array("locks", "rate_voters"))) {
					continue;
				}

				$properties_block = $this->parseProperty($object, $group);

				$groups_block .= <<<END
		<propertiesBlock isLocked="{$group_is_locked}" isPublic="{$group_is_public}">
			<name><![CDATA[{$group_name}]]></name>
			<title><![CDATA[{$group_title}]]></title>

{$properties_block}
		</propertiesBlock>


END;
			unset($properties_block);
			}
			unset($groups);

			return $groups_block;
		}


		protected function parseStoresBlock(umiObject $object) {
			$store_amounts = $object->getValue("store_amounts");
			$objs = umiObjectsCollection::getInstance();
			if(is_array($store_amounts)) {
				$stores = "";
				foreach($store_amounts as $store_amount_id) {
					$store_amount = $objs->getObject($store_amount_id);
					if (!$store_amount instanceof umiObject) continue;


					$store_id = $store_amount->getValue("store_id");
					$store = $objs->getObject($store_id);

					if (!$store instanceof umiObject) continue;

					$store_name = $store->getName();
					$amount = $store_amount->getValue("amount");

					$stores .= <<<END

						<store id="{$store_name}">
							<amount>{$amount}</amount>
						</store>

END;
				}

				return <<<END
					<storesBlock>
						{$stores}
					</storesBlock>
END;
			}
			return "";
		}


		protected function parseProperty(umiObject $object, umiFieldsGroup $group) {
			$properties = "";

			$fields = $group->getFields();

			foreach($fields as $field) {
				$field_name		= $field->getName();
				$field_title		= $field->getTitle();
				$field_tip		= $field->getTip();

				$field_is_locked	= (int) $field->getIsLocked();
				$field_is_public	= (int) $field->getIsVisible();
				$field_is_indexed	= (int) $field->getIsInSearch();
				$field_is_filterable	= (int) $field->getIsInFilter();

				$field_guide_id		= $field->getGuideId();

				$field_type		= $field->getFieldType();
				$field_is_multiple	= (int) $field_type->getIsMultiple();
				$field_data_type	= (string) $field_type->getDataType();


				$values = $this->parseValues($object, $field);

				$properties .= <<<END

			<property isLocked="{$field_is_locked}" isPublic="{$field_is_public}">
				<name><![CDATA[{$field_name}]]></name>
				<title><![CDATA[{$field_title}]]></title>

				<fieldType><![CDATA[{$field_data_type}]]></fieldType>
				<isMultiple>{$field_is_multiple}</isMultiple>
				<isIndexed>{$field_is_indexed}</isIndexed>
				<isFilterable>{$field_is_filterable}</isFilterable>

				<guideId>{$field_guide_id}</guideId>

				<tip><![CDATA[{$field_tip}]]></tip>

				<values>
{$values}
				</values>
			</property>
END;
				unset($values);
			}
			unset($fields);
			return $properties;
		}


		protected function parseValues(umiObject $object, umiField $field) {
			$field_type		= $field->getFieldType();
			$field_is_multiple	= (int) $field_type->getIsMultiple();
			$field_data_type	= (string) $field_type->getDataType();

			$values = $object->getValue($field->getName());
			$values = (is_array($values)) ? $values : Array($values);

			switch($field_data_type) {
				case "img_file": {
					$values_arr = Array();

					foreach($values as $cval) {
						if(!$cval) continue;

						$values_arr[] = Array	(
										"value"	=> $cval->getFilePath()
									);
					}

					break;
				}

				case "relation": {
					$values_arr = Array();

					foreach($values as $cval) {
						$cval = umiObjectsCollection::getInstance()->getObject($cval);
						if(!$cval) continue;

						$obj_id = $cval->getId();

						if(!in_array($obj_id, $this->objects)) {
							$this->objects[] = $obj_id;
						}


						$values_arr[] = Array	(
										"value"	=> $cval->getName(),
										"id"	=> $cval->getId()
									);
					}
					break;
				}

				case "symlink": {
					$values_arr = Array();

					foreach($values as $cval) {
						if(!$cval) continue;

						$values_arr[] = Array	(
										"value"	=> $cval->getName(),
										"id"	=> $cval->getId(),
										"link"	=> $this->getDomainPath() . umiHierarchy::getInstance()->getPathById($cval->getId())
									);
					}
					break;
				}

				case "date": {
					$values_arr = Array();

					foreach($values as $cval) {
						if(!$cval) continue;

						$values_arr[] = Array	(
										"timestamp"	=> $cval->getFormattedDate("U"),
										"RFC"		=> $cval->getFormattedDate("r"),
										"UTC"		=> $cval->getFormattedDate(DATE_ATOM)
									);
					}
					break;
				}


				default: {
					$values_arr = Array();
					foreach($values as $cval) {
						$values_arr[] = Array	(
										"value"	=> $cval,
										"id"	=> NULL
									);
					}
					break;
				}
			}
			$values = "";
			foreach($values_arr as $val) {

				if(array_key_exists('value',$val)) $value = $val['value'];

				if(array_key_exists('id',$val)) {
					if(array_key_exists('timestamp',$val)) {
						$values .= <<<END
							<value>
								<timestamp><![CDATA[{$val['timestamp']}]]></timestamp>
								<RFC><![CDATA[{$val['RFC']}]]></RFC>
								<UTC><![CDATA[{$val['UTC']}]]></UTC>
							</value>

END;
					} else {
						$rel = !is_null($val['id']) ? ' id="' . $val['id'] . '"' : '';
						$values .= <<<END
							<value{$rel}><![CDATA[{$value}]]></value>

END;
					}

				} else {
					if(array_key_exists('timestamp',$val)) {
						$values .= <<<END
							<value>
								<timestamp><![CDATA[{$val['timestamp']}]]></timestamp>
								<RFC><![CDATA[{$val['RFC']}]]></RFC>
								<UTC><![CDATA[{$val['UTC']}]]></UTC>
							</value>

END;
					} else {
						$values .= <<<END
							<value><![CDATA[{$value}]]></value>

END;
					}
					
					if(!array_key_exists('value', $val)) continue;
					if(array_key_exists('timestamp',$val))	{
						$id = $val['id'];
						$link = array_key_exists("link", $val) ? " link=\"{$val['link']}\"" : "";

						$values .= <<<END
							<value id="{$id}"{$link}><![CDATA[{$value}]]></value>
END;
					}
				}
			}
			unset($values_arr);
			return $values;
		}


		protected function getDomainPath() {
			return "http://" . $_SERVER['HTTP_HOST'];
		}


		protected function getSiteName() {
			/**
			* @var cmsController
			*/
			$oController = cmsController::getInstance();
			$lang_id     = $oController->getCurrentLang()->getId();
			$domain_id   = $oController->getCurrentDomain()->getId();
			$regedit     = regedit::getInstance();
			$prefix      = $regedit->getVal("//settings/title_prefix/{$lang_id}/{$domain_id}");
			$siteName    = $regedit->getVal("//settings/site_name");
			if(strlen($prefix))
				return $prefix . $siteName;
			else
				return $siteName;
		}


		protected function fillObjects($elements_arr) {
			foreach($elements_arr as $element_id) {
				$element = umiHierarchy::getInstance()->getElement($element_id);
				if (!$element) continue;
				$object_id = $element->getObject()->getId();

				if(!is_array($this->objects) || !in_array($object_id, $this->objects)) {
					$this->objects[] = $object_id;
				}
			}
		}

		protected function parseElements() {
			$elements_arr = $this->elements;

			$elements = "";

			$is_absolute_path = umiHierarchy::getInstance()->forceAbsolutePath(true);

			foreach($elements_arr as $element_id) {
				$element = umiHierarchy::getInstance()->getElement($element_id);
				if(!$element) continue;

				$name			= $element->getName();
				$alt_name		= $element->getAltName();
				$link			= umiHierarchy::getInstance()->getPathById($element_id);
				$parent_id		= $element->getParentId();
				
				$hierarchy_type_id	= $element->getTypeId();

				$hierarchy_type		= umiHierarchyTypesCollection::getInstance()->getType($hierarchy_type_id);
				$behaviour_title	= $hierarchy_type->getTitle();
				$behaviour_module	= $hierarchy_type->getName();
				$behaviour_method	= $hierarchy_type->getExt();

				$tpl_id			= $element->getTplId();
				$tpl_path		= templatesCollection::getInstance()->getTemplate($tpl_id)->getFilename();

				$lang_id		= $element->getLangId();
				$lang			= langsCollection::getInstance()->getLang($lang_id);
				$lang_title		= $lang->getTitle();
				$lang_prefix		= $lang->getPrefix();

				$domain_id		= $element->getDomainId();
				$domain			= domainsCollection::getInstance()->getDomain($domain_id);
				$domain_host		= $domain->getHost();

				$object_id		= $element->getObject()->getId();

				$is_visible		= (int) $element->getIsVisible();
				$is_active		= (int) $element->getIsActive();

				$updatetime		= new umiDate($element->getUpdateTime());
				$updatetime_timestamp	= $updatetime->getFormattedDate("U");
				$updatetime_rfc		= $updatetime->getFormattedDate("r");
				$updatetime_utc		= $updatetime->getFormattedDate(DATE_ATOM);

				// set relations
				$parent_rel_id = umiImportRelations::getInstance()->getNewIdRelation($this->source_id, $parent_id);
				$element_rel_id = umiImportRelations::getInstance()->getNewIdRelation($this->source_id, $element_id);
				if ($element_id && !$element_rel_id) {
					umiImportRelations::getInstance()->setIdRelation($this->source_id, $element_id, $element_id);
					$element_rel_id = $element_id;
				}
				if ($parent_id && !$parent_rel_id) {
					umiImportRelations::getInstance()->setIdRelation($this->source_id, $parent_id, $parent_id);
					$parent_rel_id = $parent_id;
				}


				$elements .= <<<END
	<element id="{$element_rel_id}" parentId="{$parent_rel_id}" objectId="{$object_id}" is_visible="{$is_visible}" is_active="{$is_active}">
		<name><![CDATA[{$name}]]></name>
		<link><![CDATA[{$link}]]></link>
		<altName><![CDATA[{$alt_name}]]></altName>

		<templateId><![CDATA[{$tpl_id}]]></templateId>
		<templatePath><![CDATA[{$tpl_path}]]></templatePath>
		<lang prefix="{$lang_prefix}"><![CDATA[{$lang_title}]]></lang>
		<domain><![CDATA[{$domain_host}]]></domain>

		<behaviour>
			<title><![CDATA[{$behaviour_title}]]></title>
			<module><![CDATA[{$behaviour_module}]]></module>
			<method><![CDATA[{$behaviour_method}]]></method>
		</behaviour>

		<updateTime>
				<timestamp><![CDATA[{$updatetime_timestamp}]]></timestamp>
				<RFC><![CDATA[{$updatetime_rfc}]]></RFC>
				<UTC><![CDATA[{$updatetime_utc}]]></UTC>
		</updateTime>
	</element>


END;
				unset($element);
				umiHierarchy::getInstance()->unloadElement($element_id);
			}

			umiHierarchy::getInstance()->forceAbsolutePath($is_absolute_path);

			unset($elements_arr);
			return $elements;
		}
	};



	interface iUmiXmlImporter {
		public function __construct();

		public function ignoreNewFields($ignoreNewFields = false);
		public function ignoreNewItems($ignoreNewItems = false);

		public function loadXmlString($xmlString);
		public function loadXmlFile($xmlFilePath);

		public function analyzeXml();
		public function importXml();


		public function getImportedElementsCount();
	};



/**
	* Класс, обеспечивающий механизм импорта данных в CMS.
	* Способен принимать данные, сгенерированные классом umiXmlExporter.
	* Не смотря на то, что формат XML-файла предусматривает передачу и страниц, и объектов,
	* этот класс умеет импортировать только страницы (класс umiHierarchyElement).
*/
	class umiXmlImporter implements iUmiXmlImporter {
		protected	$ignore_new_fields = false,
				$ignore_new_items = false,
				$is_xml_analyzed = false;
		protected $xml;

		protected	$xml_elements = Array(),
				$xml_objects = Array(),
				$xml_stores = Array(),
				$xml_types = Array();

		protected	$source_id = 1;

		protected	$importedElements = 0,
					$importedElementsArr = Array(),
					$createdElements = 0,
					$deletedElements = 0,
					$updatedElements = 0,
					$importErrors = 0;

		protected	$importLog = array();

		protected $destination_element_id = 0;

		public function __construct() {
			//umiObjectProperty::$USE_FORCE_OBJECTS_CREATION = true;
		}


		/**
			* Устанавливает элемент, в который будут попадать элементы, у которых в дампе не существует родителя.
			* По умолчанию такие элементы попадают в корень сайта
			* @param Variant Id элемента, либо сам элемент
			* @return Boolean true, если удалось установить значение
		*/
		public function setDestinationElementId($element) {
			if ($element instanceof umiHierarchyElement) {
				$this->destination_element_id = $element->getId();
				return true;
			}
			if (umiHierarchy::getInstance()->getElement($element) instanceof umiHierarchyElement) {
				$this->destination_element_id = $element;
				return true;
			}
			return false;
		}

		/**
			* Игнорировать создание новых полей при импорте. В текущей версии не используется.
			* @param Boolean если true, то новые поля при импорте создаваться не будут
			* @return Boolean предыдущее значение этого флага
		*/
		public function ignoreNewFields($ignore_new_fields = NULL) {
			$old_value = $this->ignore_new_fields;

			if(!is_null($ignore_new_fields)) {
				$this->ignore_new_fields = (bool) $ignore_new_fields;
			}

			return $old_value;
		}

		/**
			* Метод в текущей версии не используется
		*/
		public function ignoreNewItems($ignore_new_items = NULL) {
			$old_value = $this->ignore_new_items;

			if(!is_null($ignore_new_items)) {
				$this->ignore_new_items = (bool) $ignore_new_items;
			}

			return $old_value;
		}


		/**
			* Загрузить XML с данными из строки, переданной в качестве параметра
			* @param String $xml_string XML с данными для импорта
			* @return Boolean true, если при чтении данных не возникло ошибок
		*/
		public function loadXmlString($xml_string) {
			$xml = simplexml_load_string($xml_string);
			return $this->loadXml($xml);
		}

		/**
			* Загрузить XML с данными для импорта из указанного файла
			* @param String $xml_filepath путь до файла с данными
			* @return Boolean true, если при чтении данных не возникло ошибок
		*/
		public function loadXmlFile($xml_filepath) {
			if(!is_file($xml_filepath)) {
				trigger_error("XML file {$xml_filepath} not found", E_USER_WARNING);
				return false;
			}


			if(!is_readable($xml_filepath)) {
				trigger_error("XML file {$xml_filepath} is not readable", E_USER_WARNING);
				return false;
			}


			$xml = simplexml_load_file($xml_filepath);
			return $this->loadXml($xml);
		}


		protected function loadXml($xml) {
			if(is_object($xml)) {
				$this->xml = $xml;
				return true;
			} else {
				trigger_error("Failed to read xml-content", E_USER_WARNING);
				return false;
			}
		}

		/**
			* Проанализировать загруженный XML непосредственно перед импортом данных.
		*/
		public function analyzeXml() {
			$source_id_name = (string) $this->xml->sourceId;
			$this->source_id = umiImportRelations::getInstance()->addNewSource($source_id_name);

			foreach($this->xml->element as $currentNode) {
				$this->analyzeElementNode($currentNode);
			}


			foreach($this->xml->object as $currentNode) {
				$old_object_id = (string) $currentNode->attributes()->id;

				if(array_key_exists($old_object_id, $this->xml_objects)) {
					$this->analyzeObjectNode($currentNode);
				}
			}
		}


		protected function analyzeElementNode(SimpleXMLElement $elementNode) {
			$element_id =		(string) $elementNode->attributes()->id;
			$element_parent_id =	(string) $elementNode->attributes()->parentId;
			$element_object_id =	(string) $elementNode->attributes()->objectId;
			$element_alt_name =	(string) $elementNode->altName;
			$element_is_visible =	is_object($elementNode->attributes()->is_visible) ? (string) $elementNode->attributes()->is_visible : NULL;
			$element_is_active =	is_object($elementNode->attributes()->is_active) ? (string) $elementNode->attributes()->is_active : NULL;
			$element_is_deleted =	is_object($elementNode->attributes()->is_deleted) ? (string) $elementNode->attributes()->is_deleted : NULL;

			if(in_array($element_id, $this->importedElementsArr)) {
				return false;
			}

			$module = $elementNode->behaviour->module;
			$method = $elementNode->behaviour->method;

			$element_hierarchy_type = umiHierarchyTypesCollection::getInstance()->getTypeByName((string) $module, (string) $method);

			if($element_hierarchy_type === false) {
				trigger_error("Unknown element's module/method", E_USER_ERROR);
				return false;
			}

			$element_filepath = (string) $elementNode->templatePath;

			$element_hierarchy_type_id = $element_hierarchy_type->getId();

			$this->xml_elements[$element_id] = Array(
							"old_element_id" => $element_id,
							"old_parent_id" => $element_parent_id,
							"old_element_object_id" => $element_object_id,

							"element_hierarchy_type_id" => $element_hierarchy_type_id,
							"element_filepath" => $element_filepath,

							"old_element_alt_name" => $element_alt_name,

							"element_is_visible" => $element_is_visible,
							"element_is_active" => $element_is_active,
							"element_is_deleted" => $element_is_deleted
							);

			$this->xml_objects[$element_object_id] = Array(
							"old_element_id" => $element_id,
							"element_hierarcy_type_id" => $element_hierarchy_type_id,
							"is_linked" => true
			);

		}


		protected function analyzeObjectNode(SimpleXMLElement $objectNode) {
			$object_id = (string) $objectNode->attributes()->id;
			$object_type_id = (string) $objectNode->attributes()->typeId;
			$object_type_name = (string) $objectNode->attributes()->typeName;

			$object_info = $this->xml_objects[$object_id];

			$object_info['old_object_id'] = $object_id;
			$object_info['old_type_id'] = $object_type_id;
			$object_info['type_name'] = $object_type_name;
			$object_info['old_name'] = (string) $objectNode->name;

			$object_info['props'] = $this->analyzeObjectPropertiesBlockNode($objectNode->propertiesBlock, $object_type_id);

			if ($objectNode->storesBlock->store) {
				$this->analyzeObjectSoresInfo($object_id, $objectNode->storesBlock->store);
			}

			$this->xml_objects[$object_id] = $object_info;
		}



		protected function analyzeObjectPropertiesBlockNode(SimpleXMLElement $object_properties_block_nodes, $object_type_id) {
			if(!array_key_exists($object_type_id, $this->xml_types)) {
				$this->xml_types[$object_type_id] = Array();
				$this->xml_types[$object_type_id]['is_base'] = true;
				$this->xml_types[$object_type_id]['props'] = Array();
			}

			$obj_props = Array();

			foreach($object_properties_block_nodes as $object_properties_block_node) {
				$props_block_title = (string) $object_properties_block_node->title;
				$props_block_name = (string) $object_properties_block_node->name;
				$props_block_is_public = (string) $object_properties_block_node->isPublic;

				foreach($object_properties_block_node->property as $object_property_node) {
					$prop_title = (string) $object_property_node->title;
					$prop_name = (string) $object_property_node->name;
					$prop_tip = (string) $object_property_node->tip;

					$prop_is_multiple = (string) $object_property_node->isMultiple;
					$prop_is_indexed = (string) $object_property_node->isIndexed;
					$prop_is_filterable = (string) $object_property_node->isFilterable;
					$prop_is_public = (string) $object_property_node->isPublic;
					$prop_is_public = (bool)  $object_property_node->isPublic;
					$prop_guide_id = (string) $object_property_node->guideId;

					$prop_field_type = (string) $object_property_node->fieldType;

					$prop_values = $this->extractValues($object_property_node->values);
					$currency_code = (string) $object_property_node->values->attributes()->currency_code;


					if(!$prop_name) {
						$prop_name = translit::convert($prop_title);
					}

					$prop_info = Array();
					$prop_info['title'] = $prop_title;
					$prop_info['name'] = $prop_name;
					$prop_info['tip'] = $prop_tip;
					$prop_info['is_multiple'] = $prop_is_multiple;
					$prop_info['is_filterable'] = $prop_is_filterable;
					$prop_info['guide_id'] = $prop_guide_id;
					$prop_info['field_type'] = $prop_field_type;
					$prop_info['values'] = $prop_values;
					$prop_info['currency_code'] = $currency_code;
					$prop_info['is_public'] = $prop_is_public;

					$prop_info['prop_block_title'] = $props_block_title;
					$prop_info['prop_block_name'] = $props_block_name;
					$prop_info['prop_block_is_public'] = $props_block_is_public;

					$this->xml_types[$object_type_id]['props'][$prop_name] = $prop_info;

					$obj_props[$prop_name] = $prop_info;
				}
			}

			return $obj_props;
		}

		protected function analyzeObjectSoresInfo($iObjectId, SimpleXMLElement $oObjectStoresInfoNodes) {
			foreach ($oObjectStoresInfoNodes as $oStoreInfoXml) {
				$sStoreId = (string) $oStoreInfoXml->attributes()->id;
				$iAmount = (int) $oStoreInfoXml->amount;
				if (strlen($sStoreId)) {
					$sStoreId = $sStoreId;
					if (!isset($this->xml_stores[$iObjectId])) $this->xml_stores[$iObjectId] = array();
					$arrStoreInfo = array();
					$arrStoreInfo['old_store_id'] = $sStoreId;
					$arrStoreInfo['amount'] = $iAmount;
					$this->xml_stores[$iObjectId][] = $arrStoreInfo;
				}
			}
		}

		protected function extractValues($values_node) {
			$res = Array();

			if (!$values_node->value) return array();

			foreach($values_node->value as $value_node) {
				$timestamp = ((string) $value_node->timestamp[0]);

				$val = ((string) $value_node);

				if($timestamp) {
					$val = new umiDate();
					$val->setDateByTimeStamp($timestamp);
				}

				if($val) {
					$res[] = $val;
				}
			}

			return $res;
		}



		protected function detectBetterFieldType($value) {
			//TODO: Определять наибоее подходящий тип данных.
		}


		protected function detectBetterObjectType($hierarchy_type_id, $old_type_id, $new_type_name = "") {
			//TODO: Определять наиболее подходящий тип данных.
			$fields = array_keys($this->xml_types[$old_type_id]['props']);

			$new_type_id = umiImportRelations::getInstance()->getNewTypeIdRelation($this->source_id, $old_type_id);

			if($new_type_id) {
				return $new_type_id;
			}

			$types = umiObjectTypesCollection::getInstance()->getTypesByHierarchyTypeId($hierarchy_type_id);
			$base_type_id = umiObjectTypesCollection::getInstance()->getTypeByHierarchyTypeId($hierarchy_type_id);

			foreach($types as $type_id => $type_name) {
				$diff_count = $this->compareObjectTypeFields($type_id, $fields);

				if($diff_count == 0) {
					$new_type_id = $type_id;
					break;
				}
			}
			if(!$new_type_id) {
				$base_type_name = umiObjectTypesCollection::getInstance()->getType($base_type_id)->getName();
				if (!$new_type_name || !strlen($new_type_name)) $new_type_name = "Подтип \"{$base_type_name}\" #{$old_type_id}";
				$new_type_id = umiObjectTypesCollection::getInstance()->addType($base_type_id, $new_type_name);

				$new_type = umiObjectTypesCollection::getInstance()->getType($new_type_id);
				$new_type->setHierarchyTypeId($hierarchy_type_id);
				$new_type->commit();
			}

			umiImportRelations::getInstance()->setTypeIdRelation($this->source_id, $old_type_id, $new_type_id);

			return $new_type_id;
		}


		protected function compareObjectTypeFields($object_type_id, $fields) {
			$object_type = umiObjectTypesCollection::getInstance()->getType($object_type_id);

			if($object_type === false) {
				trigger_error("Object type #{$object_type_id} not found", E_USER_ERROR);
				return false;
			}


			$diff_count = 0;
			foreach($fields as $field_name) {
				if($object_type->getFieldId($field_name) == false) {
					++$diff_count;
				}
			}

			return $diff_count;
		}



		protected function detectBetterTemplateId($filepath) {
			if($filepath) {
				$domain_id = cmsController::getInstance()->getCurrentDomain()->getId();
				$lang_id = cmsController::getInstance()->getCurrentLang()->getId();

				$templates = templatesCollection::getInstance()->getTemplatesList($domain_id, $lang_id);
				foreach($templates as $ctpl) {
					if($ctpl->getFilename() == $filepath) {
						return $ctpl->getId();
					}
				}
			}
			return templatesCollection::getInstance()->getDefaultTemplate()->getId();
		}


		/**
			* Импортировать данные в систему.
		*/
		public function importXml() {
			foreach($this->xml_elements as $element_info) {
				$hierarchy_type_id = $element_info['element_hierarchy_type_id'];
				$old_object_id = $element_info['old_element_object_id'];
				$old_object_type_id = $this->xml_objects[$old_object_id]['old_type_id'];
				$type_name =  $this->xml_objects[$old_object_id]['type_name'];

				$element_info['old_type_id'] = $old_object_type_id;
				$element_info['new_type_id'] = $new_type_id = $this->detectBetterObjectType($hierarchy_type_id, $old_object_type_id, $type_name);
				$element_info['new_tpl_id'] = $new_tpl_id = $this->detectBetterTemplateId($element_info['element_filepath']);

				$element_info['new_lang_id'] = cmsController::getInstance()->getCurrentLang()->getId() ;
				$element_info['new_domain_id'] = cmsController::getInstance()->getCurrentDomain()->getId();

				$element_info['element_name'] = $this->xml_objects[$old_object_id]['old_name'];


				$this->importElement($element_info);
			}
		}


		protected function importElement($element_info) {
			$this->importedElements += 1;

			$old_element_id = $element_info['old_element_id'];
			$old_element_object_id = $element_info['old_element_object_id'];

			$new_element_id = umiImportRelations::getInstance()->getNewIdRelation($this->source_id, $old_element_id);

			$oEventPoint = new umiEventPoint("import_element");
			$oEventPoint->setMode("before");
			$oEventPoint->setParam("new_element_id", $new_element_id);
			$oEventPoint->setParam("old_element_id", $old_element_id);
			$oEventPoint->addRef("element_info", $element_info);
			$oEventPoint->addRef("props", $this->xml_objects[$old_element_object_id]['props']);
			umiEventsController::getInstance()->callEvent($oEventPoint);

			$old_element_parent_id = $element_info['old_parent_id'];

			$this->importedElementsArr[] = $old_element_id;

			$new_name = $element_info['element_name'];
			$old_element_alt_name = $element_info['old_element_alt_name'];

			$old_object_type_id = $element_info['old_type_id'];

			$element_is_active = $element_info['element_is_active'];
			$element_is_visible = $element_info['element_is_visible'];
			$element_is_deleted = $element_info['element_is_deleted'];

			if($old_element_alt_name) {
				$alt_name = $old_element_alt_name;
			} else {
				$alt_name = $new_name;
			}

			$alt_name = translit::convert($alt_name);

			if($element_is_deleted !== NULL) {
				if($element_is_deleted) {
					umiHierarchy::getInstance()->delElement($new_element_id);
					$this->importLog[] = "Element \"" . $new_name . "\" (" . $old_element_id . ") has been deleted";
					$this->deletedElements++;
					return true;
				}
			}
			if($old_element_parent_id === "0") {
				$new_parent_id = $old_element_parent_id;
			} else {
				$new_parent_id = umiImportRelations::getInstance()->getNewIdRelation($this->source_id, $old_element_parent_id);
			}

			if ($new_parent_id === false) {
				$new_parent_id = $this->destination_element_id;
			}

			$b_created = false;
			if ($new_element_id === false && $new_parent_id !== false) {
				$new_domain_id = $element_info['new_domain_id'];
				$new_lang_id = $element_info['new_lang_id'];
				$new_hierarchy_type_id = $element_info['element_hierarchy_type_id'];
				$new_tpl_id = $element_info['new_tpl_id'];
				$new_type_id = $element_info['new_type_id'];

				$new_element_parent_id = umiImportRelations::getInstance()->getNewIdRelation($this->source_id, $old_element_parent_id);
				$new_element_id = umiHierarchy::getInstance()->addElement($new_parent_id, $new_hierarchy_type_id, $new_name, $alt_name, $new_type_id, $new_domain_id, $new_lang_id, $new_tpl_id);
				umiImportRelations::getInstance()->setIdRelation($this->source_id, $old_element_id, $new_element_id);
				if ($new_element_id) $b_created = true;
			}

			permissionsCollection::getInstance()->setDefaultPermissions($new_element_id);

			$new_element = umiHierarchy::getInstance()->getElement($new_element_id, true, true);

			if (!$new_element instanceof umiHierarchyElement) {
				$this->importLog[] = "Can't create element \"{$new_name}\" ({$old_element_id})";
				$this->importErrors++;
			    return false;
			}

			$oEventPoint = new umiEventPoint("import_element");
			$oEventPoint->setMode("process");
			$oEventPoint->setParam("new_element", $new_element);
			$oEventPoint->setParam("old_element_id", $old_element_id);
			$oEventPoint->addRef("element_info", $element_info);
			$oEventPoint->addRef("props", $this->xml_objects[$old_element_object_id]['props']);
			umiEventsController::getInstance()->callEvent($oEventPoint);

			if($element_is_active !== NULL) {
				$new_element->setIsActive($element_is_active);
			}

			if($element_is_visible !== NULL) {
				$new_element->setIsVisible($element_is_visible);
			}

			if($alt_name) {
				$new_element->setAltName($alt_name);
			}

			if ($new_name) {
				$new_element->setName($new_name);
			}

			$missed_props = Array();
			$props = $this->xml_objects[$old_element_object_id]['props'];

			foreach($props as $prop_name => $prop_info) {
				$prop_value = $prop_info['values'];
				$field_type = $prop_info['field_type'];
				if($field_type == "img_file") {
					if(isset($prop_value[0])) {
						$prop_value[0] = new umiImageFile($prop_value[0]);
					}
				}

				$prop_name = translit::convert($prop_name);

				if($new_element->getObject()->getPropByName($prop_name)) {
					if ($field_type == 'price' && strlen($prop_info['currency_code'])) {
						$emarket = cmsController::getInstance()->getModule('emarket');
						if ($emarket) {
							$price = isset($prop_value[0]) ? floatval($prop_value[0]) : 0;

							$currency = $emarket->getCurrency($prop_info['currency_code']);
							if ($currency) {
								$f_price = $emarket->formatCurrencyPrice(array($price), $emarket->getDefaultCurrency(), $currency);
								$prop_value = isset($f_price[0]) ? floatval($f_price[0]) : 0;
							}
						}
					}
					$new_element->setValue($prop_name, $prop_value);
				} else {

					$missed_props[] = $prop_info;
				}
			}
			$this->addMissedProps($new_element, $missed_props, $old_object_type_id);
			if(count($missed_props)) {
				// reloading object propertyes
				/*
				$element_id = $new_element->getId();
				$object_id = $new_element->getObject()->getId();
				umiHierarchy::getInstance()->unloadElement($element_id);
				umiObjectsCollection::getInstance()->unloadObject($object_id);
				$new_element = umiHierarchy::getInstance()->getElement($element_id, true, true);
				*/

				$new_element->getObject()->update();
			}
			foreach($missed_props as $prop_info) {
				$prop_value = $prop_info['values'];

				$field_type = $prop_info['field_type'];
				if($field_type == "img_file") {
					if($prop_value[0]) {
						$prop_value[0] = new umiImageFile($prop_value[0]);
					}
				}


				if(!$prop_info['name']) $prop_info['name'] = translit::convert($prop_info['title']);
				$prop_info['name'] = translit::convert($prop_info['name']);

				if(!$new_element->setValue($prop_info['name'], $prop_value)) {
					//trigger_error("Value for property '{$prop_info['name']}' not set", E_USER_WARNING);
					continue;
				}

			}

			$new_element->commit();
			if ($b_created) {
				$this->importLog[] = "Element \"" . $new_name . "\" (" . $old_element_id . ") has been created";
				$this->createdElements++;
			} else {
				$this->importLog[] = "Element \"" . $new_name . "\" (" . $old_element_id . ") has been updated";
				$this->updatedElements++;
			}


			$bOldCreateFlag = umiObjectProperty::$USE_FORCE_OBJECTS_CREATION;
			umiObjectProperty::$USE_FORCE_OBJECTS_CREATION = false;
			// update store info
			$iStoreTypeId = umiObjectTypesCollection::getInstance()->getBaseType("eshop", "store");
			$iStoreRelType = umiObjectTypesCollection::getInstance()->getBaseType("eshop", "store_relation");
			$oEshopInstance = cmsController::getInstance()->getModule("eshop");
			if ($oEshopInstance && $iStoreTypeId && $iStoreRelType) {
				if (isset($this->xml_stores[$old_element_object_id])) {
					foreach ($this->xml_stores[$old_element_object_id] as $arrStoreInfo) {
						$sOldStoreId = $arrStoreInfo['old_store_id'];
						$iAmount = $arrStoreInfo['amount'];
						$iStoreId = $this->getStoreIdByName($sOldStoreId);

						if ($iStoreId === false) {
							$iStoreId = umiObjectsCollection::getInstance()->addObject($sOldStoreId, $iStoreTypeId);
						}

						$oStore = umiObjectsCollection::getInstance()->getObject($iStoreId);
						if ($oStore instanceof umiObject) {
							$oStore->setName($sOldStoreId);
							$oStore->commit();
							$oEshopInstance->setStoreAmount($new_element->getId(), $iStoreId, $iAmount);
						}
					}
				}
			}
			umiObjectProperty::$USE_FORCE_OBJECTS_CREATION = $bOldCreateFlag;

			$oEventPoint = new umiEventPoint("import_element");
			$oEventPoint->setMode("after");
			$oEventPoint->setParam("new_element_id", $new_element_id);
			$oEventPoint->setParam("old_element_id", $old_element_id);
			$oEventPoint->setParam("element_info", $element_info);
			umiEventsController::getInstance()->callEvent($oEventPoint);

			umiHierarchy::getInstance()->unloadElement($new_element_id);
		}


		protected function getStoreIdByName($sName) {
			$object_type_id = umiObjectTypesCollection::getInstance()->getBaseType("eshop", "store");

			$sel = new umiSelection;
			$sel->setObjectTypeFilter();
			$sel->addObjectType($object_type_id);

			$sel->setPropertyFilter();
			$sel->addNameFilterEquals($sName);

			$result = umiSelectionsParser::runSelection($sel);

			return isset($result[0]) ? (int) $result[0] : false;
		}

		protected function addMissedProps(&$new_element, $missed_props, $old_object_type_id) {
			if (strlen($old_object_type_id)) {
				$object_type_id = umiImportRelations::getInstance()->getNewTypeIdRelation($this->source_id, $old_object_type_id);
			} else {
				$object_type_id = $new_element->getObject()->getTypeId();
			}

			$object_type = umiObjectTypesCollection::getInstance()->getType($object_type_id);


			foreach($missed_props as $missed_prop) {
				$prop_block_title = $missed_prop['prop_block_title'];
				$prop_block_name = $missed_prop['prop_block_name'];
				$prop_block_is_public = $missed_prop['prop_block_is_public'];

				if(!$prop_block_name) {
					if($prop_block_title) {
						$prop_block_name = translit::convert($prop_block_title);
					} else {
						$prop_block_title = "Imported fields group";
						$prop_block_name = "imported";
					}
				}


				if($prop_group_block = $object_type->getFieldsGroupByName($prop_block_name)) {
				} else {
					$prop_group_block_id = $object_type->addFieldsGroup($prop_block_name, $prop_block_name, true, $prop_block_is_public);
					$prop_group_block = $object_type->getFieldsGroup($prop_group_block_id);
					$prop_group_block->setTitle($prop_block_title);
					$prop_group_block->commit();
				}

				if(!$missed_prop['field_type']) {
					$missed_prop['field_type'] = "string";
				}

				$field_type_id = $this->getFieldTypeId($missed_prop['field_type'], $missed_prop['is_multiple']);

				if($field_type_id === false) continue;


				$missed_prop['name'] = (string) $missed_prop['name'];

				if(!$missed_prop['name']) {
					$missed_prop['name'] = translit::convert($missed_prop['title']);
				}

				$missed_prop['name'] = translit::convert($missed_prop['name']);

				if($object_type_id) {
					if(umiImportRelations::getInstance()->getNewFieldId($this->source_id, $object_type_id, $missed_prop['name'])) {
						continue;
					}
				}


				if($missed_prop['field_type'] == "relation") {
					$guide_id = self::getAutoGuideId($missed_prop['title']);
				} else {
					$guide_id = false;
				}

				$field_id = umiFieldsCollection::getInstance()->addField($missed_prop['name'], $missed_prop['title'], $field_type_id, $missed_prop['is_public'], false);
				$field = umiFieldsCollection::getInstance()->getField($field_id);
				$field->setTip($missed_prop['tip']);

				if($guide_id) {
					$field->setGuideId($guide_id);
				}

				$field->commit();

				$prop_group_block->attachField($field_id);

				if($object_type_id) {
					umiImportRelations::getInstance()->setFieldIdRelation($this->source_id, $object_type_id, $missed_prop['name'], $field_id);
				}
			}
		}


		protected function getFieldTypeId($data_type, $is_multiple = false) {
			$field_types = umiFieldTypesCollection::getInstance()->getFieldTypesList();

			foreach($field_types as $field_type) {
				if($field_type->getDataType() == $data_type && $field_type->getIsMultiple() == $is_multiple) {
					return $field_type->getId();
				}
			}

			return false;
		}


		public function getAutoGuideId($title) {
			$guide_name = "Справочник для поля \"{$title}\"";

			$typesCollection = umiObjectTypesCollection::getInstance();
			$rootGuideId = $typesCollection->getTypeIdByGUID('root-guides-type');

			$child_types = $typesCollection->getChildClasses($rootGuideId);
			foreach($child_types as $child_type_id) {
				$child_type = umiObjectTypesCollection::getInstance()->getType($child_type_id);
				$child_type_name = $child_type->getName();

				if($child_type_name == $guide_name) {
					$child_type->setIsGuidable(true);
					return $child_type_id;
				}
			}

			$guide_id = umiObjectTypesCollection::getInstance()->addType($rootGuideId, $guide_name);
			$guide = umiObjectTypesCollection::getInstance()->getType($guide_id);
			$guide->setIsGuidable(true);
			$guide->setIsPublic(true);
			$guide->commit();

			return $guide_id;
		}

		/**
			* Получить количество импортированных в систему страниц
			* @return Integer количество импортированных страниц
			* !Deprecated не используется, т.к. не учитывает ошибки. Следует использовать getCreatedElemensCount, getUpdatedElementsCount
		*/
		public function getImportedElementsCount() {
			return $this->importedElements;
		}

		/**
			* Получить количество созданных импортером элементов
			* @return Integer количество созданных элементов
		*/
		public function getCreatedElementsCount() {
			return $this->createdElements;
		}

		/**
			* Получить количество обновленных импортером элементов
			* @return Integer количество обновленных элементов
		*/
		public function getUpdatedElementsCount() {
			return $this->updatedElements;
		}

		/**
			* Получить количество удаленных импортером элементов
			* @return Integer количество удаленных элементов
		*/
		public function getDeletedElementsCount() {
			return $this->deletedElements;
		}

		/**
			* Получить количество ошибок, при которых элементы не были созданы
			* @return Integer количество ошибок
		*/
		public function getImportErrorsCount() {
			return $this->importErrors;
		}

		/**
			* Получить лог импотра ввиде массива строк
		*/
		public function getImportLog() {
			return $this->importLog;
		}
	};


	interface iXmlImporter {
		public function __construct($source_name = false);
		public function loadXmlString($xml_string);
		public function loadXmlFile($xml_filepath);
		public function loadXmlDocument(DOMDocument $doc);
		public function setDestinationElement($element);
		public function execute();
	}



	class xmlImporter implements iXmlImporter {
		const VERSION = "2.0";
		const ROOT_PAGE_TYPE_ID = 3; // id корневого типа "Раздел сайта"


		protected $doc, $parser;
		protected $relations, $source_id;
		protected $destination_element_id = 0;

		protected $update_ignore = false;
		protected $demosite_mode = false;

		protected $meta = array();

		// counters
		public		$updated_types = 0, $created_types = 0,
					$updated_languages = 0, $created_languages = 0,
					$updated_domains = 0, $created_domains = 0,
					$updated_domain_mirrors = 0, $created_domain_mirrors = 0,
					$updated_templates = 0, $created_templates = 0,
					$updated_objects = 0, $created_objects = 0, $deleted_objects = 0,
					$updated_elements = 0, $created_elements = 0, $deleted_elements = 0,
					$copied_files = 0,
					$update_relations = 0,
					$created_restrictions = 0,
					$created_registry_items = 0,
					$created_permissions = 0,
					$created_field_types = 0,
					$created_dirs = 0,
					$import_errors = 0;

		public $filesSource = false;

		public $ignoreParentGroups = true;
		public $auto_guide_creation = false;
		public $renameFiles = false;

		protected	$import_log = array();
		protected	$imported_elements = array();

		public function __construct($source_name = false) {
			if ($source_name) $this->meta['source-name'] = $source_name;
			//umiObjectProperty::$USE_FORCE_OBJECTS_CREATION = true;
			$this->doc = new DomDocument("1.0", "utf-8");
			$this->relations = umiImportRelations::getInstance();
		}


		/**
		* Установить/откючить такой режим работы импортера, при котором обновление существующих объектов системы будет игнорироваться. Объекты системы только создаются.
		*
		* @param boolean $update_ignore
		*/
		public function setUpdateIgnoreMode($update_ignore = true) {
			$this->update_ignore = (bool) $update_ignore;
		}

		public function setAutoGuideCreation($auto_guide_creation = false) {
			$this->auto_guide_creation = (bool) $auto_guide_creation;
		}

		public function setRenameFiles($renameFiles = false) {
			$this->renameFiles = (bool) $renameFiles;
		}

		public function setDemositeMode ($demosite_mode = true){
			$this->demosite_mode = $demosite_mode;
		}

		public function loadXmlString($xml_string) {
			return $this->doc->loadXML($xml_string, DOM_LOAD_OPTIONS);
		}

		protected function getLabel($i18n) {
			$label = getLabel($i18n);
			if (!$label || $label == $i18n) {
				$label = str_replace('label-', '', $i18n);
				$label = preg_replace("/(.*?)-[m,f,n]+$/", "$1", $label);
				$label = str_replace('-', ' ', $label);
			}
			return $label;
		}

		public function loadXmlFile($xml_filepath) {
			if(!is_file($xml_filepath)) {
				throw new publicException($this->getLabel('label-cannot-read-file') . ' ' . $xml_filepath);
			}

			return $this->doc->load($xml_filepath, DOM_LOAD_OPTIONS);
		}

		public function loadXmlDocument(DOMDocument $doc) {
			$this->doc = $doc;
		}

		/**
			* Устанавливает элемент, в который будут попадать элементы, у которых в дампе не существует родителя.
			* По умолчанию такие элементы попадают в корень сайта
			* @param Variant Id элемента, либо сам элемент
			* @return Boolean true, если удалось установить значение
		*/
		public function setDestinationElement($element) {
			if ($element instanceof umiHierarchyElement) {
				$this->destination_element_id = $element->getId();
				return true;
			}
			if (umiHierarchy::getInstance()->getElement($element, true, true) instanceof umiHierarchyElement) {
				$this->destination_element_id = $element;
				return true;
			}
			return false;
		}

		public function execute() {
			$OLD_CACHE_STATE = cmsController::$IGNORE_MICROCACHE;
			$OLD_IGNORE_FILTER_INPUT_STRING = umiObjectProperty::$IGNORE_FILTER_INPUT_STRING;
			cmsController::$IGNORE_MICROCACHE = true;
			umiObjectProperty::$IGNORE_FILTER_INPUT_STRING = true;

			$config = mainConfiguration::getInstance();
			if(!$config->get('kernel', 'import-auto-index')) {
				if(!defined('DISABLE_SEARCH_REINDEX')) {
					define('DISABLE_SEARCH_REINDEX', 1);
				}
			}

			$old_creation = umiObjectProperty::$USE_FORCE_OBJECTS_CREATION;
			if ($this->auto_guide_creation) {
				umiObjectProperty::$USE_FORCE_OBJECTS_CREATION = true;
			} else {
				umiObjectProperty::$USE_FORCE_OBJECTS_CREATION = false;
			}


			$this->parser = new DOMXPath($this->doc);
			// check version
			$nl = $this->parser->evaluate("/umidump/@version");
			$version = $nl->length ? $nl->item(0)->nodeValue : "";
			if ($version != self::VERSION) {
				throw new publicException($this->getLabel("label-unknown-umidump-version"));
			}

			$this->parseMetaData();

			// set relations
			$this->source_id = $this->relations->getSourceId($this->meta['source-name']);
			if (!$this->source_id) {
				$this->source_id = $this->relations->addNewSource($this->meta['source-name']);
			}

			$this->importRegistry();
			$this->importDirs();
			if ($this->filesSource) $this->importFiles();
			$this->importLangs();
			$this->importDomains();
			$this->importTemplates();
			$this->importDataTypes();
			$this->importTypes();
			$this->importObjects();
			//$this->importBranches();
			$this->importElements();
			$this->importRelations();
			$this->importOptions();
			$this->importRestrictions();
			$this->setDefaultPermissions();
			$this->importPermissions();
			$this->importHierarchy();

			umiObjectProperty::$USE_FORCE_OBJECTS_CREATION = $old_creation;
			cmsController::$IGNORE_MICROCACHE = $OLD_CACHE_STATE;
			umiObjectProperty::$IGNORE_FILTER_INPUT_STRING = $OLD_IGNORE_FILTER_INPUT_STRING;

		}

		public function setFilesSource($filesSource) {
			if(!is_dir($filesSource)) {
				throw new coreException($this->getLabel("label-cannot-find-files-source"));

			}
			$this->filesSource = $filesSource;
		}

		public function setIgnoreParentGroups($ignoreParentGroups) {
			$this->ignoreParentGroups = $ignoreParentGroups;
		}

		protected function reportError($error) {
			$this->import_errors++;
			if (defined('UMICMS_CLI_MODE') && UMICMS_CLI_MODE) echo $error . "\n\r";
			else $this->import_log[] = "<font style='color:red''>" . $error . "</font>";
		}

		protected function writeLog($message) {
			if (defined('UMICMS_CLI_MODE') && UMICMS_CLI_MODE) echo $message . "\n\r";
			else $this->import_log[] = $message;
		}

		public function getImportLog() {

			return $this->import_log;
		}

		protected function parseMetaData() {
			$m = $this->meta;

			$nl = $this->parser->evaluate("/umidump/meta/site-name");
			$m['site-name'] =  $nl->length ? $nl->item(0)->nodeValue : "";

			$nl = $this->parser->evaluate("/umidump/meta/domain");
			$m['domain'] =  $nl->length ? $nl->item(0)->nodeValue : "";

			$nl = $this->parser->evaluate("/umidump/meta/lang");
			$m['lang'] =  $nl->length ? $nl->item(0)->nodeValue : "";

			if (!isset($m['source-name'])) {
				$nl = $this->parser->evaluate("/umidump/meta/source-name");
				$m['source-name'] =  $nl->length ? $nl->item(0)->nodeValue : md5($m['domain']);
			}

			$nl = $this->parser->evaluate("/umidump/meta/generate-time/timestamp");
			$m['generated'] =  $nl->length ? $nl->item(0)->nodeValue : "";

			$nl = $this->parser->evaluate("/umidump/meta/branches/id");
			$m['branches'] = array();
			foreach ($nl as $node) {
				$m['branches'][] = $node->nodeValue;
			}

			$this->meta = $m;
		}

		protected function importHierarchyType($base_module, $base_method, $base_title) {
			$collection = umiHierarchyTypesCollection::getInstance();
			$hierarchyType = $collection->getTypeByName($base_module, $base_method);
			if (!$hierarchyType instanceof umiHierarchyType) {
				$id = $collection->addType($base_module, $base_title, $base_method);
				$hierarchyType = $collection->getTypeByName($base_module, $base_method);
			}

			if (!$hierarchyType instanceof umiHierarchyType) {
				throw new coreException($this->getLabel("label-cannot-create-hierarchy-type") . "{$base_module}/{$base_method} ({$base_title})");
			}

			return $hierarchyType;
		}

		protected function importTypes() {
			$nl_types = $this->parser->evaluate("/umidump/types/type");
			foreach ($nl_types as $type_info) {
				$this->importType($type_info);
			}
		}

		protected function importType(DOMElement $type_info) {
			$old_id = $type_info->getAttribute('id');
			$type_name = $type_info->hasAttribute('title') ? $type_info->getAttribute('title') : null;

			if (!strlen($old_id)) {
				$this->reportError($this->getLabel('label-cannot-create-type') . " \"{$type_name}\" " . $this->getLabel('label-with-empty-id'));
				return false;
			}

			$old_parent_id = $type_info->getAttribute('parent-id');
			$is_guidable = $type_info->hasAttribute('guide') ? $type_info->getAttribute('guide') : null;
			$is_public = $type_info->hasAttribute('public') ? $type_info->getAttribute('public') : null;
			$is_locked = $type_info->hasAttribute('locked') ? $type_info->getAttribute('locked') : null;
			$guid = $type_info->hasAttribute('guid') ? $type_info->getAttribute('guid') : null;

			$collection = umiObjectTypesCollection::getInstance();

			$created = false;
			$new_type_id = false;

			if (!is_null($guid)) {
				$new_type_id = $collection->getTypeIdByGUID($guid);
				if ($new_type_id && $new_type_id != $this->relations->getNewTypeIdRelation($this->source_id, $old_id)) {
					$this->relations->setTypeIdRelation($this->source_id, $old_id, $new_type_id);
				}
			}
			if (!$new_type_id) $new_type_id = $this->relations->getNewTypeIdRelation($this->source_id, $old_id);

			if ($new_type_id && $this->update_ignore) {
				$this->writeLog($this->getLabel("label-datatype") . " \"" . $type_name . "\" ". $this->getLabel('label-already-exists'));
				return $collection->getType($new_type_id);
			}

			if(!$new_type_id) {

				$new_parent_type_id = (trim($old_parent_id, "{}") == 'root-pages-type') ? $collection->getTypeIdByGUID('root-pages-type') : $this->relations->getNewTypeIdRelation($this->source_id, $old_parent_id);

				if (is_null($type_name)) {
					$type_name = "Type #" . $old_id;
				}

				// import hierarchy type
				$nl = $this->parser->evaluate("base", $type_info);
				$base = $nl->length ? $nl->item(0) : false;

				$base_module = $base ? $base->getAttribute('module') : false;
				$base_method = $base ? $base->getAttribute('method') : false;
				$base_title = $base->nodeValue;

				$hierarchyType = false;
				if (strlen($base_module)) {
					$hierarchyType = $this->importHierarchyType($base_module, $base_method, $base_title);
					$main_object_type_id = $collection->getTypeByHierarchyTypeId($hierarchyType->getId());
					$mainObjectType = $collection->getType($main_object_type_id);

					if (trim($old_parent_id, "{}") == 'root-pages-type' && $mainObjectType instanceof umiObjectType) {
						$new_type_id = $mainObjectType->getId();
					} elseif (!$new_parent_type_id && $mainObjectType instanceof umiObjectType) {
						$new_parent_type_id = $mainObjectType->getId();
					}

				}

				if (!$new_type_id) $new_type_id = $collection->addType(intval($new_parent_type_id), trim($type_name), false, $this->ignoreParentGroups);
				$type = $collection->getType($new_type_id);
				if ($hierarchyType) $type->setHierarchyTypeId($hierarchyType->getId());

				$created = true;

				if (!is_null($guid)) $collection->getType($new_type_id)->setGUID($guid);
				$this->relations->setTypeIdRelation($this->source_id, $old_id, $new_type_id);

			}

			// import type groups and fields
			$type = $collection->getType($new_type_id);
			if (!$type instanceof umiObjectType) {
				$this->reportError($this->getLabel('label-cannot-detect-type') . $this->getLabel('label-datatype') . "{$type_name} ({$old_id})");
				return false;
			}

			if (!is_null($type_name)) $type->setName(trim($type_name));
			if (!is_null($is_public)) $type->setIsPublic($is_public == 'public' || $is_public == "1");
			if (!is_null($is_guidable)) $type->setIsGuidable($is_guidable == 'guide' || $is_guidable == "1");
			if (!is_null($is_locked)) $type->setIsLocked($is_locked == 'locked' || $is_locked == "1");
			$type->commit();


			if ($created) {
				$this->created_types++;
				$this->writeLog($this->getLabel('label-datatype') . " \"" . $type_name . "\" (" . $old_id . ") ". $this->getLabel('label-has-been-created-m'));
			} else {
				$this->updated_types++;
				$this->writeLog($this->getLabel('label-datatype') . " \"" . $type_name . "\" (" . $old_id . ") ". $this->getLabel('label-has-been-updated-m'));
			}

			$this->importTypeGroups($type, $type_info);

			return $type;
		}

		protected function importTypeGroups(umiObjectType $type, DOMElement $type_info) {
			$nl = $this->parser->evaluate("fieldgroups/group", $type_info);
			foreach ($nl as $group_info) {
				$this->importTypeGroup($type, $group_info);
			}
		}


		protected function importTypeGroup(umiObjectType $type, DOMElement $group_info, $import_fields = true) {
			$old_group_name = $group_info->getAttribute('name');
			if (!strlen($old_group_name)) return false;

			$new_group_name = self::translateName($old_group_name);

			$title = $group_info->hasAttribute('title') ? $group_info->getAttribute('title') : null;
			$is_visible = $group_info->hasAttribute('visible') ? $group_info->getAttribute('visible') : null;
			$is_locked = $group_info->hasAttribute('locked') ? $group_info->getAttribute('locked') : null;
			$is_active = $group_info->hasAttribute('active') ? $group_info->getAttribute('active') : null;

			$group = null;

			$group_id = $this->relations->getNewGroupId($this->source_id, $type->getId(), $old_group_name);
			if ($group_id) $group = $type->getFieldsGroup($group_id, true);

			if (!$group_id) {
				$group = $type->getFieldsGroupByName($new_group_name, true);
				if ($group) $this->relations->setGroupIdRelation($this->source_id, $type->getId(), $old_group_name, $group->getId());
			}

			if (!$group instanceof umiFieldsGroup) {
				if (is_null($title)) {
					$title = "Group #" . $old_group_name;
				}
				$group_id = $type->addFieldsGroup($new_group_name, trim($title), true, false);
				$this->relations->setGroupIdRelation($this->source_id, $type->getId(), $old_group_name, $group_id);
				$group = $type->getFieldsGroup($group_id, true);
			}

			if (!$group instanceof umiFieldsGroup) {
				$this->reportError($this->getLabel('label-cannot-import-group') . "{$old_group_name}:" . $this->getLabel('label-cannot-detect-group'));
				return false;
			}

			if (!is_null($title)) $group->setTitle(trim($title));
			if (!is_null($is_visible)) $group->setIsVisible($is_visible == 'visible' || $is_visible == '1');
			if (!is_null($is_active)) $group->setIsActive($is_active == 'active' || $is_active == '1');
			if (!is_null($is_locked)) $group->setIsLocked($is_locked == 'locked' || $is_locked == '1');
			$group->commit();

			if ($import_fields) $this->importGroupFields($group, $group_info);

			return $group;
		}

		protected function importGroupFields(umiFieldsGroup $group, DOMElement $group_info) {
			$nl = $this->parser->evaluate("field", $group_info);
			foreach ($nl as $field_info) {
				$this->importField($group, $field_info);
			}
		}

		protected function getFieldByName(umiFieldsGroup $group, $name) {
			$fields = $group->getFields();
			foreach ($fields as $field) {
				if ($field->getName() == $name) return $field;
			}
			return false;
		}

		protected function importFieldType($field_type_info) {
			$name = $field_type_info->getAttribute('name');
			$data_type = $field_type_info->getAttribute('data-type');
			$multiple = $field_type_info->getAttribute('multiple') == 1 || $field_type_info->getAttribute('multiple') == "multiple";
			if (!strlen($data_type)) return false;

			$collection = umiFieldTypesCollection::getInstance();
			$field_type = $collection->getFieldTypeByDataType($data_type, $multiple);

			$created = false;
			if (!$field_type instanceof  umiFieldType) {
				$field_type_id = $collection->addFieldType($name, $data_type);
				$field_type = $collection->getFieldType($field_type_id);
				$field_type->setIsMultiple($multiple);
				$field_type->commit();
				$created = true;
			}

			if ($created) {
				$this->created_field_types++;
				$this->writeLog($this->getLabel('label-field-type') . "\"" . $field_type->getName() . "\"" . $this->getLabel('label-has-been-created-m'));
			}

			return $field_type;
		}


		public function getAutoGuideId($title) {
			$guide_name = "Справочник для поля \"{$title}\"";

			$collection = umiObjectTypesCollection::getInstance();
			$parentTypeId = $collection->getTypeIdByGUID('root-guides-type');
			$child_types = $collection->getChildClasses($parentTypeId);
			foreach($child_types as $child_type_id) {
				$child_type = $collection->getType($child_type_id);
				$child_type_name = $child_type->getName();

				if($child_type_name == $guide_name) {
					$child_type->setIsGuidable(true);
					return $child_type_id;
				}
			}

			$guide_id = $collection->addType($parentTypeId, $guide_name);
			$guide = $collection->getType($guide_id);
			$guide->setIsGuidable(true);
			$guide->setIsPublic(true);
			$guide->commit();

			return $guide_id;
		}

		protected function importField(umiFieldsGroup $group, DOMElement $field_info) {
			$old_field_name = $field_info->getAttribute('name');
			if (!strlen($old_field_name)) {
				$this->reportError($this->getLabel('label-cannot-import-field-with-empty-name'));
				return false;
			}

			$title = $field_info->hasAttribute('title') ? $field_info->getAttribute('title') : null;
			$tip = $field_info->hasAttribute('tip') ? $field_info->getAttribute('tip') : null;
			$is_visible = $field_info->hasAttribute('visible') ? $field_info->getAttribute('visible') : null;
			$is_locked = $field_info->hasAttribute('locked') ? $field_info->getAttribute('locked') : null;
			$is_inheritable = $field_info->hasAttribute('inheritable') ? $field_info->getAttribute('inheritable') : null;
			$is_indexable = $field_info->hasAttribute('indexable') ? $field_info->getAttribute('indexable') : null;
			$is_filterable = $field_info->hasAttribute('filterable') ? $field_info->getAttribute('filterable') : null;
			$is_required = $field_info->hasAttribute('required') ? $field_info->getAttribute('required') : null;
			$is_system = $field_info->hasAttribute('system') ? $field_info->getAttribute('system') : null;

			$new_field_name = self::translateName($old_field_name);
			$object_type_id = $group->getTypeId();

			$collection = umiFieldsCollection::getInstance();
			$types_collection = umiObjectTypesCollection::getInstance();

			$field = null;

			$nl = $this->parser->evaluate("type", $field_info);
			$field_type_info = $nl->length ? $nl->item(0): false;
			if (!$field_type_info) {
				$this->reportError($this->getLabel('label-cannot-import-field') . " {$old_field_name}: " . $this->getLabel('label-cannot-detect-datatype'));
				return false;
			}

			$field_type = $this->importFieldType($field_type_info);
			if (!$field_type instanceof umiFieldType) {
				$this->reportError($this->getLabel('label-cannot-detect-field-type-for') . " {$old_field_name}");
				return false;
			}

			$field_type_id = $field_type->getId();

			$object_type = $types_collection->getType($object_type_id);

			$field_id = $object_type->getFieldId($new_field_name, false);
			if ($field_id) {
				$field = $collection->getField($field_id);
				if($field instanceof umiField && $field_id != $this->relations->getNewFieldId($this->source_id, $object_type_id, $old_field_name)){
					$this->relations->setFieldIdRelation($this->source_id, $object_type_id, $old_field_name, $field_id);
				}
			}

			if(!$field instanceof umiField) {
				$parent_type_id = $object_type->getParentId();
				if ($parent_type_id) {
					$parent_type = $types_collection->getType($parent_type_id);
					$parent_field_id = $parent_type->getFieldId($new_field_name, false);

					if ($parent_field_id) {
						$parentField = $collection->getField($parent_field_id, false);
						if ($parentField->getFieldTypeId() == $field_type_id && $parentField->getTitle() == $title) {
							$field = $parentField;
							$group->attachField($parent_field_id);
							$this->relations->setFieldIdRelation($this->source_id, $object_type_id, $old_field_name, $field->getId());
						}

					}

					if (!$field instanceof umiField) {

						$horisontalTypes = $types_collection->getSubTypesList($parent_type_id);
						foreach($horisontalTypes as $horisontalTypeId) {
							if($horisontalTypeId == $object_type_id) continue;
							$horisontalType = $types_collection->getType($horisontalTypeId);
							if($horisontalType instanceof umiObjectType == false) continue;

							if($horisontalFieldId = $horisontalType->getFieldId($new_field_name, false)) {
								$horisontalField = $collection->getField($horisontalFieldId);
								if($horisontalField instanceof umiField == false) continue;
								if ($horisontalField->getFieldTypeId() == $field_type_id && $horisontalField->getTitle() == $title) {
									$field = $horisontalField;
									$group->attachField($horisontalFieldId);
									$this->relations->setFieldIdRelation($this->source_id, $object_type_id, $old_field_name, $field->getId());
									break;
								}
							}
						}
					}
				}
			}

			if (!$field instanceof umiField) {
				if (is_null($title)) {
					$title = $old_field_name;
				}
				$field_id = $collection->addField($new_field_name, trim($title), $field_type_id, false, false, false);
				$this->relations->setFieldIdRelation($this->source_id, $object_type_id, $old_field_name, $field_id);

				$group->attachField($field_id);
				$field = $collection->getField($field_id);
				if (is_null($is_visible)) $field->setIsVisible($is_visible);
				if (is_null($is_filterable)) $field->setIsInFilter($is_filterable);
				if (is_null($is_indexable)) $field->setIsInSearch($is_indexable);
			}

			if (($field_type->getDataType() == 'relation' || $field_type->getDataType() == 'optioned') && $this->auto_guide_creation) {
				$field->setGuideId($this->getAutoGuideId($title));
			}

			if ($field->getFieldTypeId() != $field_type_id) $field->setFieldTypeId($field_type_id);

			if (!is_null($title)) $field->setTitle(trim($title));
			if (!is_null($is_visible)) $field->setIsVisible($is_visible == 'visible' || $is_visible == "1");
			if (!is_null($is_indexable)) $field->setIsInSearch($is_indexable == 'indexable' || $is_indexable == "1");
			if (!is_null($is_filterable)) $field->setIsInFilter($is_filterable == 'filterable' || $is_filterable == "1");
			if (!is_null($is_required)) $field->setIsRequired($is_required == 'required' || $is_required == "1");
			if (!is_null($is_system)) $field->setIsSystem($is_system == 'system' || $is_system == "1");
			if (!is_null($tip)) $field->setTip(trim($tip));
			if (!is_null($is_locked)) $field->setIsLocked($is_locked == 'locked' || $is_locked == "1");
			if (!is_null($is_inheritable)) $field->setIsInheritable($is_inheritable == 'inheritable' || $is_inheritable == "1");
			$tips = $this->parser->evaluate("tip", $field_info);
			$tip = $tips->length ? $tips->item(0): false;
			if ($tip) $field->setTip($tip->nodeValue);

			$field->commit();

			return $field;
		}


		protected function importBranches() {
			foreach ($this->meta['branches'] as $id) {
				$this->importBranch($id);
			}
		}

		protected function importElements() {
			$nl = $this->parser->evaluate("/umidump/pages/page");
			foreach ($nl as $info) {
				$this->importElement($info);
			}
		}


		protected function importBranch($id) {
			$nl = $this->parser->evaluate("/umidump/pages/page[@id = '" . $id . "']");
			if (!$nl->length) return false; //TODO: write log
			$this->importElement($nl->item(0));
			$nl = $this->parser->evaluate("/umidump/pages/page[@parentId = '" . $id . "']");
			foreach ($nl as $info) {
				$child_id = $info->getAttribute('id');
				if ($child_id) $this->importBranch($child_id);
			}
		}

		protected function detectTemplateId($filepath, $domain_id = false, $lang_id = false) {
			if($filepath) {
				if ($domain_id === false) $domain_id = cmsController::getInstance()->getCurrentDomain()->getId();
				if ($lang_id === false) $lang_id = cmsController::getInstance()->getCurrentLang()->getId();

				$templates = templatesCollection::getInstance()->getTemplatesList($domain_id, $lang_id);
				foreach($templates as $ctpl) {
					if($ctpl->getFilename() == $filepath) {
						return $ctpl->getId();
					}
				}
			}

			return false;
		}

		protected function importHierarchyRelation(DOMElement $info) {
			$old_id = $info->getAttribute('id');
			$old_parent_id = $info->getAttribute('parent-id');
			$ord = $info->getAttribute('ord');

			$element_id = $this->relations->getNewIdRelation($this->source_id, $old_id);

			if ($old_parent_id) {
				$parent_id = $this->relations->getNewIdRelation($this->source_id, $old_parent_id);
			} else {
				 $parent_id = $this->destination_element_id;
			}

			if($element_id) {

				$collection = umiHierarchy::getInstance();
				$element = $collection->getElement($element_id, true, true);
				if (!$element instanceof umiHierarchyElement) return false;

				if ($parent_id !== false) $element->setRel($parent_id);
				if ($ord) $element->setOrd($ord);
				$element->commit();
			}
		}

		protected function importElement(DOMElement $info) {
			$old_id = $info->getAttribute('id');
			$old_type_id = $info->getAttribute('type-id');
			$update_only = $info->getAttribute('update-only') == '1';

			$nl = $info->getElementsByTagName('name');
			$name = $nl->length ? $nl->item(0)->nodeValue : false;

			$nl = $info->getElementsByTagName('template');
			$template = $nl->length ? $nl->item(0)->nodeValue : null;

			if (!strlen($old_id)) {
				$this->reportError("Can't create element \"{$name}\" with empty id");
				return false;
			}

			$alt_name = $info->getAttribute('alt-name');
			if (!strlen($alt_name)) $alt_name = $name;
			$is_active = $info->hasAttribute('is-active') ? $info->getAttribute('is-active') : null;
			$old_parent_id = $info->hasAttribute('parentId') ? $info->getAttribute('parentId') : null;
			$is_visible = $info->hasAttribute('is-visible') ? $info->getAttribute('is-visible') : null;
			$is_deleted = $info->hasAttribute('is-deleted') ? $info->getAttribute('is-deleted') : null;
			$lang_id = $info->hasAttribute('lang-id') ? $info->getAttribute('lang-id') : false;
			$domain_id = $info->hasAttribute('domain-id') ? $info->getAttribute('domain-id') : false;
			$is_default = $info->hasAttribute('is-default') ? $info->getAttribute('is-default') : false;

			if($domain_id) $domain_id = $this->relations->getNewDomainIdRelation($this->source_id, $domain_id);
			if($lang_id) $lang_id = $this->relations->getNewLangIdRelation($this->source_id, $lang_id);

			$collection = umiHierarchy::getInstance();
			$types_collection = umiObjectTypesCollection::getInstance();

			$created = false;
			$element_id = $this->relations->getNewIdRelation($this->source_id, $old_id);

			if ($element_id && $this->update_ignore) {
				$this->writeLog("Element \"" . $name . "\" (#{$old_id}) already exists");
				return $collection->getElement($element_id);
			}

			if (!$element_id) {
				if ($update_only) {
					return false;
				}

				if (!$name) $name = $old_id;
				if (!strlen($old_type_id)) {
					$this->reportError($this->getLabel('label-cannot-create-element') . ": \"{$name}\" (#{$old_id}) ." . $this->getLabel('label-cannot-detect-type'));
					return false;
				}
				$type_id = $this->relations->getNewTypeIdRelation($this->source_id, $old_type_id);
				$type = $types_collection->getType($type_id);

				if (!$type instanceof umiObjectType) {
					$this->reportError($this->getLabel('label-cannot-create-element') . "\"{$name}\" ($old_id): " . $this->getLabel('label-cannot-detect-type') . " #{$old_type_id}");
					return false;
				}

				$hierarchyTypeId = $type->getHierarchyTypeId();
				if ($hierarchyTypeId) {
					$hierarchyType = umiHierarchyTypesCollection::getInstance()->getType($hierarchyTypeId);
					if ($hierarchyType instanceof umiHierarchyType) {
						$module = $hierarchyType->getModule();
						if (!regedit::getInstance()->getVal("//modules/{$module}")) return false;
					}
				}

				$parent_id = false;
				if ($old_parent_id) $parent_id = $this->relations->getNewIdRelation($this->source_id, $old_parent_id);
				if ($parent_id === false) $parent_id = $this->destination_element_id;

				// call event on before add element
				$oEventPoint = new umiEventPoint("exchangeOnAddElement");
				$oEventPoint->setParam("source_id", $this->source_id);
				$oEventPoint->setMode("before");
				$oEventPoint->setParam("parent_id", $parent_id);
				$oEventPoint->setParam("old_element_id", $old_id);
				$oEventPoint->setParam("type", $type);
				$oEventPoint->setParam("element_info", $info);

				umiEventsController::getInstance()->callEvent($oEventPoint);

				$element_id = $collection->addElement($parent_id, $type->getHierarchyTypeId(), $name, $alt_name, $type->getId(), $domain_id, $lang_id);

				$this->imported_elements[] = $element_id;
				$this->relations->setIdRelation($this->source_id, $old_id, $element_id);

				// default activity
				if (is_null($is_active)) {
					$nl = $info->getElementsByTagName('default-active');
					if ($nl->length) $is_active = $nl->item(0)->nodeValue;
				}
				// default visible
				if (is_null($is_visible)) {
					$nl = $info->getElementsByTagName('default-visible');
					if ($nl->length) $is_visible = $nl->item(0)->nodeValue;
				}

				// default template
				if (is_null($template)) {
					$nl = $info->getElementsByTagName('default-template');
					if ($nl->length) $template = $nl->item(0)->nodeValue;
				}

				$created = true;
			}

			$element = $collection->getElement($element_id, true, true);
			if (!$element instanceof umiHierarchyElement) return false;


			if (!$created) {
				// call on before update element
				$oEventPoint = new umiEventPoint("exchangeOnUpdateElement");
				$oEventPoint->setParam("source_id", $this->source_id);
				$oEventPoint->setMode("before");
				$oEventPoint->addRef("element", $element);
				$oEventPoint->setParam("element_info", $info);
				umiEventsController::getInstance()->callEvent($oEventPoint);
			}

			if ($name) $element->setName($name);
			if (!is_null($is_active)) $element->setIsActive($is_active == 'active' || $is_active == '1');
			if (!is_null($is_visible)) $element->setIsVisible($is_visible == 'visible' || $is_visible == '1');
			if ($is_default) $element->setIsDefault($is_default == 'default' || $is_default == '1');

			if (!is_null($template) && $tpl_id = $this->detectTemplateId($template, $domain_id, $lang_id)) {
			$element->setTplId($tpl_id);
			}

			if ($created) {
				$old_object_id = $info->hasAttribute('object-id') ? $info->getAttribute('object-id') : null;
				if (!is_null($old_object_id)) {
					$object_id = $element->getObjectId();
					$new_object_id = $this->relations->getNewObjectIdRelation($this->source_id, $old_object_id);
					if ($new_object_id) {
						$object = umiObjectsCollection::getInstance()->getObject($new_object_id);
						if ($element->getObjectTypeId() == $object->getTypeId()) {
							$element->setObject($object);
							$element->commit();
							umiObjectsCollection::getInstance()->delObject($object_id);
						} else {
							$this->relations->setObjectIdRelation($this->source_id, $old_object_id, $object_id);
						}
					} else {
						$this->relations->setObjectIdRelation($this->source_id, $old_object_id, $object_id);
					}
				}
			}

			if ($is_deleted == 'deleted' || $is_deleted == '1') $element->setIsDeleted(true);

			$this->importPropValues($element, $info, $created);

			if ($is_deleted && ($is_deleted == 'deleted' || $is_deleted == '1')) {
				$this->deleted_elements++;
				$this->writeLog($this->getLabel("label-page") . " \"" . $element->getName() . "\" (" . $old_id . ") ". $this->getLabel("label-has-been-deleted-m"));
			} elseif ($created) {
				$this->created_elements++;
				$this->writeLog($this->getLabel("label-page") . " \"" . $element->getName() . "\" (" . $old_id . ") " . $this->getLabel("label-has-been-created-f"));
			} elseif($element->getIsUpdated()) {
				$this->updated_elements++;
				$this->writeLog($this->getLabel("label-page") . " \"" . $element->getName() . "\" (" . $old_id . ") " . $this->getLabel("label-has-been-updated-f"));
			}

			if ($created) {
				// call event on after add element
				$oEventPoint = new umiEventPoint("exchangeOnAddElement");
				$oEventPoint->setParam("source_id", $this->source_id);
				$oEventPoint->setMode("after");
				$oEventPoint->addRef("element", $element);
				$oEventPoint->setParam("element_info", $info);
				umiEventsController::getInstance()->callEvent($oEventPoint);
			} else {
				// call event on after update element
				$oEventPoint = new umiEventPoint("exchangeOnUpdateElement");
				$oEventPoint->setParam("source_id", $this->source_id);
				$oEventPoint->setMode("after");
				$oEventPoint->addRef("element", $element);
				$oEventPoint->setParam("element_info", $info);
				umiEventsController::getInstance()->callEvent($oEventPoint);
			}

			$element->commit();

			$collection->unloadElement($element_id);

			return $element;
		}

		protected function importLang(DOMElement $info) {
			$old_id = $info->getAttribute('id');
			$title = $info->nodeValue;

			if (!strlen($old_id)) {
				$this->reportError($this->getLabel('label-cannot-create-language') . " \"{$title}\" " . $this->getLabel('label-with-empty-id'));
				return false;
			}

			$is_default = $info->hasAttribute('is-default') ? $info->getAttribute('is-default') : null;
			$prefix = $info->hasAttribute('prefix') ? $info->getAttribute('prefix') : null;

			$collection = langsCollection::getInstance();

			$created = false;
			$language_id = $this->relations->getNewLangIdRelation($this->source_id, $old_id);

			if (!$language_id) {
				if($prefix) {
					$language_id = $collection->getLangId($prefix);
					if ($language_id) $this->relations->setLangIdRelation($this->source_id, $old_id, $language_id);
				}
			}

			if (!$language_id) {

				if (!$title) $title = $old_id;
				$language_id = $collection->addLang($prefix, $title);

				$this->relations->setLangIdRelation($this->source_id, $old_id, $language_id);
				$created = true;
			}

			$language = $collection->getLang($language_id);

			if (!$language instanceof lang) {
				$this->reportError($this->getLabel('label-cannot-detect-language') . " \"{$title}\" ");
				return false;
			}

			if ($title) $language->setTitle($title);
			if (!is_null($is_default) && $is_default) {
				$collection->setDefault($language_id);
			}
			if (!is_null($prefix)) $language->setPrefix($prefix);

			$language->commit();

			if ($created) {
				$this->created_languages++;
				$this->writeLog($this->getLabel('label-language') . " \"" . $language->getTitle() . "\" (" . $old_id . ") " . $this->getLabel('label-has-been-updated-m'));
			} elseif($language->getIsUpdated()) {
				$this->updated_languages++;
				$this->writeLog($this->getLabel('label-language') . " \"" . $language->getTitle() . "\" (" . $old_id . ") " . $this->getLabel('label-has-been-created-m'));
			}

			return $language;
		}

		protected function importDomain(DOMElement $info) {
			$old_id = $info->getAttribute('id');

			if (!strlen($old_id)) {
				$this->reportError($this->getLabel('label-cannot-create-domain') . " \"{$host}\" " . $this->getLabel('label-with-empty-id'));
				return false;
			}

			$host = $info->hasAttribute('host') ? $info->getAttribute('host') : null;
			$old_lang_id = $info->hasAttribute('lang-id') ? $info->getAttribute('lang-id') : null;
			$is_default = $info->hasAttribute('is-default') ? $info->getAttribute('is-default') : null;

			$collection = domainsCollection::getInstance();

			$created = false;
			$domain_id = $this->relations->getNewDomainIdRelation($this->source_id, $old_id);
			if (!$domain_id) {
				if($host) {
					$domain_id = $collection->getDomainId($host);
					if ($domain_id) $this->relations->setDomainIdRelation($this->source_id, $old_id, $domain_id);
				}
			}

			if ($domain_id && $this->update_ignore) {
				$this->writeLog($this->getLabel('label-domain') . " \"" . $host . "\" (#{$old_id}) " . $this->getLabel('label-already-exists'));
				return $collection->getDomain($domain_id);
			}

			if (!$domain_id) {
				if (!$host) $host = $old_id;
				$lang_id = false;
				if (!is_null($old_lang_id)) $lang_id = $this->relations->getNewLangIdRelation($this->source_id, $old_lang_id);
				if (!$lang_id) $lang_id = langsCollection::getInstance()->getDefaultLang()->getId();

				$domain_id = $collection->addDomain($host, $lang_id);
				$this->relations->setDomainIdRelation($this->source_id, $old_id, $domain_id);
				$created = true;
			}

			$domain = $collection->getDomain($domain_id);
			if (!$domain instanceof domain) {
				$this->reportError($this->getLabel('label-cannot-detect-domain') . " \"{$host}\" ");
				return false;
			}

			if (!is_null($is_default) && $is_default) {
				if(!$collection->getDefaultDomain()) $collection->setDefaultDomain($domain_id);
			}

			if ($created) {
				$this->created_domains++;
				$this->writeLog($this->getLabel('label-domain') . " \"" . $host . "\" (#" . $old_id . ") " . $this->getLabel('label-has-been-created-m'));
			} elseif($domain->getIsUpdated()) {
				$this->updated_domains++;
				$this->writeLog($this->getLabel('label-domain') . " \"" . $host . "\" (#" . $old_id . ") has been " . $this->getLabel('label-has-been-updated-m'));
			}

			$nl = $info->getElementsByTagName('domain-mirror');
			foreach ($nl as $info) {
				$this->importDomainMirror($info, $domain);
			}

			$domain->commit();

			return $domain;
		}

		protected function importDomainMirror(DOMElement $info, domain $domain) {
			$old_id = $info->getAttribute('id');
			$host = $info->hasAttribute('host') ? $info->getAttribute('host') : null;

			if (!strlen($old_id)) {
				$this->reportError($this->getLabel('label-cannot-create-domain-mirror') . " \"{$host}\" " . $this->getLabel('label-with-empty-id'));
				return false;
			}

			$created = false;
			$mirror_id = $this->relations->getNewDomainMirrorIdRelation($this->source_id, $old_id);

			if (!$mirror_id) {
				if (!is_null($host)) {
					$mirror_id = $domain->getMirrowId($host);
					if ($mirror_id) $this->relations->setDomainMirrorIdRelation($this->source_id, $old_id, $mirror_id);
				}
			}

			if ($mirror_id && $this->update_ignore) {
				$this->writeLog($this->getLabel('label-domain') . " \"" . $host . "\" (#{$old_id}) " . $this->getLabel('label-already-exists'));
				return $domain->getMirrow($mirror_id);
			}

			if (!$mirror_id) {
				if (is_null($host)) $host = $old_id;
				$mirror_id = $domain->addMirrow($host);
				$this->relations->setDomainMirrorIdRelation($this->source_id, $old_id, $mirror_id);
				$created = true;
			}

			$domainMirror = $domain->getMirrow($mirror_id);
			if (!$domainMirror instanceof domainMirrow) {
				$this->reportError($this->getLabel('label-cannot-detect-domain-mirror') . " \"{$host}\"");
				return false;
			}

			if ($created) {
				$this->created_domain_mirrors++;
				$this->writeLog($this->getLabel('label-domain-mirror') . " \"" . $host . "\" (#" . $old_id . ") " . $this->getLabel('label-has-been-created-n'));
			} elseif($domainMirror->getIsUpdated()) {
				$this->updated_domain_mirrors++;
				$this->writeLog($this->getLabel('label-domain-mirror') . " \"" . $host . "\" (#" . $old_id . ") " . $this->getLabel('label-has-been-updated-n'));
			}


			return $domainMirror;
		}

		protected function importTemplate(DOMElement $info) {

			$old_id = $info->getAttribute('id');
			$title = $info->hasAttribute('title') ? $info->getAttribute('title') : null;

			if (!strlen($old_id)) {
				$this->reportError($this->getLabel('label-cannot-create-template') . " \"{$title}\" " . $this->getLabel('label-with-empty-id'));
				return false;
			}

			$collection = templatesCollection::getInstance();

			$filename = $info->hasAttribute('filename') ? $info->getAttribute('filename') : null;
			$old_domain_id = $info->hasAttribute('domain-id') ? $info->getAttribute('domain-id') : null;
			$old_lang_id = $info->hasAttribute('lang-id') ? $info->getAttribute('lang-id') : null;
			$is_default = $info->hasAttribute('is-default') ? $info->getAttribute('is-default') : null;
			$name = $info->hasAttribute('name') ? $info->getAttribute('name') : null;
			$type = $info->hasAttribute('type') ? $info->getAttribute('type') : null;

			$lang_id = false;
			$domain_id = false;
			if (!is_null($old_lang_id)) $lang_id = $this->relations->getNewLangIdRelation($this->source_id, $old_lang_id);
			if (!is_null($old_domain_id)) $domain_id = $this->relations->getNewDomainIdRelation($this->source_id, $old_domain_id);
			if(!$lang_id) $lang_id = langsCollection::getInstance()->getDefaultLang()->getId();
			if(!$domain_id) $domain_id = domainsCollection::getInstance()->getDefaultTemplate()->getId();


			$created = false;
			$template_id = $this->relations->getNewTemplateIdRelation($this->source_id, $old_id);

			if ($template_id && $this->update_ignore) {
				$this->writeLog($this->getLabel('label-template') . " \"" . $title . "\" (#{$old_id}) " . $this->getLabel('label-already-exists'));
				return $collection->getTemplate($template_id);
			}

			if (!$template_id) {
				if (!$title) $title = $old_id;

				$template_id = $this->detectTemplateId($filename, $domain_id, $lang_id);
				if(!$template_id) $template_id = $collection->addTemplate($filename, $title);
				$this->relations->setTemplateIdRelation($this->source_id, $old_id, $template_id);
				$created = true;
			}

			$template = $collection->getTemplate($template_id);
			if (!$template instanceof template) {
				$this->reportError($this->getLabel('label-cannot-detect-template') . "\"{$title}\"");
				return false;
			}


			if (!is_null($is_default)) $template->setIsDefault($is_default);
			if (!is_null($name)) $template->setName($name);
			if (!is_null($type)) $template->setType($type);

			$template->setLangId($lang_id);
			$template->setDomainId($domain_id);

			if ($created) {
				$this->created_templates++;
				$this->writeLog($this->getLabel('label-template') . " \"" . $title . "\" (" . $old_id . ") " .  $this->getLabel('label-has-been-created-m'));
			} elseif($template->getIsUpdated()) {
				$this->updated_templates++;
				$this->writeLog($this->getLabel('label-template') . " \"" . $title . "\" (" . $old_id . ") " .  $this->getLabel('label-has-been-updated-m'));
			}

			$template->commit();

			return $template;
		}

		protected function importRestriction(DOMElement $info) {

			$old_id = $info->getAttribute('id');
			$title = $info->hasAttribute('title') ? $info->getAttribute('title') : null;
			$prefix = $info->hasAttribute('prefix') ? $info->getAttribute('prefix') : null;
			$data_type = $info->hasAttribute('field-type') ? $info->getAttribute('field-type') : null;
			$multiple = $info->getAttribute('is-multiple') == 1 || $info->getAttribute('is-multiple') == "multiple";

			if (!strlen($old_id)) {
				$this->reportError($this->getLabel('label-cannot-create-restriction') . " \"{$title}\" " . $this->getLabel('label-with-empty-id'));
				return false;
			}

			$collection = umiFieldTypesCollection::getInstance();
			$field_type = $collection->getFieldTypeByDataType($data_type, $multiple);

			$type_id = $field_type->getId();
			$created = false;
			$restriction_id = false;
			if (!$title) $title = $old_id;

			if(baseRestriction::find($prefix, $type_id)) {
				$restriction_id = baseRestriction::find($prefix, $type_id)->getId();
				if ($restriction_id != $this->relations->getNewRestrictionIdRelation($this->source_id, $old_id)) {
					$this->relations->setRestrictionIdRelation($this->source_id, $old_id, $restriction_id);
				}
			}

			if (!$restriction_id) $restriction_id = $this->relations->getNewRestrictionIdRelation($this->source_id, $old_id);

			if(!$restriction_id) {
				$restriction_id = baseRestriction::add($prefix, $title, $type_id);
				$this->relations->setRestrictionIdRelation($this->source_id, $old_id, $restriction_id);
				$created = true;
			}

			$restriction = baseRestriction::get($restriction_id);
			if (!$restriction instanceof baseRestriction) {
				$this->reportError($this->getLabel('label-cannot-detect-restriction') . " \"{$title}\"");
				return false;
			}

			if ($created) {
				$this->created_restrictions++;
				$this->writeLog($this->getLabel('label-restriction') . " \"" . $restriction->getTitle() . "\" (" . $old_id . ") " . $this->getLabel('label-has-been-created-n'));
			}

			$fields = $info->getElementsByTagName('field');
			foreach ($fields as $fld) {
				$old_field_name = $fld->getAttribute('field-name');
				$old_object_type_id = $fld->getAttribute('type-id');
				$object_type_id = $this->relations->getNewTypeIdRelation($this->source_id, $old_object_type_id);

				$field_id = umiObjectTypesCollection::getInstance()->getType($object_type_id)->getFieldId(self::translateName($old_field_name), false);
			if (!$field_id) umiObjectTypesCollection::getInstance()->getType($object_type_id)->getFieldId($old_field_name, false);

				$field = umiFieldsCollection::getInstance()->getField($field_id);
					if (!$field instanceof umiField) {
						$this->reportError($this->getLabel('label-cannot-set-restriction-for-field') . " \"{$old_field_name}\": " . $this->getLabel('label-cannot-detect-field'));
						continue;
					}

				$field->setRestrictionId($restriction_id);
				$field->setIsUpdated();
				$this->writeLog($this->getLabel('label-restriction') . " \"" . $restriction->getTitle() . "\" " . $this->getLabel('label-has-been-set-for-field') . " \"{$old_field_name}\"");
			}

			return $restriction;
		}

		protected function importReg(DOMElement $info) {

			$path = $info->hasAttribute('path') ? $info->getAttribute('path') : null;
			$val = $info->hasAttribute('val') ? $info->getAttribute('val') : null;
			$need_update = $info->hasAttribute('update') ? true : false;

			if (!strlen($path)) {
				$this->reportError($this->getLabel('label-cannot-create-registry-item-with-empty-path'));
				return false;
			}

			$created = false;
			$updated = false;
			$regedit = regedit::getInstance();

			if(!$regedit->getKey($path)){
				$regedit->setVal($path, $val);
				$created = true;
				$new_key = $regedit->getKey($path);
			}
			elseif ($need_update) {
				$regedit->setVal($path, $val);
				$updated = true;
				$new_key = $regedit->getKey($path);
			}

			if ($created) {
				$this->created_registry_items++;
				$this->writeLog($this->getLabel('label-registry-item') . " \"" . $path . "\" (" . $new_key . ") " . $this->getLabel('label-has-been-created-f'));
			} elseif ($updated) {
				$this->writeLog("Registry item \"" . $path . "\" (" . $new_key . ") has been updated");
			}
		}

		protected function importTypeRelation(umiField $field, DOMElement $info, umiObjectType $type) {
			$old_guide_ids = $info->getElementsByTagName('guide');
			$old_guide_id = $old_guide_ids->length ? $old_guide_ids->item(0)->getAttribute('id') : false;

			$guide_id = $this->relations->getNewTypeIdRelation($this->source_id, $old_guide_id);
			if(!$guide_id) return false;

			if($field->getGuideId() != $guide_id) {
				$field->setGuideId($guide_id);
				$this->updated_relations++;
				$this->writeLog($this->getLabel('label-relation') . ': ' . $this->getLabel('label-datatype') . " (" . $type->getName() . ") - " . $this->getLabel('label-field') . " (" . $field->getName() . ") - " . $this->getLabel('label-guide') . " ({$guide_id}) " . $this->getLabel('label-has-been-updated-f'));
				$field->commit();
			}

			return true;
		}

		protected function importEntityRelation(umiField $field, DOMElement $info,  $entity) {

			$field_name = $field->getName();

			$n = $info->getElementsByTagName('object');
			$obj_ids = array();
			foreach ($n as $obj) {
				$old_obj_id = $obj->getAttribute('id');
				$obj_id = (int) $this->relations->getNewObjectIdRelation($this->source_id, $old_obj_id);
				if ($obj_id) $obj_ids[] = $obj_id;
			}

			$p = $info->getElementsByTagName('page');
			$pg_ids = array();
			foreach ($p as $pg) {
				$old_pg_id = $pg->getAttribute('id');
				$pg_id = (int) $this->relations->getNewIdRelation($this->source_id, $old_pg_id);
				if ($pg_id) $pg_ids[] = $pg_id;
			}

			$updated = false;
			$entity_type = ($entity instanceof umiObject) ? "object" : "page";
			$entity_id = $entity->getId();
			if (count($obj_ids)) {
				$value = $entity->getValue($field_name);
				if(!is_array($value)) $value = array($value);
				if(count(array_diff($obj_ids, $value))) {
					$entity->setValue($field_name, $obj_ids);
					$this->updated_relations++;
					$updated = true;
				}
			} elseif (count($pg_ids)) {
				$value = $entity->getValue($field_name);
				if(!is_array($value)) $value = array($value);
				if(count(array_diff($pg_ids, $value))) {
					$entity->setValue($field_name, $pg_ids);
					$this->updated_relations++;
					$updated = true;

				}
			} else {
				 $entity->setValue($field_name, array());
			}

			if ($updated) {
				if ($entity instanceof umiObject) {
					$this->writeLog($this->getLabel('label-values-for-field') . " ({$field_name}) " . $this->getLabel('label-of-object') . " ({$entity_id}) " . $this->getLabel('label-have-been-updated'));
				} else {
					$this->writeLog($this->getLabel('label-values-for-field') . " ({$field_name}) " . $this->getLabel('label-of-object') . " ({$entity_id}) " . $this->getLabel('label-have-been-updated'));
				}
			}

			$entity->commit();

			if ($entity instanceof umiObject) {
				umiObjectsCollection::getInstance()->unloadObject($entity_id);
			} else {
				umiHierarchy::getInstance()->unloadElement($entity_id);
			}
			return true;
		}

		protected function importRelation(DOMElement $info) {
			$old_type_id = $info->hasAttribute('type-id') ? $info->getAttribute('type-id') : null;
			$old_page_id = $info->hasAttribute('page-id') ? $info->getAttribute('page-id') : null;
			$old_object_id = $info->hasAttribute('object-id') ? $info->getAttribute('object-id') : null;

			$old_field_name = $info->hasAttribute('field-name') ? $info->getAttribute('field-name') : null;

			if (!strlen($old_type_id) && !strlen($old_page_id) && !strlen($old_object_id)) {
				$this->reportError($this->getLabel('label-cannot-create-relation-for-field') . " \"{$old_field_name}\":" . $this->getLabel('label-cannot-detect-entity'));
				return false;
			}

			$type_id = null;
			$entity = null;
			if (!is_null($old_type_id)) {
				$type_id = $this->relations->getNewTypeIdRelation($this->source_id, $old_type_id);
				$entity = umiObjectTypesCollection::getInstance()->getType($type_id);
			} elseif (!is_null($old_page_id)) {
				$page_id = $this->relations->getNewIdRelation($this->source_id, $old_page_id);
				$entity = umiHierarchy::getInstance()->getElement($page_id, true, true);
			} elseif(!is_null($old_object_id)) {
				$object_id = $this->relations->getNewObjectIdRelation($this->source_id, $old_object_id);
				$entity = umiObjectsCollection::getInstance()->getObject($object_id);
			}

			if (!$entity) {
				$this->reportError($this->getLabel('label-cannot-create-relation-for-field') . " \"{$old_field_name}\": " . $this->getLabel('label-cannot-detect-entity'));
				return false;
			}
			if ($entity instanceof umiHierarchyElement) $type_id = $entity->getObjectTypeId();
			if ($entity instanceof umiObject) $type_id = $entity->getTypeId();

			$field_id = umiObjectTypesCollection::getInstance()->getType($type_id)->getFieldId(self::translateName($old_field_name), false);
			if (!$field_id) umiObjectTypesCollection::getInstance()->getType($type_id)->getFieldId($old_field_name, false);

			if (!$field_id) {
				$this->reportError($this->getLabel('label-cannot-create-relation-for-field') . " \"{$old_field_name}\":" . $this->getLabel('label-cannot-detect-field'));
				return false;
			}

			$field = umiFieldsCollection::getInstance()->getField($field_id);

			if ($entity instanceof umiObjectType) {
				return $this->importTypeRelation($field, $info, $entity);
			} else {
				return $this->importEntityRelation($field, $info, $entity);
			}
		}

		protected function importPermission(DOMElement $info) {

			$old_page_id = $info->hasAttribute('page-id') ? $info->getAttribute('page-id') : null;
			$old_object_id = $info->hasAttribute('object-id') ? $info->getAttribute('object-id') : null;

			if (!strlen($old_page_id) && !strlen($old_object_id)) {
				$this->reportError($this->getLabel('label-cannot-create-permission') . ": " . $this->getLabel('label-cannot-detect-entity'));
				return false;
			}

			$permissions = permissionsCollection::getInstance();

			$entity = null;
			if(!is_null($old_page_id)) {
				$page_id = $this->relations->getNewIdRelation($this->source_id, $old_page_id);
				$entity = umiHierarchy::getInstance()->getElement($page_id, true, true);

			} elseif(!is_null($old_object_id)) {
				$object_id = $this->relations->getNewObjectIdRelation($this->source_id, $old_object_id);
				$entity = umiObjectsCollection::getInstance()->getObject($object_id);
			}

			if (!$entity) {
				$this->reportError($this->getLabel('label-cannot-create-permission') . ": " . $this->getLabel('label-cannot-detect-entity'));
				return false;
			}

			$entity_id = $entity->getId();

			$o = $info->getElementsByTagName('owner');
			foreach ($o as $owner) {
				$old_owner_id = $owner->getAttribute('id');
				$owner_id = (int) $this->relations->getNewObjectIdRelation($this->source_id, $old_owner_id);
				$level = $owner->hasAttribute('level') ? $owner->getAttribute('level') : null;
				if(!is_null($level)) {
					$permissions->setElementPermissions($owner_id, $entity_id, $level);
					$created = true;
					$this->created_permissions++;
				} else {
					$entity->setOwnerId($owner_id);
					$entity->setIsUpdated();
					$entity->commit();
					$this->writeLog($this->getLabel('label-owner-for-entity') . " (" . $entity_id . ") ". $this->getLabel('label-has-been-updated-m'));
					$this->created_permissions++;
				}
			}

			$m = $info->getElementsByTagName('module');
			foreach ($m as $module) {
				$module_name = $module->getAttribute('name');
				$method = $module->getAttribute('method');
				$allow = $module->getAttribute('allow');

				if ($method == '' || is_null($method)) {
					if (!$permissions->isAllowedModule($entity_id, $module_name)) {
						$permissions->setModulesPermissions($entity_id, $module_name);
						$this->writeLog($this->getLabel('label-permissions-for') . " " . $this->getLabel('label-module') . " \"{$module_name}\" " . $this->getLabel('label-of-object') . " (" . $entity_id . ") " . $this->getLabel('label-have-been-updated'));
						$this->created_permissions++;
					}
				} else {

					if(!$permissions->isAllowedMethod($entity_id, $module_name, $method)) {
						$permissions->setModulesPermissions($entity_id, $module_name, $method);
						$this->writeLog($this->getLabel('label-permissions-for') . " " . $this->getLabel('label-module') . " \"{$module_name}\" - " . $this->getLabel('label-method') . " \"{$method}\" " . $this->getLabel('label-of-object') . " (" . $entity_id . ") " . $this->getLabel('label-have-been-updated'));
						$this->created_permissions++;
					}
				}
			}
		}

		protected function importOption(DOMElement $info) {

			$old_page_id = $info->hasAttribute('page-id') ? $info->getAttribute('page-id') : null;
			$old_object_id = $info->hasAttribute('object-id') ? $info->getAttribute('object-id') : null;
			$old_field_name = $info->hasAttribute('field-name') ? $info->getAttribute('field-name') : null;

			if (!strlen($old_page_id) && !strlen($old_object_id)) {
				$this->reportError($this->getLabel('label-cannot-create-options-for-field') . " {$old_field_name} " . $this->getLabel('label-cannot-detect-entity'));
				return false;
			}

			$entity = null;
			if(!is_null($old_page_id)) {
				$page_id = $this->relations->getNewIdRelation($this->source_id, $old_page_id);
				$entity = umiHierarchy::getInstance()->getElement($page_id, true, true);

			} elseif(!is_null($old_object_id)) {
				$object_id = $this->relations->getNewObjectIdRelation($this->source_id, $old_object_id);
				$entity = umiObjectsCollection::getInstance()->getObject($object_id);
			}

			if (!$entity) {
				$this->reportError($this->getLabel('label-cannot-create-options-for-field') . " {$old_field_name} " . $this->getLabel('label-cannot-detect-entity'));
				return false;
			}
			if ($entity instanceof umiHierarchyElement) $type_id = $entity->getObjectTypeId();
			if ($entity instanceof umiObject) $type_id = $entity->getTypeId();


			$field_id = umiObjectTypesCollection::getInstance()->getType($type_id)->getFieldId(self::translateName($old_field_name), false);
			if (!$field_id) umiObjectTypesCollection::getInstance()->getType($type_id)->getFieldId($old_field_name, false);

			if (!$field_id) {
				$this->reportError($this->getLabel('label-cannot-create-options-for-field') . " {$old_field_name} " . $this->getLabel('label-cannot-detect-field'));
				return false;
			}

			$field = umiFieldsCollection::getInstance()->getField($field_id);

			$field_name = $field->getName();

			$o =  $this->parser->evaluate("option", $info);
			$values = array();
			foreach ($o as $option) {
				if($option->hasAttributes()) {
					$attributes = $option->attributes;
					if(!is_null($attributes)) {
						foreach ($attributes as $index => $attribute) {
							if($attribute->name == 'object-id') {
								$object_id = $this->relations->getNewObjectIdRelation($this->source_id, $attribute->value);
								if (!$object_id) {
									$this->reportError('ошибка');
									continue;
								}
								$name = umiObjectsCollection::getInstance()->getObject($object_id)->getName();
								$value['rel'] = $name;
							}
							elseif($attribute->name == 'page-id') {
								$page_id = $this->relations->getNewIdRelation($this->source_id, $attribute->value);
								if (!$page_id) {
									$this->reportError('ошибка');
									continue;
								}
								$name = umiHierarchy::getInstance()->getElement($page_id, true, true)->getName();
								$value['rel'] = $name;
							}
							else {
								$value[$attribute->name] = $attribute->value;
							}
						}
						$values[] = $value;
					}
				}
			}
			$entity->setValue($field_name, $values);
			$entity->commit();
		}

		protected function importFile(DOMElement $info) {

			$filename = $info->hasAttribute('name') ? $info->getAttribute('name') : null;
			$old_hash = $info->hasAttribute('hash') ? $info->getAttribute('hash') : null;

			$destinationPath = $info->nodeValue;
			if(!($destinationPath)) {
				$this->reportError($this->getLabel('label-cannot-create-file-with-empty-path'));
				return false;
			}

			$destinationPath = CURRENT_WORKING_DIR . $destinationPath;

			$destinationPathFolder = dirname($destinationPath);
			if(!file_exists($destinationPathFolder)) mkdir($destinationPathFolder, 0777, true);
			$sourcePath = $this->filesSource . $info->nodeValue;

			if (!file_exists($sourcePath)) {
				$this->reportError($this->getLabel('label-file') . " {$filename} " . $this->getLabel('label-does-not-exist'));
				return false;
			}

			if (copy($sourcePath, $destinationPath)) {
				$new_hash = md5_file($destinationPath);
				if ($old_hash != $new_hash) {
					$this->reportError($this->getLabel('label-file') . " {$filename} " . $this->getLabel('label-is-broken'));
				} else {
					if (defined("PHP_FILES_ACCESS_MODE") && strtolower(substr($destinationPath, -4, 4))==='.php') {
						chmod($destinationPath, PHP_FILES_ACCESS_MODE);
					}
					$this->copied_files++;
					$this->writeLog($this->getLabel('label-file') . " \"" . $filename . "\" (" . $destinationPath . ") " . $this->getLabel('label-has-been-copied-m'));
				}
			}
			else $this->reportError($this->getLabel('label-cannot-copy-file') ." \"{$filename}\"");
		}

		protected function importDir(DOMElement $info) {

			$name = $info->hasAttribute('name') ? $info->getAttribute('name') : null;
			$path = $info->hasAttribute('path') ? $info->getAttribute('path') : null;

			if(is_null($path)) {
				$this->reportError($this->getLabel('label-cannot-create-folder-with-empty-path'));
				return false;
			} else {
				$path = CURRENT_WORKING_DIR . $info->nodeValue;
			}

			if(!file_exists($path)) {
				mkdir($path, 0777, true);
				$this->created_dirs++;
				$this->writeLog($this->getLabel('label-folder') . " \"" . $name . "\" (" . $path . ") " . $this->getLabel('label-has-been-created-f'));
			}

		}


		protected function importObject(DOMElement $info) {
			$old_id = $info->getAttribute('id');

			if (!strlen($old_id)) {
				$this->reportError("Can't create object {$name} with empty id");
				return false;
			}

			$guid = $info->hasAttribute('guid') ? $info->getAttribute('guid') : null;
			$name = $info->hasAttribute('name') ? $info->getAttribute('name') : null;
			$old_type_id = $info->getAttribute('type-id');
			$update_only = $info->getAttribute('update-only') == '1';
			$is_locked = $info->getAttribute('locked');

			$collection = umiObjectsCollection::getInstance();
			$types_collection = umiObjectTypesCollection::getInstance();

			$created = false;
			$object_id = false;

			if (!is_null($guid)) {
				$object_id = $collection->getObjectIdByGUID($guid);
				if ($object_id && $object_id != $this->relations->getNewObjectIdRelation($this->source_id, $old_id)) {
					$this->relations->setObjectIdRelation($this->source_id, $old_id, $object_id);
				}
			}

			if (!$object_id) $object_id = $this->relations->getNewObjectIdRelation($this->source_id, $old_id);

			if ($object_id && $this->update_ignore) {
				$this->writeLog($this->getLabel('label-object') .  " \"" . $name . "\" (#{$old_id}) " . $this->getLabel('label-already-exists'));
				return $collection->getObject($object_id);
			}

			if (!$object_id) {
				if ($update_only) {
					return false;
				}
				if (!$name) $name = $old_id;
				if (!strlen($old_type_id)) {
					$this->reportError($this->getLabel('label-cannot-create-object') . " \"{$name}\" (#{$old_id}): " . $this->getLabel('label-cannot-detect-type'));
					return false;
				}
				$type_id = $this->relations->getNewTypeIdRelation($this->source_id, $old_type_id);
				$type = $types_collection->getType($type_id);
				if (!$type instanceof umiObjectType) {
					$this->reportError($this->getLabel('label-cannot-create-object') . " \"{$name}\" (#{$old_id}): " . $this->getLabel('label-cannot-detect-type'). " #{$old_type_id}");
					return false;
				}

				if ($this->demosite_mode) {
					$hierarchyTypeId = $type->getHierarchyTypeId();
					if ($hierarchyTypeId) {
						$hierarchyType = umiHierarchyTypesCollection::getInstance()->getType($hierarchyTypeId);
						if ($hierarchyType instanceof umiHierarchyType) {
							$module = $hierarchyType->getModule();
							if (!regedit::getInstance()->getVal("//modules/{$module}")) return false;
						}
					}
				}

				// call event on before add object
				$oEventPoint = new umiEventPoint("exchangeOnAddObject");
				$oEventPoint->setParam("source_id", $this->source_id);
				$oEventPoint->setMode("before");
				$oEventPoint->setParam("old_object_id", $old_id);
				$oEventPoint->setParam("object_info", $info);
				$oEventPoint->setParam("type", $type);
				umiEventsController::getInstance()->callEvent($oEventPoint);

				$object_id = $collection->addObject($name, $type_id, ($is_locked == 'locked' || $is_locked == '1'));
				$this->relations->setObjectIdRelation($this->source_id, $old_id, $object_id);
				$created = true;
			}
			$object = $collection->getObject($object_id);
			if (!$object instanceof umiObject) return false; //TODO: write log

			if (!is_null($guid)) $object->setGUID($guid);

			if (!$created) {
				// call on before update object
				$oEventPoint = new umiEventPoint("exchangeOnUpdateObject");
				$oEventPoint->setParam("source_id", $this->source_id);
				$oEventPoint->setMode("before");
				$oEventPoint->addRef("object", $object);
				$oEventPoint->setParam("object_info", $info);
				umiEventsController::getInstance()->callEvent($oEventPoint);
			}

			if (!is_null($name)) $object->setName($name);

			$this->importPropValues($object, $info, $created);

			if ($created) {
				$this->created_objects++;
				$this->writeLog($this->getLabel('label-object') . " \"" . $object->getName() . "\" (" . $old_id . ") ". $this->getLabel('label-has-been-created-m'));
			} elseif($object->getIsUpdated()) {
				$this->updated_objects++;
				$this->writeLog($this->getLabel('label-object') . " \"" . $object->getName() . "\" (" . $old_id . ") ". $this->getLabel('label-has-been-updated-m'));
			}

			if ($created) {
				// call event on after add object
				$oEventPoint = new umiEventPoint("exchangeOnAddObject");
				$oEventPoint->setParam("source_id", $this->source_id);
				$oEventPoint->setMode("after");
				$oEventPoint->addRef("object", $object);
				$oEventPoint->setParam("object_info", $info);
				umiEventsController::getInstance()->callEvent($oEventPoint);
			} else {
				// call event on after update object
				$oEventPoint = new umiEventPoint("exchangeOnUpdateObject");
				$oEventPoint->setParam("source_id", $this->source_id);
				$oEventPoint->setMode("after");
				$oEventPoint->addRef("object", $object);
				$oEventPoint->setParam("object_info", $info);
				umiEventsController::getInstance()->callEvent($oEventPoint);
			}

			$object->commit();

			$collection->unloadObject($object_id);
			return $object;
		}

		protected function importPropValues(umiEntinty $entity, DOMElement $info, $is_new_entity = false) {
			$nl = $this->parser->evaluate("properties/group/property", $info);
			foreach ($nl as $prop_info) {
				try {
					$this->importPropValue($entity, $prop_info, $is_new_entity);
				} catch (Exception $e) {
					$this->writeLog("Can't set value #" . $entity->getId() . "." . $info->getAttribute('name') . ": " . $e->getMessage());
				}
			}
		}

		protected static function translateName($name) {
			$name = umiHierarchy::convertAltName($name, "_");
			$name = umiObjectProperty::filterInputString($name);
			if(!strlen($name)) $name = '_';
			$name = substr($name, 0, 64);
			return $name;
		}

		protected function importPropValue(umiEntinty $entity, DOMElement $info, $is_new_entity = false) {
			$old_name = $info->getAttribute('name');
			$name = self::translateName($old_name);

			$nl =  $this->parser->evaluate("value", $info);
			if (!$nl->length && $is_new_entity) {
				$nl =  $this->parser->evaluate("default-value", $info);
			}
			if (!$nl->length) {
				if ($is_new_entity) $this->reportError($this->getLabel('label-property') . " \"{$name}\" " . $this->getLabel('label-has-no-values'));
				return false;
			}

			$value_node = $nl->item(0);

			$type_id = ($entity instanceof umiHierarchyElement) ? $entity->getObjectTypeId() : $entity->getTypeId();
			$type = umiObjectTypesCollection::getInstance()->getType($type_id);
			$field_id = $type->getFieldId($name, false);
			$field = umiFieldsCollection::getInstance()->getField($field_id);

			if (!$field instanceof umiField && $info->getAttribute('allow-runtime-add') == '1')  {
				//  try add runtime group
				$group_info = $info->parentNode;
				$group = $this->importTypeGroup($type, $group_info, false);
				if (!$group instanceof umiFieldsGroup) return false;
				//  try add runtime field
				$field = $this->importField($group, $info);
				($entity instanceof umiHierarchyElement) ? $entity->getObject()->update() : $entity->update();
			}

			if (!$field instanceof umiField) return false;

			switch($field->getDataType()) {
				// ignored types
				case "optioned":
				case "symlink":  {
					return false; //import relations();
				}
				case "date": {
					$timestamp = intval($value_node->getAttribute('unix-timestamp'));
					$uDate = new umiDate();
					if ($timestamp) {
						$uDate->setDateByTimeStamp($timestamp);
					} else {
						$uDate->setDateByString($value_node->nodeValue);
					}
					$entity->setValue($name, $uDate);

					break;
				}
				case "price": {
					$emarket = cmsController::getInstance()->getModule('emarket');
 					$price = $value_node->nodeValue;
 					$price = str_replace(',', '.', $price);
					$price = floatval(preg_replace("/[^0-9.,]/", "", $price));
					$currency_code = $value_node->hasAttribute('currency-code') ? $value_node->getAttribute('currency-code') : $value_node->getAttribute('currency_code');
					if (strlen($currency_code) && $emarket) {
						$currency = $emarket->getCurrency($currency_code);
						if ($currency) {
							$result = $emarket->formatCurrencyPrice(array($price), $emarket->getDefaultCurrency(), $currency);
							$price = $result[0];
						}
					}
					$entity->setValue($name, $price);

					break;
				}

				/* files */
				case "file":
				case "img_file":
				case "video_file":
				case "swf_file": {

					if ($this->renameFiles) {

						$oldFileName = false;
						$oldFile = $entity->getValue($name);
						if ($oldFile instanceof umiFile) $oldFileName = $oldFile->getFilePath();

						$origFilePath = ltrim(trim($value_node->nodeValue, "\r\n"), ".");

						$filename = basename($origFilePath);
						$dir 	  = dirname ($origFilePath);

						$ext = explode(".", $filename);
						$ext = end($ext);

						$filename_translit = translit::convert(trim($entity->getName(), "\r\n"));
						$filename = $filename_translit;

						$count = 0;
						$old = error_reporting(0);
						while(true) {
							if(!file_exists(CURRENT_WORKING_DIR.'/'.$origFilePath)) {
								break(2);
							} else {
								if($oldFileName) {

									$oldFilePath = CURRENT_WORKING_DIR . ltrim($oldFileName, ".");
									if (file_exists($oldFilePath)) unlink($oldFilePath);
							}
							}

							if(!file_exists(CURRENT_WORKING_DIR.'/'.$dir  . '/' .  $filename.'.'.$ext)) {
								break;
							}

							$count++;
							$filename = $filename_translit . '_'.$count;

						}
						$filename .= '.'.$ext;

						rename(CURRENT_WORKING_DIR.'/'.$origFilePath, CURRENT_WORKING_DIR.'/'.$dir  . '/' .  $filename);
						error_reporting($old);

						$origFilePath = '.' . $dir  . '/' .  $filename;
						$entity->setValue($name, $origFilePath);

					} else {
						$filePath = ltrim(trim($value_node->nodeValue, "\r\n"), ".");
						$entity->setValue($name, "." . $filePath);
					}


					break;
				}

				case "relation": {

					if($this->auto_guide_creation) {

						/* for emarket */
						if ($name == 'payment_status_id' && $type->getMethod() == 'order') {

							$emarket = cmsController::getInstance()->getModule('emarket');
							if ($emarket) {
								umiObjectProperty::$USE_FORCE_OBJECTS_CREATION = false;
								$codename = $value_node->nodeValue;
								$order = order::get($entity->id);
								$order->setPaymentStatus($codename);
								$order->commit();
								umiObjectProperty::$USE_FORCE_OBJECTS_CREATION = true;
							}
						} elseif ($name == 'status_id' && $type->getMethod() == 'order') {
							$emarket = cmsController::getInstance()->getModule('emarket');
							if ($emarket) {
								$codename = $value_node->nodeValue;
								$order = order::get($entity->id);
								$old_status_id = $order->getOrderStatus();
								$old_status_code = $order->getCodeByStatus($old_status_id);
								if (!in_array($old_status_code, array('ready', 'canceled', 'rejected'))) {
									umiObjectProperty::$USE_FORCE_OBJECTS_CREATION = false;
									$order->setOrderStatus($codename);
									$order->commit();
									umiObjectProperty::$USE_FORCE_OBJECTS_CREATION = true;
								}
							}

						} else {
							$items = array();
							$nl = $value_node->getElementsByTagName("item");
							foreach ($nl as $item_info) {
								$items[] = $item_info->getAttribute('name');
							}
							$entity->setValue($name, $items);
						}
					}
					break;
				}
				case "tags": {
					$nl =  $this->parser->evaluate("combined", $info);
					if ($value_node = $nl->item(0))	$entity->setValue($name, trim($value_node->nodeValue, "\r\n"));
					break;
				}

				// simple props save
				case "string":
				case "text":
				case "wysiwyg":
				case "boolean":
				case "counter":
				case "float":
				case "int": {
					if ($name == 'payment_type_id' || $name == 'modificator_type_id' || $name == 'rule_type_id' || $name == 'delivery_type_id') {
						$newValue = $this->relations->getNewTypeIdRelation($this->source_id, $value_node->nodeValue);
						if ($newValue) $entity->setValue($name, $newValue);
						break;
					}
				}
				default: {
					$entity->setValue($name, trim($value_node->nodeValue, "\r\n"));
					break;
				}
			}

		}

		protected function importLangs() {
			$nl = $this->parser->evaluate("/umidump/langs/lang");
			foreach ($nl as $info) {
				$this->importLang($info);
			}
		}


		protected function importObjects() {
			$nl = $this->parser->evaluate("/umidump/objects/object");
			foreach ($nl as $info) {
				$this->importObject($info);
			}
		}

		protected function importDomains() {
			$nl = $this->parser->evaluate("/umidump/domains/domain");
			foreach ($nl as $info) {
				$this->importDomain($info);
			}
		}

		protected function importTemplates() {
			$nl = $this->parser->evaluate("/umidump/templates/template");
			foreach ($nl as $info) {
				$this->importTemplate($info);
			}
		}

		protected function importFiles() {

			$nl = $this->parser->evaluate("/umidump/files/file");

			foreach ($nl as $info) {
				$this->importFile($info);
			}
		}

		protected function importDirs() {

			$nl = $this->parser->evaluate("/umidump/directories/directory");

			foreach ($nl as $info) {
				$this->importDir($info);
			}
		}

		protected function importRelations () {
			$nl = $this->parser->evaluate("/umidump/relations/relation");
			foreach ($nl as $info) {
				$this->importRelation($info);
			}
		}

		protected function importRestrictions () {
			$nl = $this->parser->evaluate("/umidump/restrictions/restriction");
			foreach ($nl as $info) {
				$this->importRestriction($info);
			}
		}

		protected function importRegistry () {
			$nl = $this->parser->evaluate("/umidump/registry/key");
			foreach ($nl as $info) {
				$this->importReg($info);
			}
		}

		protected function setDefaultPermissions () {
			if(!count($this->imported_elements)) return;
			$collection = permissionsCollection::getInstance();
			foreach ($this->imported_elements as $element_id) {
				$collection->setDefaultPermissions($element_id);
			}
		}

		protected function importPermissions () {
			$nl = $this->parser->evaluate("/umidump/permissions/permission");
			foreach ($nl as $info) {
				$this->importPermission($info);
			}
		}

		protected function importOptions () {
			$nl = $this->parser->evaluate("/umidump/options/entity");
			foreach ($nl as $info) {
				$this->importOption($info);
			}
		}

		protected function importDataTypes () {
			$nl = $this->parser->evaluate("/umidump/datatypes/datatype");
			foreach ($nl as $info) {
				$this->importFieldType($info);
			}
		}

		protected function importHierarchy() {
			$nl = $this->parser->evaluate("/umidump/hierarchy/relation");
			foreach ($nl as $info) {
				$this->importHierarchyRelation($info);
			}
			if($nl->length) {
				umiHierarchy::getInstance()->rebuildRelationNodes($this->destination_element_id);
			}
		}

	};



	interface iUmiImportRelations {
		public function getSourceId($sourceName);
		public function addNewSource($sourceName);

		public function setIdRelation($sourceId, $oldId, $newId);
		public function getNewIdRelation($sourceId, $oldId);
		public function getOldIdRelation($sourceId, $newId);

		public function setTypeIdRelation($sourceId, $oldId, $newId);
		public function getNewTypeIdRelation($sourceId, $oldId);
		public function getOldTypeIdRelation($sourceId, $newId);


		public function setFieldIdRelation($sourceId, $typeId, $oldFieldName, $newFieldId);
		public function getNewFieldId($sourceId, $typeId, $oldFieldName);
		public function getOldFieldName($sourceId, $typeId, $newFieldId);
	};



	class umiImportRelations extends singleton implements iUmiImportRelations {
		protected function __construct() {
		}

		public static function getInstance($c = NULL) {
			return parent::getInstance(__CLASS__);
		}


		public function getSourceId($source_name) {
			$source_name = l_mysql_real_escape_string($source_name);

			$sql = "SELECT id FROM cms3_import_sources WHERE source_name = '{$source_name}'";
			$result = l_mysql_query($sql,true);

			if(list($source_id) = mysql_fetch_row($result)) {
				return $source_id;
			} else {
				return false;
			}
		}


		public function addNewSource($source_name) {
			if($source_id = $this->getSourceId($source_name)) {
				return $source_id;
			} else {
				$source_name = l_mysql_real_escape_string($source_name);

				$sql = "INSERT INTO cms3_import_sources (source_name) VALUES('{$source_name}')";
				l_mysql_query($sql, true);

				return l_mysql_insert_id();
			}
		}


		public function setIdRelation($source_id, $old_id, $new_id) {
			$source_id = l_mysql_real_escape_string($source_id);
			$old_id = l_mysql_real_escape_string($old_id);
			$new_id = l_mysql_real_escape_string($new_id);

			if(!$new_id) {
				return false;
			}

			$sql = "DELETE FROM cms3_import_relations WHERE source_id = '{$source_id}' AND (new_id = '{$new_id}' OR old_id = '{$old_id}')";
			l_mysql_query($sql);

			$sql = "INSERT INTO cms3_import_relations (source_id, old_id, new_id) VALUES('{$source_id}', '{$old_id}', '{$new_id}')";
			l_mysql_query($sql);

			return true;
		}


		public function getNewIdRelation($source_id, $old_id) {
			$source_id = l_mysql_real_escape_string($source_id);
			$old_id = l_mysql_real_escape_string($old_id);

			$sql = "SELECT new_id FROM cms3_import_relations WHERE old_id = '{$old_id}' AND source_id = '{$source_id}'";
			$result = l_mysql_query($sql, true);

			if(list($new_id) = mysql_fetch_row($result)) {
				return (string) $new_id;
			} else {
				return false;
			}
		}


		public function getOldIdRelation($source_id, $new_id) {
			$source_id = l_mysql_real_escape_string($source_id);
			$new_id =  l_mysql_real_escape_string($new_id);

			$sql = "SELECT old_id FROM cms3_import_relations WHERE new_id = '{$new_id}' AND source_id = '{$source_id}'";
			$result = l_mysql_query($sql, true);

			if(list($old_id) = mysql_fetch_row($result)) {
				return (string) $old_id;
			} else {
				return false;
			}
		}

		public function setObjectIdRelation($source_id, $old_id, $new_id) {
			$source_id = l_mysql_real_escape_string($source_id);
			$old_id = l_mysql_real_escape_string($old_id);
			$new_id = l_mysql_real_escape_string($new_id);

			if(!$new_id) {
				return false;
			}

			$sql = "DELETE FROM cms3_import_objects WHERE source_id = '{$source_id}' AND (new_id = '{$new_id}' OR old_id = '{$old_id}')";
			l_mysql_query($sql);

			$sql = "INSERT INTO cms3_import_objects (source_id, old_id, new_id) VALUES('{$source_id}', '{$old_id}', '{$new_id}')";
			l_mysql_query($sql);

			return true;
		}


		public function getNewObjectIdRelation($source_id, $old_id) {
			$source_id = l_mysql_real_escape_string($source_id);
			$old_id = l_mysql_real_escape_string($old_id);

			$sql = "SELECT new_id FROM cms3_import_objects WHERE old_id = '{$old_id}' AND source_id = '{$source_id}'";
			$result = l_mysql_query($sql, true);

			if(list($new_id) = mysql_fetch_row($result)) {
				return (string) $new_id;
			} else {
				return false;
			}
		}


		public function getOldObjectIdRelation($source_id, $new_id) {
			$source_id = l_mysql_real_escape_string($source_id);
			$new_id = l_mysql_real_escape_string($new_id);

			$sql = "SELECT old_id FROM cms3_import_objects WHERE new_id = '{$new_id}' AND source_id = '{$source_id}'";
			$result = l_mysql_query($sql, true);

			if(list($old_id) = mysql_fetch_row($result)) {
				return (string) $old_id;
			} else {
				return false;
			}
		}

		public function setTypeIdRelation($source_id, $old_id, $new_id) {
			$source_id = l_mysql_real_escape_string($source_id);
			$old_id = l_mysql_real_escape_string($old_id);
			$new_id = l_mysql_real_escape_string($new_id);

			$sql = "DELETE FROM cms3_import_types WHERE source_id = '{$source_id}' AND (new_id = '{$new_id}' OR old_id = '{$old_id}')";
			l_mysql_query($sql);

			$sql = "INSERT INTO cms3_import_types (source_id, old_id, new_id) VALUES('{$source_id}', '{$old_id}', '{$new_id}')";
			l_mysql_query($sql);

			return true;
		}


		public function getNewTypeIdRelation($source_id, $old_id) {
			$source_id = l_mysql_real_escape_string($source_id);
			$old_id = l_mysql_real_escape_string($old_id);

			$sql = "SELECT new_id FROM cms3_import_types WHERE old_id = '{$old_id}' AND source_id = '{$source_id}'";
			$result = l_mysql_query($sql, true);

			if(list($new_id) = mysql_fetch_row($result)) {
				return (string) $new_id;
			} else {
				return false;
			}
		}


		public function getOldTypeIdRelation($source_id, $new_id) {
			$source_id = l_mysql_real_escape_string($source_id);
			$new_id = l_mysql_real_escape_string($new_id);

			$sql = "SELECT old_id FROM cms3_import_types WHERE new_id = '{$new_id}' AND source_id = '{$source_id}'";
			$result = l_mysql_query($sql, true);

			if(list($old_id) = mysql_fetch_row($result)) {
				return (string) $old_id;
			} else {
				return false;
			}
		}


		public function setFieldIdRelation($source_id, $type_id, $old_field_name, $new_field_id) {
			$source_id = l_mysql_real_escape_string($source_id);
			$type_id = l_mysql_real_escape_string($type_id);
			$old_field_name = l_mysql_real_escape_string($old_field_name);
			$new_field_id = l_mysql_real_escape_string($new_field_id);


			$sql = "DELETE FROM cms3_import_fields WHERE source_id = '{$source_id}' AND type_id = '{$type_id}' AND (field_name = '{$old_field_name}' OR new_id = '{$new_field_id}')";
			l_mysql_query($sql);

			$sql = "INSERT INTO cms3_import_fields (source_id, type_id, field_name, new_id) VALUES('{$source_id}', '{$type_id}', '{$old_field_name}', '{$new_field_id}')";
			l_mysql_query($sql);

			return (string) $new_field_id;
		}


		public function getNewFieldId($source_id, $type_id, $old_field_name) {
			$source_id = l_mysql_real_escape_string($source_id);
			$type_id = l_mysql_real_escape_string($type_id);
			$old_field_name = l_mysql_real_escape_string($old_field_name);

			$sql = "SELECT new_id FROM cms3_import_fields WHERE source_id = '{$source_id}' AND type_id = '{$type_id}' AND field_name = '{$old_field_name}'";
			$result = l_mysql_query($sql, true);

			if(list($new_field_id) = mysql_fetch_row($result)) {
				return (string) $new_field_id;
			} else {
				return false;
			}
		}

		public function getOldFieldName($source_id, $type_id, $new_field_id) {
			$source_id = l_mysql_real_escape_string($source_id);
			$type_id = l_mysql_real_escape_string($type_id);
			$new_field_id = l_mysql_real_escape_string($new_field_id);

			$sql = "SELECT field_name FROM cms3_import_fields WHERE source_id = '{$source_id}' AND type_id = '{$type_id}' AND new_id = '{$new_field_id}'";
			$result = l_mysql_query($sql, true);

			if(list($old_field_name) = mysql_fetch_row($result)) {
				return (string) $old_field_name;
			} else {
				return false;
			}
		}

		public function setGroupIdRelation($source_id, $type_id, $old_group_name, $new_group_id) {
			$source_id = l_mysql_real_escape_string($source_id);
			$type_id = l_mysql_real_escape_string($type_id);
			$old_group_name = l_mysql_real_escape_string($old_group_name);
			$new_group_id = l_mysql_real_escape_string($new_group_id);


			$sql = "DELETE FROM cms3_import_groups WHERE source_id = '{$source_id}' AND type_id = '{$type_id}' AND (group_name = '{$old_group_name}' OR new_id = '{$new_group_id}')";
			l_mysql_query($sql);

			$sql = "INSERT INTO cms3_import_groups (source_id, type_id, group_name, new_id) VALUES('{$source_id}', '{$type_id}', '{$old_group_name}', '{$new_group_id}')";
			l_mysql_query($sql);


			return (string) $new_group_id;
		}

		public function getNewGroupId($source_id, $type_id, $old_group_name) {
			$source_id = l_mysql_real_escape_string($source_id);
			$type_id = l_mysql_real_escape_string($type_id);
			$old_group_name = l_mysql_real_escape_string($old_group_name);

			$sql = "SELECT new_id FROM cms3_import_groups WHERE source_id = '{$source_id}' AND type_id = '{$type_id}' AND group_name = '{$old_group_name}'";
			$result = l_mysql_query($sql, true);

			if(list($new_group_id) = mysql_fetch_row($result)) {
				return (string) $new_group_id;
			} else {
				return false;
			}
		}

		public function getOldGroupName($source_id, $type_id, $new_group_id) {
			$source_id = l_mysql_real_escape_string($source_id);
			$type_id = l_mysql_real_escape_string($type_id);
			$new_group_id = l_mysql_real_escape_string($new_group_id);

			$sql = "SELECT group_name FROM cms3_import_groups WHERE source_id = '{$source_id}' AND type_id = '{$type_id}' AND new_id = '{$new_group_id}'";
			$result = l_mysql_query($sql, true);

			if(list($old_group_name) = mysql_fetch_row($result)) {
				return l_mysql_real_escape_string($old_group_name);
			} else {
				return false;
			}
		}

		public function setDomainIdRelation($source_id, $old_id, $new_id) {
			$source_id = l_mysql_real_escape_string($source_id);
			$old_id = l_mysql_real_escape_string($old_id);
			$new_id = l_mysql_real_escape_string($new_id);

			$sql = "DELETE FROM cms3_import_domains WHERE source_id = '{$source_id}' AND (new_id = '{$new_id}' OR old_id = '{$old_id}')";
			l_mysql_query($sql);

			$sql = "INSERT INTO cms3_import_domains (source_id, old_id, new_id) VALUES('{$source_id}', '{$old_id}', '{$new_id}')";
			l_mysql_query($sql);

			return true;
		}


		public function getNewDomainIdRelation($source_id, $old_id) {
			$source_id = l_mysql_real_escape_string($source_id);
			$old_id = l_mysql_real_escape_string($old_id);

			$sql = "SELECT new_id FROM cms3_import_domains WHERE old_id = '{$old_id}' AND source_id = '{$source_id}'";
			$result = l_mysql_query($sql, true);

			if(list($new_id) = mysql_fetch_row($result)) {
				return (string) $new_id;
			} else {
				return false;
			}
		}


		public function getOldDomainIdRelation($source_id, $new_id) {
			$source_id = l_mysql_real_escape_string($source_id);
			$new_id = l_mysql_real_escape_string($new_id);

			$sql = "SELECT old_id FROM cms3_import_domains WHERE new_id = '{$new_id}' AND source_id = '{$source_id}'";
			$result = l_mysql_query($sql, true);

			if(list($old_id) = mysql_fetch_row($result)) {
				return (string) $old_id;
			} else {
				return false;
			}
		}

		public function setDomainMirrorIdRelation($source_id, $old_id, $new_id) {
			$source_id = l_mysql_real_escape_string($source_id);
			$old_id = l_mysql_real_escape_string($old_id);
			$new_id = l_mysql_real_escape_string($new_id);

			$sql = "DELETE FROM cms3_import_domain_mirrors WHERE source_id = '{$source_id}' AND (new_id = '{$new_id}' OR old_id = '{$old_id}')";
			l_mysql_query($sql);

			$sql = "INSERT INTO cms3_import_domain_mirrors (source_id, old_id, new_id) VALUES('{$source_id}', '{$old_id}', '{$new_id}')";
			l_mysql_query($sql);

			return true;
		}


		public function getNewDomainMirrorIdRelation($source_id, $old_id) {
			$source_id = l_mysql_real_escape_string($source_id);
			$old_id = l_mysql_real_escape_string($old_id);

			$sql = "SELECT new_id FROM cms3_import_domain_mirrors WHERE old_id = '{$old_id}' AND source_id = '{$source_id}'";
			$result = l_mysql_query($sql, true);

			if(list($new_id) = mysql_fetch_row($result)) {
				return (string) $new_id;
			} else {
				return false;
			}
		}


		public function getOldDomainMirrorIdRelation($source_id, $new_id) {
			$source_id = l_mysql_real_escape_string($source_id);
			$new_id = l_mysql_real_escape_string($new_id);

			$sql = "SELECT old_id FROM cms3_import_domain_mirrors WHERE new_id = '{$new_id}' AND source_id = '{$source_id}'";
			$result = l_mysql_query($sql, true);

			if(list($old_id) = mysql_fetch_row($result)) {
				return (string) $old_id;
			} else {
				return false;
			}
		}

		public function setLangIdRelation($source_id, $old_id, $new_id) {
			$source_id = l_mysql_real_escape_string($source_id);
			$old_id = l_mysql_real_escape_string($old_id);
			$new_id = l_mysql_real_escape_string($new_id);

			$sql = "DELETE FROM cms3_import_langs WHERE source_id = '{$source_id}' AND (new_id = '{$new_id}' OR old_id = '{$old_id}')";
			l_mysql_query($sql);

			$sql = "INSERT INTO cms3_import_langs (source_id, old_id, new_id) VALUES('{$source_id}', '{$old_id}', '{$new_id}')";
			l_mysql_query($sql);

			return true;
		}


		public function getNewLangIdRelation($source_id, $old_id) {
			$source_id = l_mysql_real_escape_string($source_id);
			$old_id = l_mysql_real_escape_string($old_id);

			$sql = "SELECT new_id FROM cms3_import_langs WHERE old_id = '{$old_id}' AND source_id = '{$source_id}'";
			$result = l_mysql_query($sql, true);

			if(list($new_id) = mysql_fetch_row($result)) {
				return (string) $new_id;
			} else {
				return false;
			}
		}


		public function getOldLangIdRelation($source_id, $new_id) {
			$source_id = l_mysql_real_escape_string($source_id);
			$new_id = l_mysql_real_escape_string($new_id);

			$sql = "SELECT old_id FROM cms3_import_langs WHERE new_id = '{$new_id}' AND source_id = '{$source_id}'";
			$result = l_mysql_query($sql, true);

			if(list($old_id) = mysql_fetch_row($result)) {
				return (string) $old_id;
			} else {
				return false;
			}
		}
		public function setTemplateIdRelation($source_id, $old_id, $new_id) {
			$source_id = l_mysql_real_escape_string($source_id);
			$old_id = l_mysql_real_escape_string($old_id);
			$new_id = l_mysql_real_escape_string($new_id);

			$sql = "DELETE FROM cms3_import_templates WHERE source_id = '{$source_id}' AND (new_id = '{$new_id}' OR old_id = '{$old_id}')";
			l_mysql_query($sql);

			$sql = "INSERT INTO cms3_import_templates (source_id, old_id, new_id) VALUES('{$source_id}', '{$old_id}', '{$new_id}')";
			l_mysql_query($sql);

			return true;
		}


		public function getNewTemplateIdRelation($source_id, $old_id) {
			$source_id = l_mysql_real_escape_string($source_id);
			$old_id = l_mysql_real_escape_string($old_id);

			$sql = "SELECT new_id FROM cms3_import_templates WHERE old_id = '{$old_id}' AND source_id = '{$source_id}'";
			$result = l_mysql_query($sql, true);

			if(list($new_id) = mysql_fetch_row($result)) {
				return (string) $new_id;
			} else {
				return false;
			}
		}


		public function getOldTemplateIdRelation($source_id, $new_id) {
			$source_id = l_mysql_real_escape_string($source_id);
			$new_id = l_mysql_real_escape_string($new_id);

			$sql = "SELECT old_id FROM cms3_import_templates WHERE new_id = '{$new_id}' AND source_id = '{$source_id}'";
			$result = l_mysql_query($sql, true);

			if(list($old_id) = mysql_fetch_row($result)) {
				return (string) $old_id;
			} else {
				return false;
			}
		}

		public function setRestrictionIdRelation($source_id, $old_id, $new_id) {
			$source_id = l_mysql_real_escape_string($source_id);
			$old_id = l_mysql_real_escape_string($old_id);
			$new_id = l_mysql_real_escape_string($new_id);

			$sql = "DELETE FROM cms3_import_restrictions WHERE source_id = '{$source_id}' AND (new_id = '{$new_id}' OR old_id = '{$old_id}')";
			l_mysql_query($sql);

			$sql = "INSERT INTO cms3_import_restrictions (source_id, old_id, new_id) VALUES('{$source_id}', '{$old_id}', '{$new_id}')";
			l_mysql_query($sql);

			return true;
		}


		public function getNewRestrictionIdRelation($source_id, $old_id) {
			$source_id = l_mysql_real_escape_string($source_id);
			$old_id = l_mysql_real_escape_string($old_id);

			$sql = "SELECT new_id FROM cms3_import_restrictions WHERE old_id = '{$old_id}' AND source_id = '{$source_id}'";
			$result = l_mysql_query($sql, true);

			if(list($new_id) = mysql_fetch_row($result)) {
				return (string) $new_id;
			} else {
				return false;
			}
		}


		public function getOldRestrictionIdRelation($source_id, $new_id) {
			$source_id = l_mysql_real_escape_string($source_id);
			$new_id = l_mysql_real_escape_string($new_id);

			$sql = "SELECT old_id FROM cms3_import_restrictions WHERE new_id = '{$new_id}' AND source_id = '{$source_id}'";
			$result = l_mysql_query($sql, true);

			if(list($old_id) = mysql_fetch_row($result)) {
				return (string) $old_id;
			} else {
				return false;
			}
		}

	};


	interface iUmiImportSplitter {
		public function __construct($type);

		static public function get($className);
		public function load($file_path, $block_size = 100, $offset = 0);
		public function translate(DomDocument $doc);
		public function getXML();
		public function getDocument();
		public function getOffset();
	}


	abstract class umiImportSplitter implements iUmiImportSplitter {
		protected $offset = 0;
		protected $block_size = 10;
		protected $type = "";
		protected $file_path = false;
		protected $complete = false;
		public $ignoreParentGroups = true;
		public $autoGuideCreation = false;
		public $renameFiles = false;

		abstract protected function readDataBlock();

		final static public function get($className) {
			if($wrapper = self::loadWrapper($className)) {
				return $wrapper;
			} else {
				throw new publicException("Can't load splitter for type \"{$className}\"");
			}
		}

		public function translate(DomDocument $doc) {
			$config = mainConfiguration::getInstance();
			$style_file = CURRENT_WORKING_DIR . '/xsl/import/' . $this->type . '.xsl';
			if (!is_file($style_file)) {
				throw new publicException("Can't load translator {$style_file}");
			}

			$templater = umiTemplater::create('XSLT', $style_file);
			return $templater->parse($doc);
		}

		public function __construct($type) {
			$this->type = $type;
		}

		final static private function loadWrapper($className) {
			static $loaded = array(), $config;

			if(isset($loaded[$className])) {
				return $loaded[$className];
			}

			if(is_null($config)) {
				$config = mainConfiguration::getInstance();
			}


			$wrapperClassName = $className . 'Splitter';
			$filePath = $config->includeParam('system.kernel') . 'subsystems/import/splitters/' . $wrapperClassName . '.php';
			if(is_file($filePath) == false) {
				$loaded[$className] = false;
				throw new publicException("Can't load splitter \"{$filePath}\" for \"{$className}\" file type");
			}

			require $filePath;

			if(!class_exists($wrapperClassName)) {
				$loaded[$className] = false;
				throw new publicException("Spliter class \"{$wrapperClassName}\" not found");
			}

			$wrapper = new $wrapperClassName($className);

			if($wrapper instanceof self == false) {
				$loaded[$className] = false;
				throw new publicException("Splitter class \"{$wrapperClassName}\" should be instance of umiImportSplitter");
			}

			return $loaded[$className] = $wrapper;

		}


		public function load($file_path, $block_size = 100, $offset = 0) {
			if (!is_file($file_path)) {
				throw new publicException("File " . $file_path . " does not exists.");
			}
			$this->block_size = (int) $block_size;
			$this->offset = (int) $offset;
			$this->file_path = $file_path;
		}

		public function getIsComplete() {
			return $this->complete;
		}

		public function getXML() {
			$doc = $this->readDataBlock();
			return $doc ? $doc->saveXML() : false;
		}

		public function getDocument() {
			$doc = $this->readDataBlock();
			return $doc;
		}

		public function getOffset() {
			return $this->offset;
		}

		public function getRenameFiles() {
			return (bool) $this->renameFiles;
		}

	}



	class umiDump20Splitter extends umiImportSplitter {


		protected function __getNodeParents(DOMNode $element) {
			$parents = array();
			$parents[] = $element->nodeName;
			if (($parent = $element->parentNode) instanceof DOMElement) {
				$parents = array_merge($this->__getNodeParents($element->parentNode), $parents);
			}

			return $parents;
		}


		protected function __getNodePath(DOMNode $element) {
			return implode("/", $this->__getNodeParents($element));
		}

		protected function readDataBlock() {
			$r = new XMLReader;
			$r->open($this->file_path/*, "utf-8",  LIBXML_COMPACT ^ LIBXML_NOEMPTYTAG*/);


			// set scheme, if exists
			$config = mainConfiguration::getInstance();
			$scheme_file = $config->includeParam('system.kernel') . 'subsystems/import/schemes/' . $this->type . '.xsd';
			if (is_file($scheme_file)) {
				$r->setSchema($scheme_file);
			}

			$doc = new DomDocument("1.0", "utf-8");

			$entities = array(
				'umidump/registry/key',
				'umidump/files/file',
				'umidump/directories/directory',
				'umidump/langs/lang',
				'umidump/domains/domain',
				'umidump/templates/template',
				'umidump/datatypes/datatype',
				'umidump/types/type',
				'umidump/pages/page',
				'umidump/objects/object',
				'umidump/relations/relation',
				'umidump/options/entity',
				'umidump/restrictions/restriction',
				'umidump/permissions/permission',
				'umidump/hierarchy/relation'
			);

			$collected = 0;
			$position = 0;
			$container = $doc;
			$continue = $r->read();


			while ($continue && $collected <= $this->block_size) {
				switch ($r->nodeType) {
					case XMLReader::ELEMENT: {
						$node_path = $this->__getNodePath($container);
						if (in_array($node_path . "/" . $r->name, $entities)) {
							if ($position++ < $this->offset) {
								$continue = $r->next(); continue(2);
							}
							if (($collected + 1) > $this->block_size) break(2);
							$collected++;
						}

						$el = $doc->createElement($r->name, $r->value);
						$container->appendChild($el);
						if (!$r->isEmptyElement) {
							$container = $el;
						}

						// create attributes
						if ($r->attributeCount) {
							while ($r->moveToNextAttribute()) {
								$attr = $doc->createAttribute($r->name);
								$attr->appendChild($doc->createTextNode($r->value));
								$el->appendChild($attr);
							}
						}
					} break;

					case XMLReader::END_ELEMENT: {
						$container = $container->parentNode;
					} break;

					case XMLReader::ATTRIBUTE: {
						$attr = $doc->createAttribute($r->name);
						$attr->appendChild($doc->createTextNode($r->value));
						$container->appendChild($attr);
					} break;

					case XMLReader::TEXT: {
						$txt =  $doc->createTextNode($r->value);
						$container->appendChild($txt);
					} break;

					case XMLReader::CDATA: {
						$cdata =  $doc->createCDATASection($r->value);
						$container->appendChild($cdata);
					} break;

					case XMLReader::NONE:
					default:

				}

				$continue = $r->read();
			}

			$this->offset += $collected;

			if (!$continue) $this->complete = true;

			return $doc;
		}

		public function translate(DomDocument $doc) {
			// do nothing
			return $doc->saveXML();
		}

	}



	if (!class_exists("umiDump20Splitter")) include_once(dirname(__FILE__) . "/umiDump20Splitter.php");

	class transferSplitter extends umiDump20Splitter{

		protected function readDataBlock() {

			$doc = parent::readDataBlock();

			if ($doc->getElementsByTagName('domains')->length) {
				$domains = $doc->getElementsByTagName('domains')->item(0);
				if ($domains->getElementsByTagName('domain')->length) {
					$domain = $domains->getElementsByTagName('domain')->item(0);

					$newDomain = false;
					$domainId = false;
					$importId = getRequest('param0');
					if ($importId) {
						$elements = umiObjectsCollection::getInstance()->getObject($importId)->elements;
						if (is_array($elements) && count($elements)) {
							$domainId = $elements[0]->getDomainId();
						}
					}

					if ($domainId) {
						$newDomain = domainsCollection::getInstance()->getDomain($domainId);
					} else {
						$newDomain = domainsCollection::getInstance()->getDefaultDomain();
					}
					if ($newDomain instanceof domain) {
					$newHost = $newDomain->getHost();
					$domain->setAttribute('host', $newHost);
				}
			}
			}

			return $doc;

		}
	}


	class baseModuleAdmin {
		protected	$dataTypes = array('list', 'message', 'form'),
				$actionTypes = array('modify', 'create', 'view');


		public function setDataRange($limit, $offset = 0) {
			$this->limit = (int) $limit;
			$this->offset = (int) $offset;
		}

		public function setDataRangeByPerPage($per_page, $curr_page = 0) {
			$this->setDataRange($per_page, $curr_page * $per_page);
		}


		public function setDataType($dataType) {
			$this->limit = false;
			$this->offset = false;

			$this->dataType = $dataType;
		}


		public function setActionType($actionType) {
			$this->actionType = $actionType;
		}


		public function setData($data, $total = false) {
			$this->total = $total;
			$this->data = $data;
		}


		public function doData() {
			$dataSet = array();
			$dataSet['attribute:type'] = $this->dataType;
			$dataSet['attribute:action'] = $this->actionType;

			if($this->total) {
				$dataSet['attribute:total'] = $this->total;

				if(!is_null($this->offset)) {
					$dataSet['attribute:offset'] = $this->offset;
				}

				if(!is_null($this->limit)) {
					$dataSet['attribute:limit'] = $this->limit;
				}
			}

			$dataSet = array_merge($dataSet, $this->data);

			cmsController::getInstance()->setAdminDataSet($dataSet);
		}


		public function prepareData($inputData, $type) {
			$data = array();

			$this->requireSlashEnding();

			switch($type) {
				case "page": {
					$data = $this->prepareDataPage($inputData);
					break;
				}


				case "pages": {
					$data = $this->prepareDataPages($inputData);
					break;
				}


				case "object": {
					$data = $this->prepareDataObject($inputData);
					break;
				}


				case "objects": {
					$data = $this->prepareDataObjects($inputData);
					break;
				}

				case "type": {
					$data = $this->prepareDataType($inputData);
					break;
				}

				case "field": {
					$data = $this->prepareDataField($inputData);
					break;
				}

				case "group": {
					$data = $this->prepareDataGroup($inputData);
					break;
				}

				case "types": {
					$data = $this->prepareDataTypes($inputData);
					break;
				}

				case "hierarchy_types": {
					$data = $this->prepareDataHierarchyTypes($inputData);
					break;
				}


				case "domains": {
					$data = $this->prepareDataDomains($inputData);
					break;
				}

				case "domain_mirrows": {
					$data = $this->prepareDataDomainMirrows($inputData);
					break;
				}


				case "templates": {
					$data = $this->prepareDataTemplates($inputData);
					break;
				}

				case "template": {
					$data = $this->prepareDataTemplate($inputData);
					break;
				}


				case "settings": {
					$data = $this->prepareDataSettings($inputData);
					break;
				}

				case "modules": {
					$data = $this->prepareDataModules($inputData);
					break;
				}


				case "langs": {
					$data = $this->prepareDataLangs($inputData);
					break;
				}



				default: {
					throw new coreException("Data type \"{$type}\" is unknown.");
				}
			}

			return $data;
		}


		public function prepareDataPage($inputData) {
			$element = getArrayKey($inputData, "element");
			$oUsersMdl = cmsController::getInstance()->getModule("users");
			if ($this->systemIsLocked($element, $oUsersMdl->user_id)){
				throw new wrongElementTypeAdminException(getLabel("error-element-locked"));
			}
			$oEventPoint = new umiEventPoint("sysytemBeginPageEdit");



			$oEventPoint->setMode("before");
			$oEventPoint->setParam("user_id", $oUsersMdl->user_id);
			$oEventPoint->setParam("lock_time", time());

			$oEventPoint->addRef("element", $element);

			$oEventPoint->call();
			$data = array();

			$cmsController = cmsController::getInstance();
			$dataModule = $cmsController->getModule("data");

			$page = array();
			if($this->actionType == "create") {
				$module = get_class($this);
				if(getArrayKey($inputData, 'module')) $module = getArrayKey($inputData, 'module');

				if($this->checkAllowedElementType($inputData) == false) {
						throw new wrongElementTypeAdminException(getLabel("error-unexpected-element-type"));
				}

				$method = $inputData['type'];
				if($method == "page" && $module == "content") {
					$method = "";
				}

				if(is_numeric($method)) {
					$base_type_id = $type_id = $method;
				} else {
					$base_type_id = $type_id = umiObjectTypesCollection::getInstance()->getBaseType($module, $method);
				}

				$parent = $inputData['parent'];
				$methodTemplateId = templatesCollection::getInstance()->getHierarchyTypeTemplate($module, $method);
				if($parent instanceof iUmiHierarchyElement) {
					$parent_id = $parent->getId();

					$this->checkDomainPermissions($parent->getDomainId());
					$this->checkElementPermissions($parent_id);

					$cmsController->currentEditElementId = $parent_id;

					$dominant_type_id = umiHierarchy::getInstance()->getDominantTypeId($parent_id);
					if($dominant_type_id) {
						$type_id = $dominant_type_id;
					}


					if($methodTemplateId !== false) {
						$tpl_id = $methodTemplateId;
					} else {
						$dominant_tpl_id = umiHierarchy::getInstance()->getDominantTplId($parent_id);
						if($dominant_tpl_id) {
							$tpl_id = $dominant_tpl_id;
						}
					}
				} else {
					$parent_id = 0;

					$this->checkDomainPermissions();

					$dominant_type_id = umiHierarchy::getInstance()->getDominantTypeId(0);
					if($dominant_type_id) {
						$type_id = $dominant_type_id;
					}

					$lang_id = $cmsController->getCurrentLang()->getId();
					$domain_id = $cmsController->getCurrentDomain()->getId();

					if($floated_domain_id = $this->getFloatedDomain()) {
						$domain_id = $floated_domain_id;
					}

					if($methodTemplateId !== false) {
						$tpl_id = $methodTemplateId;
					} else {
						$default_template = templatesCollection::getInstance()->getDefaultTemplate($domain_id, $lang_id);
						if($default_template instanceof iTemplate) {
							$tpl_id = $default_template->getId();
						} else {
							throw new publicAdminException(getLabel('error-require-default-template'));
						}
					}
				}

				if($this->compareObjectTypeByHierarchy($module, $method, $type_id) == false) {
					$type_id = $base_type_id;
				}

				if(isset($inputData['type_id'])) {
					$type_id = $inputData['type_id'];
				} elseif(isset($inputData['type-id'])) {
					$type_id = $inputData['type-id'];
				}

				if($type_id > 0) {
					$page['attribute:name'] = "";
					$page['attribute:parentId'] = $parent_id;
					$page['attribute:type-id'] = $type_id;
					$page['attribute:tpl-id'] = $tpl_id;
					$page['attribute:active'] = "active";

					$page['basetype'] = umiHierarchyTypesCollection::getInstance()->getTypeByName($module, $method);
					$page['properties'] = $dataModule->getCreateForm($type_id, false, false, true);
				} else {
					throw new coreException("Give me a normal type to create ;)");
				}

				if($module == 'content' && $method == '') {
					$page['attribute:visible'] = 'visible';
				}
			} else if ($this->actionType == "modify") {
				if($inputData instanceof umiHierarchyElement) {
					$element = $inputData;
				} else if (is_array($inputData)){
					$element = $inputData['element'];
				} else {
					throw new coreException("Unknown type of input data");
				}

				if($this->checkAllowedElementType($inputData) == false) {
					throw new wrongElementTypeAdminException(getLabel("error-unexpected-element-type"));
				}

				$this->checkDomainPermissions($element->getDomainId());
				$this->checkElementPermissions($element->getId());

				$cmsController->currentEditElementId = $element->getId();

				$umiHierarchy = umiHierarchy::getInstance();

				$pageDomainId = $element->getDomainId();
				$pageCopies = array();
				$copies = $umiHierarchy->getObjectInstances($element->getObjectId(), true, true, true);
				foreach($copies as $copyId) {
					$parents = $umiHierarchy->getAllParents($copyId);
					$copy = $umiHierarchy->getElement($copyId);
					$copyDomainId = $copy->getDomainId();
					$copyDomainName = domainsCollection::getInstance()->getDomain($copyDomainId)->getHost();

					$treeStateLink = '{0}';
					foreach($parents as $key => $parentId) {
						if($parentId == 0) {
							if ($pageDomainId != $copyDomainId) {
								$module = 'content';
								$method = 'sitetree';
								$settingsKey = 'tree-content-sitetree-' . $copyDomainId;
								$parents[$key] = array(
									'attribute:id' => $copyDomainId,
									'attribute:parentId' => $copyDomainId,
									'attribute:name' => $copyDomainName,
									'attribute:treeLink' => $treeStateLink,
									'attribute:module' => $module,
									'attribute:method' => $method,
									'attribute:settingsKey' => $settingsKey,
									);
							} else {
								unset($parents[$key]);
							}
							continue;
						}
						$parentPage = $umiHierarchy->getElement($parentId);
						$treeStateLink .= '{'.$parentPage->getId().'}';

						$module = $parentPage->getHierarchyType()->getModule();
						$method = regedit::getInstance()->getVal('//modules/' . $module . '/default_method_admin');
						$settingsKey = 'tree-' . $module . '-' . $method;
						if ($module == 'content') {
							$settingsKey .= '-' . $copyDomainId;
						}

						$parents[$key] = array(
							'attribute:id' => $parentPage->getId(),
							'attribute:parentId' => $parentPage->getParentId(),
							'attribute:name' => $parentPage->getName(),
							'attribute:treeLink' => $treeStateLink,
							'attribute:module' => $module,
							'attribute:method' => $method,
							'attribute:settingsKey' => $settingsKey,
							);
					}

					$editLink = false;

					if($moduleInstance = $cmsController->getModule($copy->getModule())) {
						$links = $moduleInstance->getEditLink($copyId, $copy->getMethod());

						if(is_array($links) && $links[1]) {
							$editLink = $links[1];
						}
					}

					$pageCopy = array(
							'attribute:id' => $copyId,
							'attribute:name' => $copy->getName() . (sizeof($copies) > 1 ? getLabel('js-smc-virtual-copy') : ''),
							'attribute:edit-link' => $editLink,
							'attribute:domain' => $copyDomainName,
							'attribute:domain-id' => $copyDomainId,
							'parents' => array('nodes:item' => $parents)
						);

					if($copyId == $element->getId()) {
						array_unshift($pageCopies, $pageCopy);
					} else {
						$pageCopies[] = $pageCopy;
					}
				}
				$page['copies'] = array('nodes:copy' => $pageCopies);

				$object_id = $element->getObject()->getId();

				$page['attribute:id'] = $element->getId();
				$page['attribute:parentId'] = $element->getParentId();
				$page['attribute:object-id'] = $object_id;
				$page['attribute:guid'] = $element->getObject()->getGUID();
				$page['attribute:type-id'] = $element->getObject()->getTypeId();
				$page['attribute:type-guid'] = $element->getObject()->getTypeGUID();
				$page['attribute:alt-name'] = $element->getAltName();
				$page['attribute:tpl-id'] = $element->getTplId();


				if($element->getIsActive()) {
					$page['attribute:active'] = "active";
				}

				if($element->getIsVisible()) {
					$page['attribute:visible'] = "visible";
				}

				if($element->getIsDefault()) {
					$page['attribute:default'] = "default";
				}

				$page['basetype'] = $element->getHierarchyType();

				$page['name'] = $element->getName();

				$page['properties'] = $dataModule->getEditForm($object_id, false, false, true, true);
			}
			$data['page'] = $page;
			return $data;
		}


		public function prepareDataPages($inputData) {
			$data = array();
			$hierarchy = umiHierarchy::getInstance();
			$pages = array();
			$sz = sizeof($inputData);
			for($i = 0; $i < $sz; $i++) {
				$element = $inputData[$i];
				if(is_numeric($element)) {
					$element = $hierarchy->getElement($element, false, true);
				}

				if($element instanceof umiHierarchyElement) {
					if(getRequest('viewMode') == 'full') {
						$pages[] = array('full:' => $element);
					} else {
						$pages[] = $element;
						$hierarchy->unloadElement($element->getId());
					}
				}
			}

			$data['nodes:page'] = $pages;

			return $data;
		}


		public function prepareDataObjects($inputData) {
			$data = array();

			$objectsCollection = umiObjectsCollection::getInstance();
			$objects = array();
			$sz = sizeof($inputData);
			for($i = 0; $i < $sz; $i++) {
				$object = $inputData[$i];
				if(is_numeric($object)) {
					$object = $objectsCollection->getObject($object);
				}

				if($object instanceof umiObject) {
					if(getRequest('viewMode') == 'full') {
						$objects[] = array('full:' => $object);
					} else {
						$objects[] = $object;
						$objectsCollection->unloadObject($object->getId());
					}
				}
			}
			$data['nodes:object'] = $objects;

			return $data;
		}


		public function prepareDataObject($inputData) {
			$data = array();

			$dataModule = cmsController::getInstance()->getModule("data");

			if($this->checkAllowedElementType($inputData, true) == false) {
					throw new wrongElementTypeAdminException(getLabel("error-unexpected-element-type"));
			}


			$object = array();
			if($this->actionType == "create") {
				$typeId = false;
				$module = get_class($this);
				$method = getArrayKey($inputData, 'type');

				if($module && $method) {
					$typeId = umiObjectTypesCollection::getInstance()->getBaseType($module, $method);
				}

				if(isset($inputData['type-id'])) {
					$typeId = $inputData['type-id'];
				}

				if($typeId == false) {
					throw new publicAdminException("Object type id is required to create new object");
				}

				$object['attribute:type-id'] = $typeId;
				$object['properties'] = $dataModule->getCreateForm($typeId, false, false, true);
			} else {
				if($inputData instanceof umiObject == false) {
					if(is_object($inputData = getArrayKey($inputData, 'object')) === false) {
						throw new publicAdminException(getLabel("error-expect-object"));
					}
				}

				$object['attribute:id'] = $inputData->getId();
				$object['attribute:name'] = $inputData->getName();
				$object['attribute:guid'] = $inputData->getGUID();
				$object['attribute:type-id'] = $inputData->getTypeId();
				$object['attribute:type-guid'] = $inputData->getTypeGUID();
				$object['attribute:owner-id'] = $inputData->getOwnerId();
				$object['properties'] = $dataModule->getEditForm($inputData->getId(), false, false, true, true);
			}


			$data['object'] = $object;

			return $data;
		}


		public function prepareDataType($inputData) {
			$data = array();
			$data['full:type'] = $inputData;
			xmlTranslator::$showHiddenFieldGroups = true;
			return $data;
		}


		public function prepareDataField($inputData) {
			$data = array();

			if($this->actionType == "create") {
				$field = array();
				$field['attribute:visible'] = 'visible';
				$data['field'] = $field;
			} else {
				$data['full:field'] = $inputData;
			}
			return $data;
		}


		public function prepareDataGroup($inputData) {
			$data = array();

			if($this->actionType == "create") {
				$group_arr = array();
				$group_arr['attribute:visible'] = true;
				$data['group'] = $group_arr;
			} else {
				if($inputData instanceof umiFieldsGroup) {
					$data['group'] = $inputData;
				} else {
					throw new coreException("Expected instance of umiFieldsGroup");
				}
			}
			return $data;
		}


		public function prepareDataTypes($inputData) {
			$data = array();

			$typesCollection = umiObjectTypesCollection::getInstance();
			$types = array();
			$sz = sizeof($inputData);
			for($i = 0; $i < $sz; $i++) {
				$type_id = $inputData[$i];
				$type = $typesCollection->getType($type_id);
				if($type instanceof umiObjectType) {
					$types[] = $type;
				}
			}
			$data['nodes:type'] = $types;
			return $data;
		}


		public function prepareDataHierarchyTypes($inputData) {
			$data = array();

			$typesCollection = umiHierarchyTypesCollection::getInstance();
			$types = array();

			foreach($inputData as $item) {
				if($item instanceof iUmiHierarchyType) {
					$types[] = $item;
				} else {
					$type_id = $item;
					$type = $typesCollection->getType($type_id);

					if($type instanceof iUmiHierarchyType) {
						$types[] = $type;
					}
				}
			}
			$data['nodes:basetype'] = $types;
			return $data;
		}


		public function prepareDataDomains($inputData) {
			$data = array();

			$domains = array();
			foreach($inputData as $item) {
				$domains[] = $item;
			}
			$data['nodes:domain'] = $domains;
			return $data;
		}


		public function prepareDataDomainMirrows($inputData) {
			$data = array();

			$domains = array();
			foreach($inputData as $item) {
				$domains[] = $item;
			}
			$data['nodes:domainMirrow'] = $domains;
			return $data;
		}


		public function prepareDataTemplates($inputData) {
			$data = array();
			$domainsCollection = domainsCollection::getInstance();

			$domains = array();
			foreach($inputData as $host => $templates) {
				$domain = array();
				$domain['attribute:id'] = $domainsCollection->getDomainId($host);
				$domain['attribute:host'] = $host;
				$domain['nodes:template'] = $templates;
				$domains[] = $domain;
			}
			$data['nodes:domain'] = $domains;
			return $data;
		}


		public function prepareDataTemplate(iTemplate $template) {
			$hierarchy = umiHierarchy::getInstance();

			$data = array();
			$info = array();
			$info['attribute:id'] = $template->getId();
			$info['attribute:name'] = $template->getName();
			$info['attribute:title'] = $template->getTitle();
			$info['attribute:filename'] = $template->getFileName();
			$info['attribute:type'] = $template->getType();
			$info['attribute:lang-id'] = $template->getLangId();
			$info['attribute:domain-id'] = $template->getDomainId();

			$used_pages = $template->getUsedPages();

			$pages = array();
			foreach($used_pages as $element_info) {
				$element = $hierarchy->getElement($element_info[0]);
				if($element instanceof umiHierarchyElement) {
					$element_id = $element->getId();
					$page_arr['attribute:id'] = $element_id;
					$page_arr['xlink:href'] = "upage://" . $element_id;
					$page_arr['basetype'] = selector::get('hierarchy-type')->id($element->getTypeId());
					$page_arr['name'] = str_replace("\"", "\\\"", $element->getName());
					$pages[] = $page_arr;
				}
			}
			$info['used-pages']['nodes:page'] = $pages;
			$data['template'] = $info;
			return $data;
		}


		public function prepareDataSettings($inputData) {
			$data = array();
			$data['nodes:group'] = array();

			foreach($inputData as $group_name => $params) {
				if(!is_array($params)) {
					continue;
				}

				$group = array();
				$group['attribute:name'] = $group_name;
				$group['attribute:label'] = getLabel("group-" . $group_name);

				$options = array();
				foreach($params as $param_key => $param_value) {
					$param_name = def_module::getRealKey($param_key);
					$param_type = def_module::getRealKey($param_key, true);

					$option = array();
					$option['attribute:name'] = $param_name;
					$option['attribute:type'] = $param_type;
					$option['attribute:label'] = getLabel("option-" . $param_name);

					switch($param_type) {
						case "select": {
							$items = array();
							$value = isset($param_value['value']) ? $param_value['value'] : false;
							foreach($param_value as $item_id => $item_name) {
								if($item_id === "value") continue;

								$item_arr = array();
								$item_arr['attribute:id'] = $item_id;
								$item_arr['node:name'] = $item_name;
								$items[] = $item_arr;
							}
							$option['value'] = array("nodes:item" => $items);

							if($value !== false) {
								$option['value']['attribute:id'] = $value;
							}
							break;
						}

						case "password": {
							if($param_value) {
								$param_value = "********";
							} else {
								$param_value = "";
							}

							break;
						}

						case "symlink": {
							$hierarchy = umiHierarchy::getInstance();

							$param_value = @unserialize($param_value);
							if(!is_array($param_value)) {
								$param_value = array();
							}
							$items = array();
							foreach($param_value as $item_id) {
								$item = $hierarchy->getElement($item_id);
								if($item instanceof umiHierarchyElement == false) {
									continue;
								}

								$item_arr = array();
								$item_arr['attribute:id'] = $item_id;
								$item_arr['node:name'] = $item->getName();
								$items[] = $item_arr;
							}
							$option['value'] = array('nodes:item' => $items);
							break;
						}

						default: {
							$option['value'] = $param_value;
							break;
						}
					}

					$options[] = $option;
				}

				$group['nodes:option'] = $options;
				$data['nodes:group'][] = $group;
			}
			return $data;
		}


		public function prepareDataModules($inputData) {
			$data = array();
			$modules = array_values($inputData);

			$items = array();
			foreach($modules as $module_name) {
				$item_arr = array();
				$item_arr['attribute:label'] = getLabel('module-' . $module_name);
				$item_arr['node:module'] = $module_name;
				$items[] = $item_arr;
			}

			$data['nodes:module'] = $items;
			return $data;
		}


		public function prepareDataLangs($inputData) {
			$data = array();

			$langs = array();

			foreach($inputData as $lang) {
				$lang_arr = array();
				$lang_arr['attribute:id'] = $lang->getId();
				$lang_arr['attribute:title'] = $lang->getTitle();
				$lang_arr['attribute:prefix'] = $lang->getPrefix();
				$langs[] = $lang_arr;
			}

			$data['nodes:lang'] = $langs;
			return $data;
		}


		public function expectParams($params) {
			foreach($params as $group_key => $group) {
				foreach($group as $param_key => $param) {
					$param_name = def_module::getRealKey($param_key);
					$param_type = def_module::getRealKey($param_key, true);

					$params[$group_key][$param_key] = $this->getExpectedParam($param_name, $param_type, $param);
				}
			}
			return $params;
		}


		public function getExpectedParam($param_name, $param_type, $param = NULL) {
			global $_FILES;

			$value = getRequest($param_name);

			if($param_type == "status") {
				return NULL;
			}

			if(is_null($value) && !in_array($param_type, array('file', 'weak_guide'))) {
				throw new requireAdminParamException("I expect value in request for param \"" . $param_name . "\"");
			}

			switch($param_type) {
				case "float": {
					return (float) $value;
				}

				case "bool":
				case "boolean":
				case "templates":
				case "guide":
				case "weak_guide":
				case "int": {
					return (int) $value;
				}

				case "password": {
					$value = ($value == "********") ? NULL : (string) $value;
					if($value) {
						try {
							$oOpenSSL = new umiOpenSSL();
							$bFilesOk = $oOpenSSL->supplyDefaultKeyFiles();
							if ($bFilesOk) {
								$value = 'umipwd_b64::' . base64_encode($oOpenSSL->encrypt($value));
							} else {
								$value = NULL;
							}
						} catch(publicException $e) {
							$value = NULL;
						}
					}
					return $value;
				}

				case "email":
				case "status":
				case "string": {
					return (string) $value;
				}

				case "symlink": {
					return serialize($value);
				}

				case "file": {

					$destination_folder = $param['destination-folder'];
					$group = isset($param['group']) ? $param['group'] : "pics";

					if($value = umiFile::upload($group, $param_name, $destination_folder)) {
						return $value;
					} else {
						$path = $destination_folder . getRequest('select_' . $param_name);
						return new umiFile($path);
					}
					break;
				}

				case "select": {
					return $value;
					break;
				}

				default: {
					throw new wrongParamException("I don't expect param \"" . $param_type . "\"");
				}
			}
		}


		public function expectElement($var, $strict = false, $byValue = false, $ignoreDeleted = false) {
			$element_id = ($byValue) ? $var : (int) getRequest($var);
			$element = umiHierarchy::getInstance()->getElement((int) $element_id, false, $ignoreDeleted);

			if($element instanceof umiHierarchyElement) {
				return $element;
			} else {
				if($strict) {
					throw new expectElementException(getLabel("error-expect-element"));
				} else {
					return false;
				}
			}
		}


		public function expectObject($var, $strict = false, $byValue = false) {
			$object_id = ($byValue) ? $var : (int) getRequest($var);
			$object = umiObjectsCollection::getInstance()->getObject((int) $object_id);

			if($object instanceof umiObject) {
				return $object;
			} else {
				if($strict) {
					throw new expectObjectException(getLabel("error-expect-object"));
				} else {
					return false;
				}
			}
		}


		public function expectElementId($var, $strict = false) {
			$element_id = (int) getRequest($var);

			if($element_id === 0 || umiHierarchy::getInstance()->isExists($element_id)) {
				return $element_id;
			} else {
				if($strict) {
					throw new expectElementException(getLabel("error-expect-element"));
				} else {
					return false;
				}
			}
		}


		public function expectObjectId($var, $strict = false) {
			$object_id = (int) getRequest($var);

			if($object_id === 0 || umiObjectsCollection::getInstance()->isExists($object_id)) {
				return $object_id;
			} else {
				if($strict) {
					throw new expectObjectException(getLabel("error-expect-object"));
				} else {
					return false;
				}
			}
		}


		public function expectObjectType($var, $strict = false) {
			$object_type_id = (int) getRequest($var);

			if($object_type_id === 0 || umiObjectTypesCollection::getInstance()->isExists($object_type_id)) {
				return umiObjectTypesCollection::getInstance()->getType($object_type_id);
			} else {
				if($strict) {
					throw new expectObjectTypeException(getLabel("error-expect-object-type"));
				} else {
					return false;
				}
			}
		}


		public function expectObjectTypeId($var, $strict = false, $byValue = false) {
			$object_type_id = (int) getRequest($var);
			if($byValue) {
				$object_type_id = $var;
			}

			$objectTypes = umiObjectTypesCollection::getInstance();
			if($object_type_id === 0 || $objectTypes->getType($object_type_id)) {
				return $object_type_id;
			} else {
				if($strict) {
					throw new expectObjectTypeException(getLabel("error-expect-object-type"));
				} else {
					return false;
				}
			}
		}


		public function saveEditedElementData($inputData) {
			if($this->checkAllowedElementType($inputData) == false) {
					throw new wrongElementTypeAdminException(getLabel("error-unexpected-element-type"));
			}

			$element = getArrayKey($inputData, "element");
			$oUsersMdl = cmsController::getInstance()->getModule("users");
			$event = new umiEventPoint("systemModifyElement");
			$event->addRef("element", $element);
			$event->addRef("inputData", $inputData);
			$event->setParam("user_id", $oUsersMdl->user_id);
			$event->setMode("before");
			$event->call();

			if($element instanceof umiHierarchyElement === false) {
				throw new expectElementException(getLabel("error-expect-element"));
			}

			$this->checkDomainPermissions($element->getDomainId());
			$this->checkElementPermissions($element->getId());

			$module_name = $element->getModule();
			$method_name = $element->getMethod();

			if(!is_null(getRequest('alt-name'))) {
				$alt_name = strlen(getRequest('alt-name')) ? getRequest('alt-name') : getRequest('name');
				$element->setAltName($alt_name);
			}

			if(!is_null($is_active = getRequest('active'))) {
				$permissions = permissionsCollection::getInstance();
				$user_id = $permissions->getUserId();
				if($permissions->isAllowedMethod($user_id, $module_name, "publish") != false) {
					$element->setIsActive($is_active);
				}
			}

			if(!is_null($is_visible = getRequest('is-visible'))) {
				$element->setIsVisible($is_visible);
			}

			if(!is_null($is_default = getRequest('is-default'))) {
				$element->setIsDefault($is_default);
			}

			if(!is_null($tpl_id = getRequest('template-id'))) {
				$element->setTplId($tpl_id);
			}

			$users = cmsController::getInstance()->getModule('users');
			if($users instanceof users) {
				$users->setPerms($element->getId());
			}

			backupModel::getInstance()->save($element->getId());

			$object = $element->getObject();
			if($object instanceof umiObject) {
				$this->saveEditedObjectData($object);
			}

			$element->commit();

			$this->currentEditedElementId = $element->getId();

			$event->setMode("after");
			$event->call();

			return $element;
		}


		public function saveAddedElementData($inputData) {
			$cmsController = cmsController::getInstance();
			$hierarchyTypes = umiHierarchyTypesCollection::getInstance();
			$objectTypes = umiObjectTypesCollection::getInstance();
			$hierarchy = umiHierarchy::getInstance();
			$templates = templatesCollection::getInstance();

			$module = get_class($this);
			if(isset($inputData['module'])) $module = $inputData['module'];
			$method = $inputData['type'];
			$parent = $inputData['parent'];

			if($this->checkAllowedElementType($inputData) == false) {
					throw new wrongElementTypeAdminException(getLabel("error-unexpected-element-type"));
			}

			if($module == "content" && $method == "page") {
				$method = "";
			}

			if($parent) {
				$this->checkElementPermissions($parent->getId(), permissionsCollection::E_CREATE_ALLOWED);
			}


			$event = new umiEventPoint("systemCreateElement");
			$event->addRef("inputData", $inputData);
			$event->setMode("before");
			$event->call();

			$methodTemplateId = $templates->getHierarchyTypeTemplate($module, $method);
			if($parent instanceof iUmiHierarchyElement) {
				$parent_id = $parent->getId();
				$lang_id = $parent->getLangId();
				$domain_id = $parent->getDomainId();

				if($methodTemplateId !== false) {
					$tpl_id = $methodTemplateId;
				} else {
					$dominant_tpl_id = umiHierarchy::getInstance()->getDominantTplId($parent_id);
					if($dominant_tpl_id) {
						$tpl_id = $dominant_tpl_id;
					} else {
						throw new coreException(getLabel('error-dominant-template-not-found'));
					}
				}
			} else {
				$parent_id = 0;
				$lang_id = $cmsController->getCurrentLang()->getId();
				$domain_id = $cmsController->getCurrentDomain()->getId();

				if($floated_domain_id = $this->getFloatedDomain()) {
					$domain_id = $floated_domain_id;
				}

				if($methodTemplateId !== false) {
					$tpl_id = $methodTemplateId;
				} else {
					$tpl_id = $templates->getDefaultTemplate()->getId();
				}
			}


			$this->checkDomainPermissions($domain_id);

			if(getRequest('template-id')) {
				$tpl_id = getRequest('template-id');
			}

			$hierarchy_type = $hierarchyTypes->getTypeByName($module, $method);
			if($hierarchy_type instanceof iUmiHierarchyType) {
				$hierarchy_type_id = $hierarchy_type->getId();
			} else {
				throw new coreException(getLabel('error-element-type-detect-failed'));
			}

			if(is_null($name = getRequest('name'))) {
				throw new coreException(getLabel('error-require-name-param'));
			}

			if(is_null($alt_name = getRequest('alt-name'))) {
				$alt_name = $name;
			}

			$type_id = getArrayKey($inputData, 'type-id');

			if(!$type_id && !($type_id = getRequest("type-id"))) {
				$type_id = $objectTypes->getBaseType($module, $method);

				if($parent instanceof iUmiHierarchyElement) {
					$dominant_type_id = $hierarchy->getDominantTypeId($parent->getId(), 1, $hierarchy_type_id);
					if($dominant_type_id) {
						$type_id = $dominant_type_id;
					}
				}
			}

			if(!$type_id) {
				throw new coreException("Base type for {$module}::{$method} doesn't exists");
			}

			$element_id = $hierarchy->addElement($parent_id, $hierarchy_type_id, $name, $alt_name, $type_id, $domain_id, $lang_id, $tpl_id);

			$users = $cmsController->getModule('users');
			if($users instanceof users) {
				backupModel::getInstance()->save($element_id);
				$users->setPerms($element_id);
			}

			$element = $hierarchy->getElement($element_id);

			if($element instanceof iUmiHierarchyElement) {
				$module_name = $element->getModule();
				$method_name = $element->getMethod();

				if(!is_null($is_active = getRequest('active'))) {
					$permissions = permissionsCollection::getInstance();
					$user_id = $permissions->getUserId();
					if($permissions->isAllowedMethod($user_id, $cmsController->getCurrentModule(), "publish") == false) {
						$is_active = false;
					}

					$element->setIsActive($is_active);
				}

				if(!is_null($is_visible = getRequest('is-visible'))) {
					$element->setIsVisible($is_visible);
				}

				if(!is_null($tpl_id = getRequest('template-id'))) {
					$element->setTplId($tpl_id);
				}

				if(!is_null($is_default = getRequest('is-default'))) {
					$element->setIsDefault($is_default);
				}

				if(!is_null($name = getRequest('name'))) {
					$element->setValue('h1', $name);
				}



				$object = $element->getObject();

				$this->saveAddedObject($object);

				$element->commit();
				$newObject = $element->getObject();
				//Set up "publish" status to new page
				if (!$newObject->getValue("publish_status")){
					$newObject->setValue("publish_status", $this->getPageStatusIdByStatusSid());
					$newObject->commit();
				}
				$event_after = new umiEventPoint("systemCreateElement");
				$event_after->addRef("element", $element);
				$event_after->setMode("after");
				$event_after->call();

				$this->currentEditedElementId = $element_id;
				return $element_id;
			} else {
				throw new coreException("Can't get created element instance");
			}
		}


		public function saveEditedObjectData($inputData) {
			if(is_array($inputData)) {
				$object = getArrayKey($inputData, 'object');
			} else {
				$object = $inputData;
			}

			if($object instanceof umiObject === false) {
				throw new coreException("Expected instance of umiObject in param");
			}

			if(is_array($inputData)) {
				$this->setRequestDataAliases(getArrayKey($inputData, 'aliases'), $object->getId());
			}

			$event = new umiEventPoint("systemModifyObject");
			$event->addRef("object", $object);
			$event->setMode("before");
			$event->call();

			if(!is_null($name = getRequest('name'))) {
				$object->setName($name);
				$object->setValue('nazvanie', $name);
			}

			if(!is_null($type_id = getRequest('type-id'))) {
				$object->setTypeId($type_id);
			}

			$dataModule = cmsController::getInstance()->getModule("data");
			$dataModule->saveEditedObject($object->getId(), false, true, true);

			$object->commit();

			$event->setMode("after");
			$event->call();

			return $object;
		}


		public function saveAddedObject(umiObject $object) {
			$event = new umiEventPoint("systemCreateObject");
			$event->addRef("object", $object);
			$event->setMode("before");
			$event->call();

			$dataModule = cmsController::getInstance()->getModule("data");
			$dataModule->saveEditedObject($object->getId(), true, true, true);

			if(!is_null($name = getRequest('name'))) {
				$object->setValue('nazvanie', $object->getName());
			}


			$object->commit();

			$event->setMode("after");
			$event->call();

			return $object->getId();
		}


		public function saveAddedObjectData($inputData) {
			$objectsCollection = umiObjectsCollection::getInstance();
			$typesCollection = umiObjectTypesCollection::getInstance();

			if($this->checkAllowedElementType($inputData, true) == false) {
				throw new wrongElementTypeAdminException(getLabel("error-unexpected-element-type"));
			}


			$this->setRequestDataAliases(getArrayKey($inputData, 'aliases'));

			if(is_null($name = getArrayKey($inputData, 'name'))) {
				$name = getRequest('name');
			}

			if(is_null($name)) {
				throw new publicAdminException("Require 'name' param in _REQUEST array.");
			}

			$module = get_class($this);
			$method = getArrayKey($inputData, 'type');
			$typeId = getArrayKey($inputData, 'type-id');

			if(!$typeId) {
				$typeId = $typesCollection->getBaseType($module, $method);
			}

			$objectId = $objectsCollection->addObject($name, $typeId);
			$object = $objectsCollection->getObject($objectId);
			if($object instanceof umiObject) {
				$this->saveAddedObject($object);
				return $object;
			} else {
				throw new coreException("Can't create object #{$objectId} \"{$name}\" of type #{$typeId}");
			}
		}


		public function saveEditedList($type, $params = false) {
			$data = getRequest("data");
			$dels = getRequest("dels");

			switch($type) {
				case "objects": {
					return $this->saveEditedObjectsList($data, $dels, $params);
				}

				case "basetypes": {
					return $this->saveEditedBaseTypesList($data, $dels);
				}

				case "domains": {
					return $this->saveEditedDomains($data, $dels);
				}

				case "domain_mirrows": {
					return $this->saveEditedDomainMirrows($data, $dels);
				}

				case "langs": {
					return $this->saveEditedLangs($data, $dels);
				}

				case "templates": {
					return $this->saveEditedTemplatesList($data, $dels, $params);
				}

				default: {
					throw new coreException("Can't save edited list of type \"{$type}\"");
				}
			}
		}


		public function saveEditedObjectsList($data, $dels, $params) {
			$collection = umiObjectsCollection::getInstance();
			$objectTypes = umiObjectTypesCollection::getInstance();
			$new_item_id = false;

			if(is_array($data)) {
				foreach($data as $id => $info) {
					$name = getArrayKey($info, 'name');
					$type_id = getArrayKey($params, 'type_id');
					$method = getArrayKey($params, 'type');
					if(!$type_id && $method) {
						$type_id = $objectTypes->getBaseType(get_class($this), $method);
					}

					if($id == "new") {
						if($name && $type_id) {
							$id = $collection->addObject($name, $type_id);
							$item = $collection->getObject($id);
							if($item instanceof umiObject) {
								$new_item_id = $this->saveAddedObject($item);
								$item->commit();
							}
						}
					} else {
						$item = $collection->getObject($id);

						if($item instanceof umiObject) {
							$item->setName($name);
							$this->saveEditedObjectData($item);
							$item->commit();
						} else {
							throw new coreException("Object #{$id} doesn't exists");
						}
					}
				}
			}

			if(is_array($dels)) {
				foreach($dels as $id) {
					$collection->delObject($id);
				}
			}

			return $new_item_id;
		}


		public function saveEditedBaseTypesList($data, $dels) {
			$collection = umiHierarchyTypesCollection::getInstance();

			if(is_array($data)) {
				foreach($data as $id => $info) {
					$title = getArrayKey($info, 'title');
					$module = getArrayKey($info, 'module');
					$method = getArrayKey($info, 'method');

					if($id == "new") {
						if($module && $title) {
							$collection->addType($module, $title, $method);
						}
					} else {
						$item = $collection->getType($id);

						if($item instanceof iUmiHierarchyType) {
							$item->setTitle($title);
							$item->setName($module);
							$item->setExt($method);
							$item->commit();
						} else {
							throw new coreException("Hierarchy type #{$id} doesn't exists");
						}
					}
				}
			}

			if(is_array($dels)) {
				foreach($dels as $id) {
					$collection->delType($id);
				}
			}
		}


		public function saveEditedTemplatesList($data, $dels, $params) {
			$collection = templatesCollection::getInstance();
			$default = getArrayKey($data, 'default');

			foreach($params as $host => $templates) {
				$domain_id = domainsCollection::getInstance()->getDomainId($host);
				$host_data = getArrayKey($data, $host);

				$default_tpl_id = getArrayKey($default, $domain_id);

				foreach($templates as $template) {
					$template_data = getArrayKey($host_data, $template->getId());

					$title = getArrayKey($template_data, 'title');
					$filename = getArrayKey($template_data, 'filename');

					if(!$title || !$filename) {
						continue;
					}

					$template->setTitle($title);
					$template->setFileName($filename);

					if(is_numeric($default_tpl_id)) {
						if($template->getId() == $default_tpl_id) {
							$template->setIsDefault(true);
						} else {
							$template->setIsDefault(false);
						}
					}

					$template->commit();
				}

				if(!is_null($template_data = getArrayKey($host_data, 'new'))) {
					$title = getArrayKey($template_data, 'title');
					$filename = getArrayKey($template_data, 'filename');

					if($title && $filename) {
						$lang_id = cmsController::getInstance()->getCurrentLang()->getId();
						$is_default = ($default_tpl_id == "new") ? true : false;
						$collection->addTemplate($filename, $title, $domain_id, $lang_id, $is_default);
					}
				}
			}

			if(is_array($dels)) {
				foreach($dels as $id) {
					$template = $collection->getTemplate($id);
					if($template->getIsDefault() == false) {
						unset($template);
						$collection->delTemplate($id);
					}
				}
			}
		}


		public function saveEditedTemplateData(iTemplate $template) {
			$name = getRequest('name');
			$title = getRequest('title');
			$filename = getRequest('filename');
			$type = getRequest('type');
			$used_pages = getRequest('used_pages');

			$template->setName($name);
			$template->setTitle($title);
			$template->setFilename($filename);
			$template->setType($type);
			$template->setUsedPages($used_pages);
			$template->commit();
		}


		public function saveEditedDomains($data, $dels) {
			$collection = domainsCollection::getInstance();

			if(is_array($data)) {
				foreach($data as $id => $info) {
					$host = getArrayKey($info, 'host');
					$lang_id = getArrayKey($info, 'lang_id');

					if($id == "new") {
						$host = domain::filterHostName($host);
						if($host && $lang_id) {
							$edition = regedit::getInstance()->getVal("//modules/autoupdate/system_edition");
							if ($edition=='gov' && count($collection->getList())>0) {
								throw new publicAdminException(getLabel('error-disabled-in-demo'));
							}

							if(defined("CURRENT_VERSION_LINE") &&
							in_array(CURRENT_VERSION_LINE, array('start', 'lite', 'shop'))) {
								throw new publicAdminException(getLabel('error-disabled-in-demo'));
							}

							if($collection->getDomainId($host)) {
								throw new publicAdminException(getLabel('error-domain-already-exists'));
							}

							$collection->addDomain($host, $lang_id);
						}
					} else {
						if(!$host) {
							$item = $collection->getDomain($id);
							$item->setDefaultLangId($lang_id);
							$item->commit();

							continue;
						}

						$item = $collection->getDomain($id);

						if($item instanceof iDomain) {
							if($item->getIsDefault() == false) {
								$item->setHost($host);
							}
							$item->setDefaultLangId($lang_id);
							$item->commit();
						} else {
							throw new coreException("Domain #{$id} doesn't exists");
						}
					}
				}
			}

			if(is_array($dels)) {
				foreach($dels as $id) {
					$collection->delDomain($id);
				}
			}
		}


		public function saveEditedDomainMirrows($data, $dels) {
			$collection = domainsCollection::getInstance();
			$domain = $collection->getDomain(getRequest('param0'));

			if(is_array($data)) {
				foreach($data as $id => $info) {
					$host = getArrayKey($info, 'host');

					if($id == "new") {
						$host = domain::filterHostName($host);
						if($host) {
							if($collection->getDomainId($host)) {
								throw new publicAdminException(getLabel('error-domain-already-exists'));
							}
							$domain->addMirrow($host);
						}
					} else {
						if(!$host) {
							continue;
						}

						$item = $domain->getMirrow($id);

						if($item instanceof iDomainMirrow) {
							$item->setHost($host);
							$item->commit();
						} else {
							throw new coreException("Domain #{$id} doesn't exists");
						}
					}
				}
			}

			if(is_array($dels)) {
				foreach($dels as $id) {
					$domain->delMirrow($id);
				}
			}

			$domain->setIsUpdated();
			$domain->commit();
		}


		public function saveEditedLangs($data, $dels) {
			$collection = langsCollection::getInstance();

			if(is_array($data)) {
				foreach($data as $id => $info) {
					$title  = getArrayKey($info, 'title');
					$prefix = getArrayKey($info, 'prefix');

					if(!strlen($title) || !strlen($prefix)) continue;

					$title  = trim($title);
					$prefix = preg_replace("/[^A-z0-9]*/", "", $prefix);

					if(!strlen($title) || !strlen($prefix)) continue;

					if($id == "new") {
						$id = $collection->addLang($prefix, $title);
					}

					$item = $collection->getLang($id);

					if($item instanceof iLang) {
						$item->setTitle($title);
						$item->setPrefix($prefix);
						$item->commit();
					} else {
						throw new coreException("Lang #{$id} doesn't exists");
					}
				}
			}
		}


		public function saveEditedTypeData($data) {
			$info = getRequest('data');

			$name = getArrayKey($info, 'name');
			$is_guidable = getArrayKey($info, 'is_guidable');
			$is_public = getArrayKey($info, 'is_public');
			$hierarchy_type_id = getArrayKey($info, 'hierarchy_type_id');

			$type = $data;
			if($type instanceof umiObjectType) {

				if (is_null($name) || $name == '') throw new coreException("Expected to get type name");
				if ($type->getHierarchyTypeId() && !$hierarchy_type_id && !$type->getIsGuidable()) throw new coreException("Expected to get hierarchy type id");

				$type->setName($name);
				$type->setIsGuidable($is_guidable);
				$type->setIsPublic($is_public);
				$type->setHierarchyTypeId($hierarchy_type_id);
				$type->commit();
			} else {
				throw new coreException("Expected instance of type umiObjectType");
			}

		}


		public function saveEditedGroupData($group) {
			$info = getRequest('data');

			$title = getArrayKey($info, 'title');
			$name = getArrayKey($info, 'name');
			$is_visible = getArrayKey($info, 'is_visible');

			if($group instanceof iUmiFieldsGroup) {
				$group->setName($name);
				$group->setTitle($title);
				$group->setIsVisible($is_visible);
				$group->setIsActive(true);
				$group->commit();
			} else {
				throw new coreException("Expected instance of type umiFieldsGroup");
			}
		}


		public function saveEditedFieldData($field) {
			$info = getRequest('data');

			$title = getArrayKey($info, 'title');
			$name = getArrayKey($info, 'name');
			$is_visible = getArrayKey($info, 'is_visible');
			$field_type_id = getArrayKey($info, 'field_type_id');
			$guide_id = getArrayKey($info, 'guide_id');
			$in_search = getArrayKey($info, 'in_search');
			$in_filter = getArrayKey($info, 'in_filter');
			$tip = getArrayKey($info, 'tip');
			$isRequired = getArrayKey($info, 'is_required');
			$restrictionId = getArrayKey($info, 'restriction_id');

			if($field instanceof umiField) {
				$field->setTitle($title);
				$field->setName($name);
				$field->setIsVisible($is_visible);
				$field->setFieldTypeId($field_type_id);
				$field->setIsInSearch($in_search);
				$field->setIsInFilter($in_filter);
				$field->setTip($tip);
				$field->setIsRequired($isRequired);
				$field->setRestrictionId($restrictionId);

				//Choose or create public guide for unlinked relation field
				$field_type_obj = umiFieldTypesCollection::getInstance()->getFieldType($field_type_id);
				$field_data_type = $field_type_obj->getDataType();

				if($field_data_type == "relation" && $guide_id == 0) {
					$guide_id = self::getAutoGuideId($title);
				}

				if($field_data_type == "optioned" && $guide_id == 0) {
					$parent_guide_id = umiObjectTypesCollection::getInstance()->getTypeIdByGUID('emarket-itemoption');
					$guide_id = self::getAutoGuideId($title, $parent_guide_id);
				}

				$field->setGuideId($guide_id);

				$field->commit();
			} else {
				throw new coreException("Expected instance of type umiField");
			}
		}


		public function saveAddedGroupData($inputData) {
			$info = getRequest('data');

			$name = getArrayKey($info, 'name');
			$title = getArrayKey($info, 'title');
			$is_visible = getArrayKey($info, 'is_visible');

			$type_id = getArrayKey($inputData, 'type-id');
			$type = umiObjectTypesCollection::getInstance()->getType($type_id);

			if($type instanceof umiObjectType) {
				$fields_group_id = $type->addFieldsGroup($name, $title, true, $is_visible);
				$type->commit();
				return $fields_group_id;
			} else {
				throw new coreException("Expected instance of type umiObjectType");
			}
		}


		public function saveAddedFieldData($inputData) {

			$group_id = $inputData['group-id'];
			$type_id = $inputData['type-id'];

			$info = getRequest('data');

			$title = getArrayKey($info, 'title');
			$name = getArrayKey($info, 'name');
			$is_visible = getArrayKey($info, 'is_visible');
			$field_type_id = getArrayKey($info, 'field_type_id');
			$guide_id = getArrayKey($info, 'guide_id');
			$in_search = getArrayKey($info, 'in_search');
			$in_filter = getArrayKey($info, 'in_filter');
			$tip = getArrayKey($info, 'tip');
			$isRequired = getArrayKey($info, 'is_required');
			$restrictionId = getArrayKey($info, 'restriction_id');

			$objectTypes = umiObjectTypesCollection::getInstance();
			$fields = umiFieldsCollection::getInstance();
			$fieldTypes = umiFieldTypesCollection::getInstance();

			//Check for non-unique field name
			$type = $objectTypes->getType($type_id);
			if($type instanceof umiObjectType) {
				if($type->getFieldId($name)) {
					throw new publicAdminException(getLabel('error-non-unique-field-name'));
				}
			}

			$field_type_obj = $fieldTypes->getFieldType($field_type_id);
			$field_data_type = $field_type_obj->getDataType();

			if($field_data_type == "relation" && $guide_id == 0) {
				$guide_id = self::getAutoGuideId($title);
			}

			if($field_data_type == "optioned" && $guide_id == 0) {
				$parent_guide_id = $objectTypes->getTypeIdByGUID('emarket-itemoption');
				$guide_id = self::getAutoGuideId($title, $parent_guide_id);
			}

			//Ищем аналог в горизонтальной иерархии
			$field_id = false;
			$parentTypeId = $type->getParentId();
			$horisontalTypes = $objectTypes->getSubTypesList($parentTypeId);
			foreach($horisontalTypes as $horisontalTypeId) {
				if($horisontalTypeId == $type_id) continue;
				$horisontalType = $objectTypes->getType($horisontalTypeId);
				if($horisontalType instanceof umiObjectType == false) continue;

				if($horisontalFieldId = $horisontalType->getFieldId($name)) {
					$horisontalField = $fields->getField($horisontalFieldId);
					if($horisontalField instanceof umiField == false) continue;
					if(($horisontalField->getFieldTypeId() == $field_type_id) && ($horisontalField->getTitle() == $title)) {
						$field_id = $horisontalFieldId;
						break;
					}
				}
			}

			//Ищем аналоги в вертикальной иерархии
			$verticalTypes = $objectTypes->getSubTypesList($type_id);
			foreach($verticalTypes as $verticalTypeId) {
				$verticalType = $objectTypes->getType($verticalTypeId);
				if($verticalType instanceof umiObjectType == false) continue;

				if($verticalFieldId = $verticalType->getFieldId($name)) {
					$verticalField = $fields->getField($verticalFieldId);
					if($verticalField instanceof umiField == false) continue;
					if(($verticalField->getFieldTypeId() == $field_type_id) && ($verticalField->getTitle() == $title)) {
						$field_id = $verticalFieldId;
						break;
					}
				}
			}

			if($field_id === false) {
				//Содаем новое поле, если не нашли в вертикальной и горизонтальной иерархии аналогов
				$field_id = $fields->addField($name, $title, $field_type_id, $is_visible, false, false);

				$field = $fields->getField($field_id);
				$field->setGuideId($guide_id);
				$field->setIsInSearch($in_search);
				$field->setIsInFilter($in_filter);
				$field->setTip($tip);
				$field->setIsRequired($isRequired);
				$field->setRestrictionId($restrictionId);
				$field->commit();
			}

			if($type instanceof umiObjectType) {
				$group = $type->getFieldsGroup($group_id);
				if($group instanceof umiFieldsGroup) {
					$group->attachField($field_id);
					$group_name = $group->getName();

					$childs = $objectTypes->getChildClasses($type_id);
					$sz = sizeof($childs);

					for($i = 0; $i < $sz; $i++) {
						$child_type_id = $childs[$i];
						$child_type = $objectTypes->getType($child_type_id);

						if($child_type instanceof umiObjectType) {

							if($child_type->getFieldId($name) == $field_id) continue;

							$child_group = $child_type->getFieldsGroupByName($group_name);
							if($child_group instanceof umiFieldsGroup) {
								$child_group->attachField($field_id, true);
							} else {
								throw new coreException("Can't find umiFieldsGroup #{$group_name} in umiObjectType #{$child_type_id}");
							}
						} else {
							throw new coreException("Can't find umiObjectType #{$child_type_id}");
						}
					}
					return $field_id;
				} else {
					throw new coreException("Can't find umiFieldsGroup #{$group_id}");
				}
			} else {
				throw new coreException("Can't find umiObjectType #{$type_id}");
			}
		}


		public function chooseRedirect($redirect_string = false) {
			$cmsController = cmsController::getInstance();
			$hierarchy = umiHierarchy::getInstance();
			$referer_uri = $cmsController->getCalculatedRefererUri();

			$save_mode_str = getRequest('save-mode');

			switch($save_mode_str) {
				case getLabel('label-save-exit'):
				case getLabel('label-save-add-exit'): {
					$save_mode = 1;
					break;
				}

				case getLabel('label-save-view'):
				case getLabel('label-save-add-view'): {
					$save_mode = 2;
					break;
				}

				case getLabel('label-save'):
				case getLabel('label-save-add'): {
					$save_mode = 3;
					break;
				}

				default: {
					$save_mode = false;
				}
			}

			if($forceRedirectUrl = getArrayKey($_GET, 'force-redirect')) {
				$this->redirect($forceRedirectUrl);
			}

			if($save_mode == 1) {
				$this->redirect($referer_uri);
			}

			if($save_mode == 2) {
				$element_id = $this->currentEditedElementId;
				if($element_id) {
					$element_path = $hierarchy->getPathById($element_id);
					$this->redirect($element_path);
				}
			}

			if($redirect_string !== false) {
				$this->redirect($redirect_string);
			}

			if($save_mode && $element_id = $this->currentEditedElementId) {
				$element = $hierarchy->getElement($element_id);

				if($element instanceof umiHierarchyElement) {
					$element_module = $element->getHierarchyType()->getName();
					$element_method = $element->getHierarchyType()->getExt();
					$module = cmsController::getInstance()->getModule($element_module);

					if($module instanceof def_module) {
						$links = $module->getEditLink($element_id, $element_method);
						$edit_link = isset($links[1]) ? $links[1] : false;

						if($edit_link) {
							$this->redirect($edit_link);
						}
					}
				}
			}
			$request_uri = $this->removeErrorParam(getServer('HTTP_REFERER'));
			outputBuffer::current()->redirect($request_uri);
		}


		public function checkAllowedElementType($inputData, $ignoreIfNull = true) {
			$element = getArrayKey($inputData, 'element');
			$object = getArrayKey($inputData, 'object');
			$type = getArrayKey($inputData, 'type');
			$allowed_types = getArrayKey($inputData, 'allowed-element-types');

			$commentsHierarchyType = umiHierarchyTypesCollection::getInstance()->getTypeByName("comments", "comment");
			if($commentsHierarchyType) {
				$commentsHierarchyTypeId = $commentsHierarchyType->getId();
			} else {
				$commentsHierarchyTypeId = false;
			}

			if(is_array($allowed_types) === false) {
				if($ignoreIfNull === false) {
					throw new coreException("Allowed types expected to be array");
				} else {
					return true;
				}
			}


			if($type) {
				if(in_array($type, $allowed_types)) {
					return true;
				} else {
					return false;
				}
			}

			if($element instanceof umiHierarchyElement === true) {
				$hierarchy_type_id = $element->getTypeId();
			} else if($object instanceof umiObject === true) {
				$object_type_id = $object->getTypeId();
				$object_type = umiObjectTypesCollection::getInstance()->getType($object_type_id);
				$hierarchy_type_id = $object_type->getHierarchyTypeId();
			} else {
				throw new coreException("If you are doing 'add' method, you should pass me 'type' key in 'inputData' array. If you have 'edit' method, pass me 'element' key in 'inputData' array.");
			}

			$hierarchy_type = umiHierarchyTypesCollection::getInstance()->getType($hierarchy_type_id);

			if($hierarchy_type instanceof iUmiHierarchyType) {
				$method = $hierarchy_type->getExt();
				if(in_array($method, $allowed_types) || $hierarchy_type->getId() == $commentsHierarchyTypeId) {
					return true;
				} else {
					return false;
				}
			} else {
				throw new coreException("This should never happen");
			}
		}


		public function checkElementPermissions($element_id, $requiredPermission = permissionsCollection::E_EDIT_ALLOWED) {
			static $permissions = NULL, $user_id = NULL;
			if(is_null($permissions)) {
				$permissions = permissionsCollection::getInstance();
				$user_id = $permissions->getUserId();
			}

			$allow = $permissions->isAllowedObject($user_id, $element_id);

			if(!isset($allow[$requiredPermission]) || $allow[$requiredPermission] == false) {
				throw new requreMoreAdminPermissionsException(getLabel("error-require-more-permissions"));
			} else {
				return true;
			}
		}


		public function switchActivity($params) {
			if($this->checkAllowedElementType($params) == false) {
				throw new wrongElementTypeAdminException(getLabel("error-unexpected-element-type"));
			}

			$element = getArrayKey($params, 'element');
			$activity = getArrayKey($params, 'activity');

			if($element instanceof umiHierarchyElement === false) {
				throw new expectElementException(getLabel('error-expect-element'));
			}

			$this->checkElementPermissions($element->getId());

			if(is_null($activity)) {
				$activity = !$element->getIsActive();
			}

			$module_name = $element->getModule();
			$method_name = $element->getMethod();

			$permissions = permissionsCollection::getInstance();
			$user_id = $permissions->getUserId();
			if($permissions->isAllowedMethod($user_id, $module_name, "publish") == false) {
				throw new requreMoreAdminPermissionsException(getLabel('error-no-publication-permissions'));
			}

			if($activity == $element->getIsActive()) {	//Don't raise event, if no modifications planned
				return $activity;
			}

			$event = new umiEventPoint("systemSwitchElementActivity");
			$event->addRef("element", $element);
			$event->setParam("activity", $activity);
			$event->setMode("before");

			try {
				$event->call();
			} catch (coreBreakEventsException $e) {
				return $element->getIsActive();
			}

			$element->setIsActive($activity);
			$element->commit();

			$event->setMode("after");

			try {
				$event->call();
			} catch (coreBreakEventsException $e) {
				return $element->getIsActive();
			}

			return $element->getIsActive();
		}


		public function moveElement($params) {
			if($this->checkAllowedElementType($params) == false) {
				throw new wrongElementTypeAdminException(getLabel("error-unexpected-element-type"));
			}
			$hierarchy = umiHierarchy::getInstance();
			$domains = domainsCollection::getInstance();

			$element = getArrayKey($params, 'element');
			$parentId = getArrayKey($params, 'parent-id');
			$domainId = getArrayKey($params, 'domain');


			$asSibling = getArrayKey($params, 'as-sibling');
			$beforeId = getArrayKey($params, 'before-id');

			$this->checkElementPermissions($element->getId(), permissionsCollection::E_MOVE_ALLOWED);

			$event = new umiEventPoint("systemMoveElement");
			$event->addRef("element", $element);
			$event->setParam("parent-id", $parentId);
			$event->setParam("domain-host", $domainId);
			$event->setParam("as-sibling", $asSibling);
			$event->setParam("before-id", $beforeId);
			$event->setMode("before");

			try {
				$event->call();
			} catch (coreBreakEventsException $e) {
				return false;
			}

			if(is_numeric($domainId) == false)
				$domainId = $domains->getDomainId($domainId);

			$oldParentId = $element->getParentId();

			if ($domainId) {
				$element->setDomainId($domainId);
			}
			$element->commit();

			if ($asSibling) {
				$hierarchy->moveBefore($element->getId(), $parentId, (($beforeId) ? $beforeId : false));
			} else {
				$hierarchy->moveFirst($element->getId(), $parentId);
			}
			$element->update();
			$element->setIsUpdated();
			$element->commit();
			$event->setMode("after");
			try {
				$event->call();
				return true;
			} catch (coreBreakEventsException $e) {
				return false;
			}
		}


		public function deleteElement($params) {
			$element = getArrayKey($params, 'element');

			if($element instanceof umiHierarchyElement === false) {
				throw new expectElementException(getLabel('error-expect-element'));
			}

			if($this->checkAllowedElementType($params) == false) {
				throw new wrongElementTypeAdminException(getLabel("error-unexpected-element-type"));
			}

			$this->checkElementPermissions($element->getId(), permissionsCollection::E_DELETE_ALLOWED);

			$event = new umiEventPoint("systemDeleteElement");
			$event->addRef("element", $element);
			$event->setMode("before");
			$event->call();

			umiHierarchy::getInstance()->delElement($element->getId());

			$event->setMode("after");
			$event->call();
		}


		public function deleteObject($params) {
			$objectsCollection = umiObjectsCollection::getInstance();
			$objectTypesCollection = umiObjectTypesCollection::getInstance();
			$hierarchyTypesCollection = umiHierarchyTypesCollection::getInstance();

			$object = getArrayKey($params, 'object');
			if($object instanceof umiObject == false) {
				throw new coreException("You should pass \"object\" key containing umiObject instance.");
			}
			$object_id = $object->getId();

			$object_type_id = $object->getTypeId();
			$object_type = $objectTypesCollection->getType($object_type_id);

			if($object_type instanceof umiObjectType == false) {
				throw new coreException("Object #{$object_id} hasn't type #{$object_type_id}. This should not happen.");
			}

			if(!is_null(getArrayKey($params, 'type'))) {
				$hierarchy_type_id = $object_type->getHierarchyTypeId();
				$hierarchy_type = $hierarchyTypesCollection->getType($hierarchy_type_id);
				if($hierarchy_type instanceof iUmiHierarchyType == false) {
					throw new coreException("Object type #{$object_type_id} doesn't have hierarchy type #{$hierarchy_type_id}. This should not happen.");
				}
				$params['type'] = $hierarchy_type->getExt();

				if($this->checkAllowedElementType($params) == false) {
					throw new wrongElementTypeAdminException(getLabel("error-unexpected-element-type"));
				}
			}

			$event = new umiEventPoint("systemDeleteObject");
			$event->addRef("object", $object);
			$event->setMode("before");
			$event->call();

			$result = $objectsCollection->delObject($object_id);

			$event->setMode("after");
			$event->call();

			return $result;
		}


		public function getFloatedDomain() {
			if(!is_null($domain_floated = getRequest('domain'))) {
				$domain_floated_id = domainsCollection::getInstance()->getDomainId($domain_floated);
				if($domain_floated_id) {
					return $domain_floated_id;
				}
			}
			return false;
		}


		public static function getAutoGuideId($title, $baseGuideId = false) {
			$objectTypesCollection = umiObjectTypesCollection::getInstance();
			if(!$baseGuideId) $baseGuideId = $objectTypesCollection->getTypeIdByGUID('root-guides-type');
			$guide_name = getLabel('autoguide-for-field') . " \"{$title}\"";

			$child_types = $objectTypesCollection->getChildClasses($baseGuideId);
			foreach($child_types as $child_type_id) {
				$child_type = $objectTypesCollection->getType($child_type_id);
				$child_type_name = $child_type->getName();

				if($child_type_name == $guide_name) {
					$child_type->setIsGuidable(true);
					return $child_type_id;
				}
			}

			$guide_id = $objectTypesCollection->addType($baseGuideId, $guide_name);
			$guide = $objectTypesCollection->getType($guide_id);
			$guide->setIsGuidable(true);
			$guide->setIsPublic(true);
			$guide->commit();

			return $guide_id;
		}


		public function checkDomainPermissions($domain_id = false) {
			$permissions = permissionsCollection::getInstance();
			$domains = domainsCollection::getInstance();
			$cmsController = cmsController::getInstance();

			if($domain_id == false) {
				if(!is_null($domain_host = getRequest('domain'))) {
					$domain_id = $domains->getDomainId($domain_host);
				} else {
					$domain_id = $cmsController->getCurrentDomain()->getId();
				}
			}

			if(!$domain_id) {
				throw new coreException("Require domain id to check domain permissions");
			}

			$user_id = $permissions->getUserId();
			$is_allowed = $permissions->isAllowedDomain($user_id, $domain_id);

			if($is_allowed == 0) {
				throw new requreMoreAdminPermissionsException(getLabel('error-no-domain-permissions'));
			} else {
				return NULL;
			}
		}


		public function setRequestDataAlias($key1, $key2) {
			if(isset($_REQUEST[$key2])) {
				$_REQUEST[$key1] = &$_REQUEST[$key2];
				return true;
			} else {
				return false;
			}
		}


		public function setRequestDataAliases($aliases, $id = "new") {
			if(!is_array($aliases)) {
				return false;
			}

			foreach($aliases as $key1 => $key2) {
				if(isset($_REQUEST['data'][$id][$key2])) {
					$_REQUEST[$key1] = &$_REQUEST['data'][$id][$key2];
				}

			}
		}

		public function compareObjectTypeByHierarchy($module, $method, $type_id) {
			$typesCollection = umiObjectTypesCollection::getInstance();
			$hierarchyTypesCollection = umiHierarchyTypesCollection::getInstance();

			$type = $typesCollection->getType($type_id);
			$hierarchy_type = $hierarchyTypesCollection->getTypeByName($module, $method);

			if($type instanceof umiObjectType && $hierarchy_type instanceof umiHierarchyType) {
				return $type->getHierarchyTypeId() == $hierarchy_type->getId();
			} else {
				return false;
			}
		}
		public function systemIsLocked($element, $user_id){
			if ($element){
				$oPage = $element->getObject();
				$lockTime = $oPage->getValue("locktime");
				$lockUser = $oPage->getValue("lockuser");
				if ($lockTime == null || $lockUser == null){
					return false;
				}
				$lockDuration = regedit::getInstance()->getVal("//settings/lock_duration");
				if (($lockTime->timestamp + $lockDuration) > time() && $lockUser!=$user_id){
					return true;
				}else{
					$oPage->setValue("lockuser", null);
					$oPage->setValue("locktime", null);
					$oPage->commit();
					$element->commit();
					return false;
				}
			}
		}

		/* Deprecated. use selector */
		public function autoDetectAllFilters(umiSelection $sel, $objectsMode = false) {
			$arr_parents = getRequest('rel');
			$i_depth = (int) getRequest('depth');
			$arr_domains = getRequest('domain_id');
			$arr_langs = getRequest('lang_id');

			if(!$i_depth) {
				$i_depth = 0;
			}

			$hierarchy = umiHierarchy::getInstance();
			$objectTypesCollection = umiObjectTypesCollection::getInstance();
			$hierarchyTypesCollection = umiHierarchyTypesCollection::getInstance();

			if(is_null(getRequest('or-mode')) == false) {
				$sel->setConditionModeOr();
			}

			if (isset($arr_domains[0])) {
				$sel->setDomainId($arr_domains[0]);
			}

			if (isset($arr_langs[0])) {
				$sel->setLangId($arr_langs[0]);
			}

			if (is_array($arr_parents) && count($arr_parents)) {
				foreach ($arr_parents as $s_parent_id) {
					$i_parent_id = intval($s_parent_id);
					if (is_numeric($i_parent_id)) {
						$sel->addHierarchyFilter(intval($s_parent_id), $i_depth, true);
					}
				}
			}

			$objectTypes = array_extract_values($sel->getObjectTypeConds());
			$elementTypes = array_extract_values($sel->getElementTypeConds());
			$hierarchyParents = array_extract_values($sel->getHierarchyConds(), $foo, true);

			$searchAllTextCond = getRequest('search-all-text');
			$searchAllTextCond = array_extract_values($searchAllTextCond);
			$filterCond = getRequest('fields_filter');
			$filterCond = array_extract_values($filterCond, $foo, true);

			if(sizeof($elementTypes)) {
				$lastElementTypeId = $elementTypes[sizeof($elementTypes) - 1];
			} else {
				$lastElementTypeId = false;
			}

			if(sizeof($objectTypes)) {
				reset($objectTypes);
				$typeId = current($objectTypes);
			} else if(sizeof($hierarchyParents)) {
				reset($hierarchyParents);
				$typeId = $hierarchy->getDominantTypeId(current($hierarchyParents));
			} else if(sizeof($elementTypes) && (!empty($searchAllTextCond) || sizeof($elementTypes) == 1)) {
				reset($elementTypes);
				$typeId = $objectTypesCollection->getTypeByHierarchyTypeId(array_pop($elementTypes));
			} else {
				$typeId = $objectTypesCollection->getTypeIdByGUID('root-pages-type');
			}

			if(empty($hierarchyParents) && !empty($elementTypes) && empty($searchAllTextCond) && empty($filterCond)) {
				$sel->optimize_root_search_query = true;
			} else {
				if(!empty($filterCond)) {
					if($lastElementTypeId) {
						$typeId = $objectTypesCollection->getTypeByHierarchyTypeId($lastElementTypeId);
					}
				}
			}

			if($typeId) {
				$this->autoDetectFilters($sel, $typeId);
				$this->autoDetectOrders($sel, $typeId);
			}

			if(!$objectsMode) {
				$sel->excludeNestedPages = true;
			}

			if(sizeof($hierarchyParents) && sizeof($elementTypes)) {
				$hierarchy_type_id = $hierarchyTypesCollection->getTypeByName("comments", "comment")->getId();
				$sel->addElementType($hierarchy_type_id);
			}

			if(getRequest('import')) {
				quickCsvImporter::autoImport($sel, $objectsMode, (bool) getRequest('force-hierarchy'));
			}

			if(getRequest('export')) {
				quickCsvExporter::autoExport($sel, (bool) getRequest('force-hierarchy'));
			}
			return true;
		}

		public function getPageStatusIdByStatusSid($statusId = 'page_status_publish') {
			$sel = new umiSelection;
			$sel->setObjectTypeFilter();
			$objectTypeId = $this->getGuideIdByFieldName('publish_status');
			if(!$objectTypeId) {
				return false;
			}
			$sel->addObjectType($objectTypeId);

			$result = umiSelectionsParser::runSelection($sel);
			foreach ($result as $objectId) {
				$statusStringId = umiObjectsCollection::getInstance()->getObject($objectId)->getValue("publish_status_id");
				if ($statusStringId == $statusId) {
					return $objectId;
				}
			}
			return false;
		}

		public function getGuideIdByFieldName($fieldName) {
			$fields = umiObjectTypesCollection::getInstance()->getTypeByGUID('root-pages-type');
			foreach ($fields->getAllFields() as $field) {
				if ($field->getName() == $fieldName) {
					return $field->getGuideId();
				}
			}
			return false;
		}

		public function setHeaderLabel($label) {
			$cmsController = cmsController::getInstance();
			$cmsController->headerLabel = $label;
		}

		public function getObjectTypeMethod($object) {
			if($object instanceof umiObject == false) {
				throw new coreException("Expected instance of umiObject as param.");
			}

			$objectTypes = umiObjectTypesCollection::getInstance();
			$objectTypeId = $object->getTypeId();
			$objectType = $objectTypes->getType($objectTypeId);
			if($objectType instanceof umiObjectType) {
				$hierarchyTypes = umiHierarchyTypesCollection::getInstance();
				$hierarchyTypeId = $objectType->getHierarchyTypeId();
				$hierarchyType = $hierarchyTypes->getType($hierarchyTypeId);

				if($hierarchyType instanceof umiHierarchyType) {
					return $hierarchyType->getExt();
				} else {
					throw new coreException("Can't get hierarchy type #{$hierarchyTypeId}");
				}
			} else {
				throw new coreException("Can't get object type #{$objectTypeId}");
			}
		}

		public function getDatasetConfiguration($param = '') {
			return array(
					'methods' => array(
						array('title'=>getLabel('smc-load'), 'forload'=>true, 			 'module'=>'content', '#__name'=>'load_tree_node'),
						array('title'=>getLabel('smc-delete'), 					     'module'=>'content', '#__name'=>'tree_delete_element'),
						array('title'=>getLabel('smc-activity'), 		 'module'=>'content', '#__name'=>'tree_set_activity'),
						array('title'=>getLabel('smc-copy'), 'module'=>'content', '#__name'=>'tree_copy_element'),
						array('title'=>getLabel('smc-move'), 					 'module'=>'content', '#__name'=>'tree_move_element'),
						array('title'=>getLabel('smc-change-template'), 						 'module'=>'content', '#__name'=>'change_template'),
						array('title'=>getLabel('smc-change-lang'), 					 'module'=>'content', '#__name'=>'copy_to_lang_old'),
						array('title'=>getLabel('smc-change-lang'), 					 'module'=>'content', '#__name'=>'move_to_lang'),
					)
				);
		}

		final public function dataset_config() {
			$param = getRequest('param');

			$childMap = array('methods'=>'method', 'types'=>'type', 'stoplist'=>'exclude', 'default'=>'column');

			$datasetConfig = $this->getDatasetConfiguration($param);

			$document = new DOMDocument();
			$document->encoding = "utf-8";

			$root	  = $document->createElement('dataset');
			$document->appendChild($root);

			if(is_array($datasetConfig)) {
				$objectTypes = umiObjectTypesCollection::getInstance();

				foreach($datasetConfig as $sectionName => $sectionRecords) {
					$section = $document->createElement($sectionName);
					$root->appendChild($section);
					if(is_array($sectionRecords)) {
						foreach($sectionRecords as $record) {
							$element = $document->createElement($childMap[$sectionName]);
							if(is_array($record)) {
								foreach($record as $propertyName => $propertyValue) {
									if($propertyName === "#__name") {
										$element->appendChild( $document->createTextNode($propertyValue) );
										continue;
									}

									if($propertyName == "id" && !is_numeric($propertyValue)) {
										$propertyValue = $objectTypes->getBaseType(get_class($this), $propertyValue);
									}
									$element->setAttribute($propertyName, is_bool($propertyValue) ? ($propertyValue ? "true" : "false") : $propertyValue );
								}
							} else {
								$element->appendChild( $document->createTextNode($record) );
							}
							$section->appendChild($element);
						}
					} else {
						$section->appendChild( $document->createTextNode($sectionRecords) );

					}
				}
			}

			$buffer = outputBuffer::current();
			$buffer->contentType('text/xml');
			$buffer->charset('utf-8');
			$buffer->push($document->saveXML());
			$buffer->end();
		}

		public function change_template() {
			$elements = getRequest('element');
			if(!is_array($elements)) {
				$elements = array($elements);
			}

			$element = $this->expectElement("element");
			$templateId = getRequest('template-id');

			if (!is_null($templateId)) {
				foreach($elements as $elementId) {
					$element = $this->expectElement($elementId, false, true);

					if ($element instanceof umiHierarchyElement) {
						$element->setTplId($templateId);
						$element->commit();
					} else {
						throw new publicAdminException(getLabel('error-expect-element'));
					}
				}

				$this->setDataType("list");
				$this->setActionType("view");
				$data = $this->prepareData($elements, "pages");
				$this->setData($data);

				return $this->doData();
			} else {
				throw new publicAdminException(getLabel('error-expect-action'));
			}
		}

		public function switchGroupsActivity($groupName, $activity) {
			$groups = umiFieldsGroup::getAllGroupsByName($groupName);
			foreach($groups as $group) {
				if($group instanceof umiFieldsGroup) {
					$group->setIsActive($activity);
					$group->commit();
				}
			}
		}
	};


	interface iBaseSerialize {
		public static function serializeDocument($type, $xmlString, $params);
	};



	abstract class baseSerialize implements iBaseSerialize {
		static $called = Array();
	
		final public static function serializeDocument($type, $buffer, $params) {
			$serializer = self::loadSerializer($type);
			return $serializer->execute($buffer, $params);
		}
		
		
		abstract public function execute($xmlString, $params);
		
		
		protected static function loadSerializer($type) {
			$filename = SYS_KERNEL_PATH . "subsystems/matches/serializes/{$type}/{$type}.php";
			if(is_file($filename)) {
				require $filename;
				
				$serializerClassName = strtolower($type) . "Serialize";
				
				if(class_exists($serializerClassName)) {
					return new $serializerClassName();
				} else {
					throw new coreException("Class {$serializerClassName} doesn't exsits");
				}
			} else {
				throw new coreException("Can't load serializer of type \"{$type}\"");
			}
		}
		
		
		protected function sendHTTPHeaders($params) {
			if(is_array($params)) {
				$buffer = outputBuffer::current();
				$headers = getArrayKey($params, 'headers');
				
				if(is_array($headers)) {
					foreach($headers as $i => $v) {
						if(strtolower($i) == 'content-type') {
							$buffer->contentType($v);
							continue;
						}
						$buffer->header($i, $v);
					}
				}
			} else {
				throw new coreException("First argument must be ad array in sendHTTPHeaders()");
			}
		}
	};



	interface iUmiLogger {

		
		public function __construct($logDir = "./logs/");

		public function pushGlobalEnviroment();

		public function push($mess, $enableTimer = true);

		public function log();

		public function save();

		public function get();
	};



	class umiLogger implements iUmiLogger {
		
		protected	$logDir = "./logs/",
					$log = "",
					$is_saved = false,
					$is_global_env_pushed = false,
					$start_time = false;
		
		public function __construct($logDir = "./logs/") {
			$this->runTimer();

			$this->logDir = $logDir;
			$this->checkDirectory();
		}
		
		public function pushGlobalEnviroment() {
			if($this->is_global_env_pushed == false) {
				$this->collectGlobalEnviroment();
				$this->is_global_env_pushed = true;
				
				return true;
			} else {
				return false;
			}
		}
		
		
		public function push($mess, $enableTimer = true) {
			if($enableTimer == true) {
				$mess = "[" . sprintf("%1.7f", $this->getTimer()) . "]\t" . $mess;
			}
			$this->log .= $mess . "\n";
		}
		
		
		public function log() {
			$this->pushGlobalEnviroment();
		}
		
		
		public function __destruct() {
			if($this->is_saved == false) {
				$this->save();
			}
		}

		
		public function save() {
			$store_dirpath = $this->prepareStoreDir();
			
			$filename = date("Y-m-d_H_i_s");
			
			$filepath = $store_dirpath . "/" . $filename . ".log";
			if(file_put_contents($filepath, $this->get())) {
				return $filepath;
			} else {
				throw new Exception("Can't save log in \"{$filepath}\"");
			}
			
			$this->is_saved = true;
		}
		
		
		public function get() {
			return $this->log;
		}
		
		
		protected function checkDirectory() {
			$dirpath = $this->logDir;
			
			if(is_dir($dirpath)) {
				if(is_writable($dirpath)) {
					return true;
				} else {
					throw new Exception("Directory \"{$dirpath}\" must be writable");
				}
			} else {
				throw new Exception("Directory \"{$dirpath}\" doesn't exists");
			}
		}
		
		protected function prepareStoreDir() {
			$dirpath = $this->logDir;
			$remote_addr = $_SERVER['REMOTE_ADDR'];
			$storepath = $dirpath . $remote_addr;
			
			if(file_exists($storepath)) {
				if(is_writable($storepath)) {
					return $storepath;
				} else {
					throw new Exception("Directory \"{$storepath}\" must be writable");
				}
			}
			
			if(mkdir($storepath)) {
				return $storepath . '/';
			} else {
				throw new Exception("Can't create directory \"{$storepath}\"");
			}
		}
		
		protected function collectGlobalEnviroment() {
			$this->collectGlobalArray('_COOKIE');
			$this->collectGlobalArray('_SESSION');
			$this->collectGlobalArray('_POST');
			$this->collectGlobalArray('_GET');
			$this->collectGlobalArray('_FILES');
			
			if(function_exists('apache_request_headers')) {
				$this->collectArray("Request headers", apache_request_headers());
			}
			
			if(function_exists('apache_response_headers')) {
				$this->collectArray("Response headers", apache_response_headers());
			}
		}
		
		
		protected function collectGlobalArray($varname) {
			global $$varname;
			
			if(isset($$varname)) {
				$this->collectArray($varname, $$varname);
			}
		}
		
		
		protected function collectArray($name, $arr) {
			if(!is_array($arr)) {
				return false;
			}
			
			if(sizeof($arr) == 0) {
				return true;
			}

			$msg = "[{$name}]\n";
			foreach($arr as $i => $v) {
				$msg .= "\t[" . $i . "]\n\t" . "(" . gettype($v) . ") ";
				
				if(is_array($v)) {
					$v = $this->serializeArray($v);
				}
				$msg .= $v . "\n\n";
			}
			$this->push($msg, false);
			return true;
		}
		
		protected function serializeArray($arr) {
			$res = "[";
			
			$sz = sizeof($arr);
			$c = 0;
			foreach($arr as $i => $v) {
				if(is_array($v)) {
					$v = $this->serializeArray($v);
				}
				
				$res .= "'" . $v . "'";
				if(++$c < $sz) {
					$res .= ", ";
				}
			}
			
			$res .= "]";
			return $res;
		}
		
		protected function runTimer() {
			$this->start_time = microtime(true);
		}
		
		protected function getTimer() {
			$time = microtime(true) - $this->start_time;
			return round($time, 7);
		}
	};


/**
	* Классы, дочерние от класса baseRestriction отвечают за валидацию полей.
	* В таблицу `cms3_object_fields` добавилось поле `restriction_id`
	* Список рестрикшенов хранится в таблице `cms3_object_fields_restrictions`:
	* +----+------------------+-------------------------------+---------------+
	* | id | class_prefix     | title                         | field_type_id |
	* +----+------------------+-------------------------------+---------------+
	* | 1  | email            | i18n::restriction-email-title | 4             |
	* +----+------------------+-------------------------------+---------------+
	*
	* При модификации значения поля, которое связано с restriction'ом, загружается этот restriction,
	* В метод validate() передается значение. Если метод вернет true, работа продолжается,
	* если false, то получаем текст ошибки и делаем errorPanic() на предыдущую страницу.
*/
	abstract class baseRestriction {
		protected	$errorMessage = 'restriction-error-common',
					$id, $title, $classPrefix, $fieldTypeId;


		/**
			* Загрузить restriction
			* @param Integer $restrictionId id рестрикшена
			* @return baseRestriction потомок класса baseRestriction
		*/
		final public static function get($restrictionId) {
			$restrictionId = (int) $restrictionId;

			$sql = "SELECT `class_prefix`, `title`, `field_type_id` FROM `cms3_object_fields_restrictions` WHERE `id` = '{$restrictionId}'";
			$result = l_mysql_query($sql);

			if(list($classPrefix, $title, $fieldTypeId) = mysql_fetch_row($result)) {
				$filePath = CURRENT_WORKING_DIR . '/classes/system/subsystems/models/data/restrictions/' . $classPrefix . '.php';
				$className = $classPrefix . 'Restriction';
				if(is_file($filePath) == false) {
					return false;
				}

				if(!class_exists($className)) {
					require $filePath;
				}

				if(class_exists($className)) {
					$restriction = new $className($restrictionId, $classPrefix, $title, $fieldTypeId);
					if($restriction instanceof baseRestriction) {
						return $restriction;
					} else {
						return false;
					}
				} else {
					return false;
				}
			} else {
				return false;
			}
		}


		/**
			* Получить список всех рестрикшенов
			* @return Array массив из наследников baseRestriction
		*/
		final public static function getList() {
			$sql = "SELECT `id` FROM `cms3_object_fields_restrictions`";
			$result = l_mysql_query($sql);

			$restrictions = array();
			while(list($id) = mysql_fetch_row($result)) {
				 $restriction= self::get($id);
				 if($restriction instanceof baseRestriction) {
				 	$restrictions[] = $restriction;
				 }
			}
			return $restrictions;
		}


		/**
			* Добавить новый restriction
			* @param String $classPrefix название класса рестрикшена
			* @param String $title название рестрикшена
			* @param Integer $fieldTypeId id типа полей, для которого допустим этот рестрикшен
			* @return Integer|Boolean id созданного рестрикшена, либо false
		*/
		final public static function add($classPrefix, $title, $fieldTypeId) {
			$classPrefix = l_mysql_real_escape_string($classPrefix);
			$title = l_mysql_real_escape_string($title);
			$fieldTypeId = (int) $fieldTypeId;

			$sql = <<<SQL
INSERT INTO `cms3_object_fields_restrictions`
	(`class_prefix`, `title`, `field_type_id`)
	VALUES ('{$classPrefix}', '{$title}', '{$fieldTypeId}')
SQL;
			l_mysql_query($sql);
			return l_mysql_insert_id();
		}


		/**
			* Провалидировать значение поля
			* @param Mixed &$value валидируемое значение поля
			* @return Boolean результат валидации
		*/
		abstract public function validate($value, $objectId = false);

		/**
			* Получить текст сообщения об ошибке
			* @return String сообщение об ошибке
		*/
		public function getErrorMessage() {
			return getLabel($this->errorMessage);
		}


		/**
			* Получить название рестрикшена
			* @return String название рестрикшена
		*/
		public function getTitle() {
			return getLabel($this->title);
		}


		/**
			* Получить префикс класса рестрикшена
			* @return String префикс класса рестрикшена
		*/
		public function getClassName() {
			return $this->classPrefix;
		}


		/**
			* Получить id рестрикшена
			* @return Integer id рестрикшена
		*/
		public function getId() {
			return $this->id;
		}

		public function getFieldTypeId() {
			return $this->fieldTypeId;
		}

		public static function find($classPrefix, $fieldTypeId) {
			$restrictions = self::getList();

			foreach($restrictions as $restriction) {
				if($restriction->getClassName() == $classPrefix && $restriction->getFieldTypeId() == $fieldTypeId) {
					return $restriction;
				}
			}
		}


		/**
			* Конструктор класса
		*/
		protected function __construct($id, $classPrefix, $title, $fieldTypeId) {
			$this->id = (int) $id;
			$this->classPrefix = $classPrefix;
			$this->title = $title;
			$this->fieldTypeId = (int) $fieldTypeId;
		}
	};

	interface iNormalizeInRestriction {
		public function normalizeIn($value, $objectId = false);
	};

	interface iNormalizeOutRestriction {
		public function normalizeOut($value, $objectId = false);
	};


	interface iRedirects {
		public static function getInstance($c = NULL);
		public function add($source, $target, $status = 301);
		public function getRedirectsIdBySource($source);
		public function getRedirectIdByTarget($target);
		public function del($id);
		public function redirectIfRequired($currentUri);
		
		public function init();
	};


	class redirects implements iRedirects {
		/**
			* Получить экземпляр коллекции
			* @return iRedirects экземпляр коллекции
		*/
		public static function getInstance($c = NULL) {
			static $instance;
			if(is_null($instance)) {
				$instance = new redirects;
			}
			return $instance;
		}
		
		
		/**
			* Добавить новое перенаправление
			* @param String $source адрес страницы, с которой осуществляется перенаправление
			* @param String $target адрес целевой страницы
			* @param Integer $status = 301 статус перенаправления
		*/
		public function add($source, $target, $status = 301) {
			if($source == $target) return;
			
			$source = l_mysql_real_escape_string($this->parseUri($source));
			$target = l_mysql_real_escape_string($this->parseUri($target));
			$status = (int) $status;
			
			l_mysql_query("START TRANSACTION /* Adding new redirect records */");
			
			//Создать новые записи на тот случай, если у нас уже есть перенаправление на $target
			$sql = <<<SQL
INSERT INTO `cms3_redirects`
	(`source`, `target`, `status`)
	SELECT `source`, '{$target}', '{$status}' FROM `cms3_redirects`	
		WHERE `target` = '{$source}'
SQL;
			l_mysql_query($sql);
			
			//Удалить старые записи
			$sql = <<<SQL
DELETE FROM `cms3_redirects` WHERE `target` = '{$source}'
SQL;
			l_mysql_query($sql);
			
			$result = l_mysql_query("SELECT * FROM `cms3_redirects` WHERE `source` = '{$source}' AND `target` = '{$target}'", true);
			if(mysql_num_rows($result)) {
				return;
			}
			
			//Добавляем новую запись для перенаправления
			$sql = <<<SQL
INSERT INTO `cms3_redirects`
	(`source`, `target`, `status`)
	VALUES
	('{$source}', '{$target}', '{$status}')
SQL;
			l_mysql_query($sql);
			
			l_mysql_query("COMMIT");
		}
		
		
		/**
			* Получить список перенаправлений со страницы $source
			* @param String $source адрес страницы, с которой осуществляется перенаправление
			* @return Array массив перенаправлений
		*/
		public function getRedirectsIdBySource($source) {
			$sourceSQL = l_mysql_real_escape_string($this->parseUri($source));
			$redirects = array();
			
			$sql = "SELECT `id`, `target`, `status` FROM `cms3_redirects` WHERE `source` = '{$sourceSQL}'";
			$result = l_mysql_query($sql);
			while(list($id, $target, $status) = mysql_fetch_row($result)) {
				$redirects[$id] = Array($source, $target, (int) $status);
			}
			return $redirects;
		}
		
		
		/**
			* Получить перенаправление по целевому адресу
			* @param String $target адрес целевой страницы
			* @return массив перенаправления
		*/
		public function getRedirectIdByTarget($target) {
			$targetSQL = l_mysql_real_escape_string($this->parseUri($target));
			$redirects = array();
			
			$sql = "SELECT `id`, `source`, `status` FROM `cms3_redirects` WHERE `target` = '{$targetSQL}'";
			$result = l_mysql_query($sql);
			if(list($id, $source, $status) = mysql_fetch_row($result)) {
				return Array($source, $target, (int) $status);
			} else {
				return false;
			}
		}
		
		
		/**
			* Удалить перенаправление
			* @param Integer $id id перенаправления
		*/
		public function del($id) {
			$id = (int) $id;
			
			$sql = <<<SQL
DELETE FROM `cms3_redirects` WHERE `id` = '{$id}'
SQL;
			l_mysql_query($sql);
		}
		
		
		/**
			* Сделать перенаправление, если url есть в таблице перенаправлений
			* @param String $currentUri url для поиска
		*/
		public function redirectIfRequired($currentUri) {
			$currentUri = l_mysql_real_escape_string($this->parseUri($currentUri));
			
			$sql = <<<SQL
SELECT `target`, `status` FROM `cms3_redirects`
	WHERE `source` = '{$currentUri}'
	ORDER BY `id` DESC LIMIT 1
SQL;
			$result = l_mysql_query($sql);
			if(mysql_num_rows($result)) {
				list($target, $status) = mysql_fetch_row($result);
				return $this->redirect("/" . $target, (int) $status);
			}
			
			//Попробуем найти в перенаправление в подстраницах
			$uriParts = explode("/", trim($currentUri, "/"));
			do {
				array_pop($uriParts);
				$subUri = implode("/", $uriParts) . "/";
				$subUriSQL = l_mysql_real_escape_string($this->parseUri($subUri));
				
				if(!strlen($subUriSQL)) {
					if(count($uriParts)) continue;
					else break;
				}
				
				$sql = <<<SQL
SELECT `source`, `target`, `status` FROM `cms3_redirects`
	WHERE `source` = '{$subUriSQL}'
	ORDER BY `id` DESC LIMIT 1
SQL;

				$result = l_mysql_query($sql);
				if(mysql_num_rows($result)) {
					list($source, $target, $status) = mysql_fetch_row($result);
					
					$sourceUriSuffix = substr($currentUri, strlen($source));
					$target .= $sourceUriSuffix;
					$this->redirect("/" . $target, $status);
				}
				
			} while (sizeof($uriParts) > 1);
		}
		
		
		/**
			* Инициализировать события
		*/
		public function init() {
			$config = mainConfiguration::getInstance();
			
			if($config->get('seo', 'watch-redirects-history')) {
				$listener = new umiEventListener("systemModifyElement", "content", "onModifyPageWatchRedirects");
				$listener = new umiEventListener("systemMoveElement", "content", "onModifyPageWatchRedirects");
			}
		}
		
		protected function redirect($target, $status) {
			$statuses = array(
				300 => 'Multiple Choices',
				'Moved Permanently', 'Found', 'See Other',
				'Not Modified', 'Use Proxy', 'Switch Proxy', 'Temporary Redirect'
			);
			
			if(!isset($statuses[$status])) return false;
			$statusMessage = $statuses[$status];
			
			$buffer = outputBuffer::current();
			if($referer = getServer('HTTP_REFERER')) {
				$buffer->header('Referrer', $referer);
			}
			$buffer->status($status . ' ' . $statusMessage);
			$buffer->redirect($target);
			$buffer->end();
		}
		
		protected function parseUri($uri) { return trim($uri, '/'); }
	};


/*
    stream_open
    stream_read
    stream_write
    stream_tell
    stream_eof
    stream_seek
    url_stat
    stream_flush
    stream_close
*/
	interface iUmiBaseStream {

		public function stream_open($path, $mode, $options, $opened_path);
		public function stream_read($count);
		public function stream_write($data);
		public function stream_tell();
		public function stream_eof();
		public function stream_seek($offset, $whence);
		public function stream_flush();
		public function stream_close();
		public function url_stat();
		
		public function getProtocol();

		public static function getCalledStreams();
	};


	abstract class umiBaseStream implements iUmiBaseStream {
	    public static $allowTimeMark = true;
		protected
				$position = 0,
				$length = 0,
				$data = "",
				$expire = 0,
				$transform = "",
				$path, $params = array(),
				$isJson = false;

		protected	$scheme;
		protected static $callLog = array();

		private		$start_time = false;


		public function __construct() {
			$this->start_time = microtime(true);
		}

		public function stream_flush() {
			return true;
		}


		public function stream_tell() {
			return $this->position;
		}


		public function stream_eof() {
			return $this->position >= $this->length;
		}


		public function stream_seek($offset, $whence) {
			switch($whence) {
				case SEEK_SET: {
					if($this->isValidOffset($offset)) {
						$this->position = $offset;
						return true;
					} else {
						return false;
					}
				}


				case SEEK_CUR: {
					if($offset >= 0) {
						$this->position += $offset;
						return true;
					} else {
						return false;
					}
				}


				case SEEK_END: {
					if($this->isValidOffset($this->position + $offset)) {
						$this->position = $this->length + $offset;
						return true;
					} else {
						return false;
					}
				}


				default: {
					return false;
				}
			}
		}


		public function url_stat() {
			return Array();
		}


		public function stream_stat() {
			return Array();
		}


		public function stream_close() {
			return true;
		}


		public function stream_read($count) {
			$result = bytes_substr($this->data, $this->position, $count);
			$this->position += $count;
			return $result;
		}


		public function stream_write($inputData) {
			$inputDataLength = bytes_strlen($inputData);

		    $dataLeft = bytes_substr($this->data, 0, $this->position);
			$dataRight = bytes_substr($this->data, $this->position + $inputDataLength);

			$this->data = $dataLeft . $inputData . $dataRight;

			$this->position += $inputData;
			return $inputDataLength;
		}


		public function getProtocol() {
			return $this->scheme . "://";
		}

		static public function registerStream($scheme) {
			$config = mainConfiguration::getInstance();
			$filepath = $config->includeParam('system.kernel.streams') . "{$scheme}/{$scheme}Stream.php";
			if(file_exists($filepath)) {
				require $filepath;
				if(!stream_wrapper_register($scheme, "{$scheme}Stream")) {
					throw new coreException("Failed to register stream \"{$scheme}\"");
				}
			} else {
				throw new coreException("Can't locate file \"{$filepath}\"");
			}
		}


		public static function protectParams($param) {
			return str_replace("/", "&#2F;", $param);
		}


		public static function unprotectParams($param) {
			return str_replace("&#2F;", "/", $param);
		}

		public static function getCalledStreams() {
			$lines_arr = Array();
			$total_time = 0;
			foreach(self::$callLog as $callInfo) {
				list($url, $time) = $callInfo;
				$total_time += $time;
				$lines_arr[] = array(
					'attribute:generation-time'	=> $time,
					'node:url'					=> $url
				);
			}
			$block_arr = array('nodes:call' => $lines_arr);

			$dom = new DOMDocument;
			$dom->formatOutput = XML_FORMAT_OUTPUT;
			$rootNode = $dom->createElement("streams-call");
			$rootNode->setAttribute('total-time', $total_time);
			$dom->appendChild($rootNode);

			$xmlTranslator = new xmlTranslator($dom);
			$xmlTranslator->translateToXml($rootNode, $block_arr);

			return $dom->saveXml();
		}

		public static function reportCallTime($path, $time) {
			foreach(self::$callLog as &$callInfo) {
				$callInfoPath = explode("?", $callInfo[0]);
				if($callInfoPath[0] == $path) {
					$callInfo[1] = $time;
				}
			}
		}



		protected function isValidOffset($offset) {
			return ($offset >= 0) && ($offset < $this->length);
		}


		protected function translateToXml() {
			$args = func_get_args();
			$res = $args[0];

			if($this->isJson) {
				return $this->translateToJSON($res);
			}

			if(isset($res['plain:result'])) {
				return $res['plain:result'];
			}

			$dom = new DOMDocument("1.0", "utf-8");
			$dom->formatOutput = XML_FORMAT_OUTPUT;

			$rootNode = $dom->createElement("udata");
			$dom->appendChild($rootNode);

			$rootNode->setAttribute('xmlns:xlink', 'http://www.w3.org/TR/xlink');

			$xslTranslator = new xmlTranslator($dom);
			$xslTranslator->translateToXml($rootNode, $res);

			$executionTime = number_format(microtime(true) - $this->start_time, 6);
			$rootNode->setAttribute('generation-time', $executionTime);
			self::reportCallTime($this->getProtocol() . $this->path, $executionTime);

			if($this->transform) {
				return $this->applyXslTransformation($dom, $this->transform);
			}

			return $dom->saveXml();
		}


		protected function applyXslTransformation(DOMDocument $dom, $xslFilePath) {
			$config = mainConfiguration::getInstance();
			if ($resourcesDir = cmsController::getInstance()->getResourcesDirectory()) {
				$templatePath = $resourcesDir . "/xslt/";
			} else {
				$templatePath = $config->includeParam('templates.xsl');
			}

			$filePath = $templatePath . $xslFilePath;
			if(is_file($filePath) == false) {
				throw new publicException("Udata trasform xsl-template was not found \"{$filePath}\"");
			}

			$xsltDom = DomDocument::load($filePath, DOM_LOAD_OPTIONS);
			checkXmlError($xsltDom);

			$xslt = new xsltProcessor;
			$xslt->registerPHPFunctions();
			$xslt->importStyleSheet($xsltDom);
			return $xslt->transformToXML($dom);
		}


		protected function parsePath($path) {

			$protocol = $this->getProtocol();
			$path = substr($path, strlen($protocol));

			$parsed_url = parse_url($path);
			$realPath = $parsed_url['path'];
			if(substr($realPath, -5) == '.json') {
				$realPath = substr($realPath, 0, strlen($realPath) - 5);
				$this->isJson = true;
			} else $this->isJson = false;

			$this->path = $realPath;

			self::$callLog[] = array($protocol . $path, false);

			if($params = getArrayKey($parsed_url, 'query')) {
				parse_str($params, $params_arr);
				$this->params = $params_arr;

				$_REQUEST = array_merge($_REQUEST, $params_arr);

				if(isset($params_arr['expire'])) {
					$this->expire = getArrayKey($params_arr, 'expire');
				}

				if(isset($params_arr['transform'])) {
					$this->transform = getArrayKey($params_arr, 'transform');
				}

			}

			if(!$this->expire) {
				$config = mainConfiguration::getInstance();

				if ($config->get('cache', 'streams.cache-enabled')) {
					$expire = (int) $config->get('cache', 'streams.cache-lifetime');
					if ($expire > 0) {
						$this->expire = $expire;

					}
				}
			}

			return $this->path;
		}


		protected function normalizeString($str) {
			$str = urldecode($str);

			if(!preg_match("/[\x{0000}-\x{FFFF}]+/u", $str)) {
				$str = iconv("CP1251", "UTF-8//IGNORE", $str);
			}

			return $str;
		}

		protected function setData($data) {
		    if(!$data) {
		        return false;
		    }

		    $this->data = $data;
		    $this->length = bytes_strlen($data);
		    return true;
		}

		protected function setDataError($errorCode) {
			$data = Array(
				'error' => Array(
					'attribute:code' => $errorCode,
					'node:message' => getLabel('error-' . $errorCode)
				)
			);
			$data = self::translateToXml($data);
			$this->setData($data);
			return true;
		}


		protected function translateToJSON($data) {
			$translator = new jsonTranslator;
			return $translator->translateToJson($data);
		}
	};



$i18n = Array(
	"header-data-config"			=> "Настройки модуля",
	"header-data-guides"			=> "Справочники",
	"header-data-guide_items"		=> "Содержание справочника",
	"header-data-guide_item_edit"	=> "Редактирование элемента справочника",
	"header-data-guide_item_add"	=> "Добавление элемента справочника",
	"header-data-trash"				=> "Корзина удаленных страниц",
	"header-data-types"				=> "Типы данных",
	"header-data-type_edit"			=> "Редактирование типа данных",
	"header-data-type_group_add"	=> "Добавление группы полей",
	"header-data-type_group_edit"	=> "Редактирование группы полей",
	"header-data-type_field_add"	=> "Добавление поля",
	"header-data-type_field_edit"	=> "Редактирование поля",

	"label-add-fields-group"		=> "Добавить группу полей",
	'label-delete-time'				=> 'Время удаления',
	"label-edit-type-common"		=> "Свойства типа",
	"label-empty-all"				=> "Очистить корзину",
	'label-field-anons'				=> 'Анонс',
	'label-field-content'			=> 'Контент',
	"label-field-default-guide"		=> "Использовать справочник",
	"label-field-in-filter"			=> "Использовать в фильтрах",
	"label-field-in-search"			=> "Индексировать",
	"label-field-is-required"		=> "Обязательное",
	"label-field-is-visible"		=> "Видимое",
	"label-field-name"				=> "Идентификатор",
	'label-field-restriction-id'	=> 'Проверка значений',
	"label-field-tip"				=> "Подсказка",
	"label-field-title"				=> "Название поля",
	"label-field-type"				=> "Тип поля",
	"label-group-is-visible"		=> "Видимое",
	"label-group-name"				=> "Идентификатор",
	"label-group-title"				=> "Название группы",
	"label-guide-add"				=> "Добавить справочник",
	"label-guide-item-add"			=> "Добавить наименование справочника",
	"label-hierarchy-type"			=> "Назначение типа",
	"label-is-guide"				=> "Можно использовать как справочник",
	"label-is-public"				=> "Общедоступный",
	"label-method"					=> "Метод",
	"label-module"					=> "Модуль",
	'label-section-description'		=> 'Описание раздела',
	"label-type-add"				=> "Добавить тип данных",
	"label-type-name"				=> "Название типа",

	'object-type-filemanagers'		=> 'Файловые менеджеры',
	'object-type-blogs-blog_message'	=> 'Cообщение блога',
	'object-type-rss-lenta'			=> 'RSS-лента',
	'object-type-users-author'		=> 'Автор',
	'object-type-eshop-address'		=> 'Адрес доставки',
	'object-type-banners-banner'		=> 'Баннер',
	'object-type-banners-banner-image'		=> 'Баннер с картинкой',
	'object-type-banners-banner-swf'		=> 'Баннер с флешкой',
	'object-type-banners-banner-html'		=> 'Баннер с HTML',
	'object-type-blogs-blog'		=> 'Блог',
	'object-type-valyuta'			=> 'Валюта',
	'object-type-vote-poll_item'		=> 'Вариант ответа на опрос',
	'object-type-vid_homyachka'		=> 'Вид хомячка',
	'object-type-faq-question'		=> 'Вопрос в FAQ',
	'object-type-catalog-question'		=> 'Вопрос в матрице подбора',
	'object-type-dispatches-release'	=> 'Выпуск рассылки',
	'object-type-users-users'		=> 'Группы пользователей',
	'object-type-eshop-discount_card'	=> 'Дисконтная карта',
	'object-type-druzhelyubnost_homyachka'	=> 'Дружелюбность хомячка',
	'object-type-eshop-order'		=> 'Заказ в интернет-магазине',
	'object-type-content-ticket'		=> 'Заметка',
	'object-type-integriruemost_homyachka_v_koleso'			=> 'Интегрируемость хомячка в колесо',
	'object-type-faq-category'		=> 'Категория в FAQ',
	'object-type-kachestvo_fleshki'		=> 'Качество флешки',
	'object-type-catalog-object'		=> 'Объект каталога',
	'object-type-catalog-object-good'		=> 'Товар в магазине',
	'object-type-catalog-object-good-hamster'		=> 'Хомячок',
	'object-type-catalog-object-good-kolesa'		=> 'Колеса для хомячков',
	'object-type-catalog-object-good-povodki'		=> 'Поводки',
	'object-type-comments-comment'		=> 'Комментарий',
	'object-type-blogs-blog_comment'	=> 'Комментарий к сообщению блога',
	'object-type-forum-conf'		=> 'Конференция форума',
	'object-type-kulinarnye_predpochteniya_homyachka'			=> 'Кулинарные предпочтения хомячка',
	'object-type-news-rubric'		=> 'Лента новостей',
	'object-type-updatesrv-license'		=> 'Лицензия UMI.CMS',
	'object-type-catalog-matrix'		=> 'Матрица подбора',
	'object-type-banners-place'		=> 'Места показов баннеров',
	'object-type-eshop-order_item'		=> 'Наименование в заказе',
	'object-type-news-item'			=> 'Новость',
	'object-type-okras_homyachka'		=> 'Окрас хомячка',
	'object-type-catalog-answer'		=> 'Ответ на вопрос в матрице подбора',
	'object-type-eshop-payment_transaction'	=> 'Платежная транзакция',
	'object-type-dispatches-subscriber'	=> 'Подписчик на рассылку',
	'object-type-pol'			=> 'Пол',
	'object-type-pol_homyachka'		=> 'Пол хомячка',
	'object-type-users-user'		=> 'Пользователь',
	'object-type-faq-project'		=> 'Проект в FAQ',
	'object-type-proizvoditeli'		=> 'Производители',
	'object-type-catalog-category'		=> 'Раздел каталога',
	'object-type-razdel_sajta'		=> 'Раздел сайта',
	'object-type-dispatches-dispatch'	=> 'Рассылка',
	'object-type-filemanager-shared_file'	=> 'Скачиваемый файл',
	'object-type-eshop-discount'		=> 'Скидка в интернет-магазине',
	'object-type-eshop-store'		=> 'Склад интернет-магазина',
	'object-type-forum-message'		=> 'Сообщение в форуме',
	'object-type-dispatches-message'	=> 'Сообщение рассылки',
	'object-type-webforms-address'		=> 'Список адресов',
	'object-type-spisok_gorodov_dlya_geo'	=> 'Список городов для geo',
	'object-type-spravochnik_dlya_polya_gorod'	=> 'Справочник для поля "Город"',
	'object-type-spravochnik_dlya_polya_zhanr'	=> 'Справочник для поля "Жанр"',
	'object-type-spravochnik_dlya_polya_nalichiya_na_skladah'	=> 'Справочник для поля "Наличия на складах"',
	'object-type-spravochnik_dlya_polya_ukazatel_na_sklad'		=> 'Справочник для поля "Указатель на склад"',
	'object-type-spravochnik_dlya_polya_format_nositelya'		=> 'Справочник для поля "Формат носителя"',
	'object-type-spravochniki'		=> 'Справочники',
	'object-type-vote-poll'			=> 'Стандартный опрос',
	'object-type-eshop-order_status'	=> 'Статус заказа',
	'object-type-eshop-payment_transaction_status'	=> 'Статус платежной транзакции',
	'object-type-blogs-blog_privacy'	=> 'Степень приватности (блоги)',
	'object-type-content-'			=> 'Страница контента',
	'object-type-strany'			=> 'Страны',
	'object-type-news-subject'		=> 'Сюжет публикации',
	'object-type-tip_rss'			=> 'Тип RSS',
	'object-type-updatesrv-license_type'	=> 'Тип лицензии UMI.CMS',
	'object-type-tip_povodka'		=> 'Тип поводка',
	'object-type-tip_shersti_homyachka'	=> 'Тип шерсти хомячка',
	'object-type-eshop-store_relation'	=> 'Товар на складе интернет-магазина',
	'object-type-forum-topic'		=> 'Топик в форуме',
	'object-type-webforms-form'		=> 'Форма обратной связи',
	'object-type-photoalbum-album'		=> 'Фотоальбом',
	'object-type-photoalbum-photo'		=> 'Фотография',
	'object-type-harakter_homyachka'	=> 'Характер хомячка',
	'object-type-cvet'			=> 'Цвет',
	'object-type-webforms-template'		=> 'Шаблон письма',
	'object-type-new-data-type' 		=>  'Новый тип данных',
	'object-type-new-guide' 			=> 	'Новый справочник',

	'object-filemanager-elfinder' => 'Файловый менеджер elFinder',
	'object-filemanager-flash' 	=> 'Классический файловый менеджер',
	'object-samka'				=> 'Самка',
	'object-samec'				=> 'Самец',
	'object-v_korzine'			=> 'В корзине',
	'object-ozhidaet_proverki'		=> 'Ожидает проверки',
	'object-prinyat'			=> 'Принят',
	'object-otklonen'			=> 'Отклонен',
	'object-otmenen'			=> 'Отменен',
	'object-gotov'				=> 'Готов',
	'object-v_processe_oplaty'		=> 'В процессе оплаты',
	'object-oplachen_uspeshno'		=> 'Оплачен успешно',
	'object-oshibki_v_oplate'		=> 'Ошибки в оплате',
	'object-proveren_mozhno_oplachivat'	=> 'Проверен, можно оплачивать',
	'object-proverka_oplaty'		=> 'Проверка оплаты',
	'object-1_inicializirovana'		=> '1. Инициализирована',
	'object-2_dostavlena'			=> '2. Доставлена',
	'object-3_ne_dostavlena'		=> '3. Не доставлена',
	'object-4_predvaritel_no_prinyata_ozhidaetsya_podtverzhdenie'			=> '4. Предварительно принята (ожидается подтверждение)',
	'object-5_predvaritel_no_prinyata_podtverzhdenie_ne_trebuetsya'			=> '5. Предварительно принята (подтверждение не требуется)',
	'object-6_predvaritel_no_otklonena_ozhidaetsya_podtverzhdenie'			=> '6. Предварительно отклонена (ожидается подтверждение)',
	'object-7_predvaritel_no_otklonena_podtverzhdenie_ne_trebuetsya'		=> '7. Предварительно отклонена (подтверждение не требуется)',
	'object-8_prinyata_s_podtverzhdeniem'	=> '8. Принята с подтверждением',
	'object-9_otklonena_s_podtverzhdeniem'	=> '9. Отклонена с подтверждением',
	'object-moya_zhzh-lenta'		=> 'Моя ЖЖ-лента',
	'object-rss'				=> 'RSS',
	'object-atom'				=> 'ATOM',
	'object-dlya_vseh'			=> 'Для всех',
	'object-dlya_vladel_ca_i_druzej'	=> 'Для владельца и друзей',
	'object-tol_ko_dlya_vladel_ca_bloga'	=> 'Только для владельца блога',
	'object-male'   => 'Мужской',
	'object-female' => 'Женский',
	'object-height'				=> 'Высокое',
	'object-low'				=> 'Низкое',
	'object-medium'				=> 'Среднее',
	'object-status-preunpublish'	=> 'Готовится к снятию с публикации',
	'object-status-publish'		=> 'Опубликован',
	'object-status-unpublish'	=> 'Снят с публикации',
	'object-type-users-avatar'			=> 'Аватара',
	'object-type-blogs20-blog'			=> 'Блог',
	'object-type-eshop-currency'			=> 'Валюта в интернет магазине',
	'object-type-blogs20-comment'			=> 'Комментарий блога',
	'object-type-blogs20-post'			=> 'Пост блога',
	'object-type-status_stranicy'			=> 'Статус страницы',
	'object-type-webforms-page'			=> 'Страница с формой обратной связи',
	'object-supervajzery'			=> 'Супервайзеры',
	'object-zaregistrirovannye_pol_zovateli'			=> 'Зарегистрированные пользователи',
	'object-currency-australia-dollars' => 'Австралийский доллар',
	'object-currency-uk-pound' => 'Фунт стерлингов Соединенного королевства',
	'object-currency-belarus-rubles' => 'Белорусский рубль',
	'object-currency-us-dollar' => 'Доллар США',
	'object-currency-euro' => 'Евро',
	'object-currency-tenge' => 'Казахский тенге',
	'object-currency-can-dollar' => 'Канадский доллар',
	'object-currency-ukr-grivna' => 'Украинская гривна',
	'object-currency-rus-rubles' => 'Российский рубль',

	'hierarchy-type-content-page'		=> 'Страницы контента',
	'hierarchy-type-users-user'		=> 'Пользователи',
	'hierarchy-type-catalog-category'	=> 'Разделы каталога',
	'hierarchy-type-catalog-object'		=> 'Объекты каталога',
	'hierarchy-type-users-users'		=> 'Группы пользователей',
	'hierarchy-type-news-rubric'		=> 'Ленты новостей',
	'hierarchy-type-news-item'		=> 'Новости',
	'hierarchy-type-news-subject'		=> 'Сюжет публикации',
	'hierarchy-type-vote-poll'		=> 'Опрос',
	'hierarchy-type-vote-poll_item'		=> 'Ответ в опросе',
	'hierarchy-type-eshop-order'		=> 'Заказ в интернет-магазине',
	'hierarchy-type-eshop-order_item'	=> 'Наименование заказа в интернет-магазине',
	'hierarchy-type-eshop-order_status'	=> 'Статус заказа в интернет-магазине',
	'hierarchy-type-eshop-address'		=> 'Адрес доставки',
	'hierarchy-type-forum-conf'		=> 'Конференция форума',
	'hierarchy-type-forum-topic'		=> 'Топик в форуме',
	'hierarchy-type-forum-message'		=> 'Сообщение в форуме',
	'hierarchy-type-comments-comment'	=> 'Комментарий',
	'hierarchy-type-updatesrv-license'	=> 'Лицензия UMI.CMS',
	'hierarchy-type-updatesrv-license_type'	=> 'Тип лицензии UMI.CMS',
	'hierarchy-type-banners-banner'		=> 'Баннер',
	'hierarchy-type-banners-place'		=> 'Место показа баннера',
	'hierarchy-type-dispatches-dispatch'	=> 'Рассылка',
	'hierarchy-type-dispatches-release'	=> 'Выпуск рассылки',
	'hierarchy-type-dispatches-message'	=> 'Сообщение рассылки',
	'hierarchy-type-dispatches-subscriber'	=> 'Подписчик на рассылку',
	'hierarchy-type-catalog-matrix'		=> 'Матрица подбора',
	'hierarchy-type-catalog-question'	=> 'Вопрос в матрице подбора',
	'hierarchy-type-catalog-answer'		=> 'Ответ на вопрос в матрице подбора',
	'hierarchy-type-users-author'		=> 'Автор',
	'hierarchy-type-content-ticket'		=> 'Заметка на сайте',
	'hierarchy-type-photoalbum-album'	=> 'Фотоальбом',
	'hierarchy-type-photoalbum-photo'	=> 'Фотография',
	'hierarchy-type-faq-project'		=> 'Проекты в FAQ',
	'hierarchy-type-faq-category'		=> 'Категории в FAQ',
	'hierarchy-type-faq-question'		=> 'Вопросы в FAQ',
	'hierarchy-type-filemanager-shared_file'	=> 'Скачиваемый файл',
	'hierarchy-type-eshop-store'		=> 'Склад в интернет-магазине',
	'hierarchy-type-eshop-store_relation'	=> 'Товар на складе интернет-магазина',
	'hierarchy-type-eshop-discount_card'	=> 'Дисконтная карта',
	'hierarchy-type-eshop-discount'		=> 'Скидка в интернет-магазине',
	'hierarchy-type-blogs-blog'		=> 'Блог',
	'hierarchy-type-blogs-blog_privacy'	=> 'Степень приватности блога',
	'hierarchy-type-blogs-blog_comment'	=> 'Комментарий к сообщению блога',
	'hierarchy-type-blogs-blog_message'	=> 'Сообщение блога',
	'hierarchy-type-eshop-payment_transaction'	=> 'Платежная транзакция',
	'hierarchy-type-eshop-payment_transaction_status'	=> 'Статус платежной транзакции',
	'hierarchy-type-webforms-form'		=> 'Форма обратной связи',
	'hierarchy-type-webforms-template'	=> 'Шаблон письма',
	'hierarchy-type-webforms-address'	=> 'Список адресов',
	"hierarchy-type-eshop-global-discount" => "Глобальная скидка в интернет магазине",
	'hierarchy-type-blogs20-blog' => 'Блог',
	'hierarchy-type-blogs20-comment' => 'Комментарий блога',
	'hierarchy-type-users-avatar'			=> 'Аватар пользователя',
	'hierarchy-type-blogs20-post'			=> 'Пост блога',
	'hierarchy-type-eshop-currency'			=> 'Валюта в интернет магазине',
	'hierarchy-type-webforms-page'			=> 'Страница с формой обратной связи',

	"field-project-id"		=> "Идентификатор проекта",
	"field-secret-key"		=> "Секретный ключ",
	"field-owner-id"		=> "Идентификатор владельца",
	"field-filemanager"		=> "Файловый менеджер",
	"field-filemanager-directory" => "Доступные директории (для файлового менеджера elFinder)",
	"field-prefix"			=> "Префикс",
	"field-is_active"		=> "Активность",
	"field-name"			=> "Название",
	'field-min_discount_order_total'	=> 'Минимальный размер заказа',
	'field-max_discount_order_total'	=> 'Максимальный размер заказа',
	'field-preffered_currency'			=> 'Предпочитаемая валюта',
	'field-age'				=> 'Возраст',
	'field-gender'				=> 'Пол',
	'field-geo_targeting_is_active'		=> 'Гео-таргетинг включен',
	'field-avatar'				=> 'Аватарка',
	'field-url'				=> 'Url страницы',
	'field-rss_type'			=> 'Тип',
	'field-news_rubric'			=> 'Раздел публикаций',
	'field-anons_pic'			=> 'Картинка для анонса',
	'field-publish_pic'			=> 'Картинка для публикации',
	'field-customer_comments'		=> 'Пометки покупателя',
	'field-default_type_id'			=> 'default_type_id',
	'field-seo_prefix'			=> 'seo_prefix',
	'field-trans'				=> 'Транзитный Id',
	'field-proizvoditel'			=> 'Производитель',
	'field-predyduwaya_cena'		=> 'Предыдущая цена',
	'field-specialnaya_cena'		=> 'Специальная цена',
	'field-fiksirovannaya_cena'		=> 'Фиксированная цена',
	'field-opisanie'			=> 'Описание товара',
	'field-soputstvuyuwie_tovary'		=> 'Сопутствующие товары',
	'field-polosa_tehnologij'		=> 'Полоса технологий',
	'field-izobrazhenie'			=> 'Изображение',
	'field-bolshoe_izobrazhenie'		=> 'Большое изображение',
	'field-id_name'				=> 'ID статуса',
	'field-tip_igrovoj_pristavki'		=> 'Тип игровой приставки',
	'field-komplekt_postavki'		=> 'Комплект поставки',
	'field-tip_karty_pamyati'		=> 'Тип карты памяти',
	'field-razemy_tip'			=> 'Разъемы (тип)',
	'field-cvet_korpusa'			=> 'Цвет корпуса',
	'field-garantiya'			=> 'Гарантия',
	'field-tranzitnyj_id'			=> 'Транзитный ID',
	'field-special_naya_cena'		=> 'Специальная цена',
	'field-bol_shoe_izobrazhenie'		=> 'Большое изображение',
	'field-yes_or_no'			=> 'Да или нет?',
	'field-country'				=> 'Страна',
	'field-city'				=> 'Город',
	'field-post_index'			=> 'Почтовый индекс',
	'field-address'				=> 'Адрес',
	'field-phone'				=> 'Номер телефона для контрольного звонка',
	'field-codename'			=> 'Идентефикатор версии',
	'field-ot_baldi'			=> 'Какое-то поле',
	'field-my_house'			=> 'Фотка моего дома',
	'field-site_link'			=> 'Ссылка на сайт',
	'field-company_logo'			=> 'Логoтип фирмы',
	'field-elements_links'			=> 'Ссылки на элементы',
	'field-kartinochka'			=> 'Картиночка',
	'field-objektiki'			=> 'Объектики',
	'field-currency_id'			=> 'Код валюты',
	'field-currency'			=> 'Валюта',
	'field-rate'				=> 'Курс',
	'field-model'				=> 'Модель товара',
	'field-isbn'				=> 'ISBN',
	'field-author'				=> 'Автор',
	'field-publisher'			=> 'Издатель',
	'field-year'				=> 'Год',
	'field-series'				=> 'Серия',
	'field-nazvanie'			=> 'Название',
	'field-media'				=> 'Носитель',
	'field-starring'			=> 'Актеры',
	'field-director'			=> 'Режиссер',
	'field-original_name'			=> 'Оригинальное название',
	'field-store'				=> 'Количество на складе',
	'field-quality_value'			=> 'Значение',
	'field-to_order'			=> 'на заказ (при отсутствии на складе)',
	'field-typePrefiks'			=> 'префикс',
	'field-place'				=> 'Место показа',
	'field-hall'				=> 'Зал',
	'field-date'				=> 'Дата выпуска',
	'field-premier'				=> 'Премьера',
	'field-for-kids'			=> 'для детей',
	'field-hall_plan'			=> 'План зала',
	'field-hall_part'			=> 'Места',
	'field-worldRegion'			=> 'Часть света',
	'field-region'				=> 'Курорт или город',
	'field-days'				=> 'Количество дней',
	'field-dataTour'			=> 'Даты заездов',
	'field-hotel_stars'			=> 'Звезды',
	'field-room'				=> 'Тип комнаты',
	'field-meal'				=> 'Тип питания',
	'field-included'			=> 'Что включено в стоимость тура',
	'field-transport'			=> 'Транспорт',
	'field-plus'				=> 'Процент (+)',
	'field-is_cbrf'				=> 'Использовать CBRF',
	'field-deliveryIncluded'		=> 'Доставка',
	'field-price_min'			=> 'Минимальная цена',
	'field-price_max'			=> 'Максимальная цена',
	'field-sales_notes'			=> 'Особенности товара',
	'field-color'				=> 'Цвет',
	'field-weight'				=> 'Вес',
	'field-power'				=> 'мощность',
	'field-description'			=> 'Описание',
	'field-'				=> 'Продолжительность',
	'field-descr'				=> 'Описание',
	'field-order_price'			=> 'Сумма счета',
	'field-elements'			=> 'Разделы каталога',
	'field-hex'				=> 'Цветовой код',
	'field-zhanr'				=> 'Жанр',
	'field-kratkoe_opisanie'		=> 'Краткое описание',
	'field-format_nositelya'		=> 'Формат носителя',
	'field-god_vypuska'			=> 'Год выпуска',
	'field-vozrastnoe_ogranichenie_na_prosmotr'	=> 'Возрастное ограничение на просмотр',
	'field-vid'				=> 'Вид',
	'field-okras'				=> 'Окрас',
	'field-tip_shersti'			=> 'Тип шерсти',
	'field-ves'				=> 'Вес',
	'field-pol'				=> 'Пол',
	'field-kolichestvo_lap'			=> 'Количество лап',
	'field-dlina_usov'			=> 'Длина усов',
	'field-maksimalnaya_skorost'		=> 'Максимальная скорость',
	'field-obem_legkih'			=> 'Объем легких',
	'field-razmah_lap_v_bege'		=> 'Размах лап в беге',
	'field-harakter'			=> 'Характер',
	'field-druzhelyubnost'			=> 'Дружелюбность',
	'field-kulinarnye_predpochteniya'	=> 'Кулинарные предпочтения',
	'field-integriruemost_v_koleso'		=> 'Интегрируемость в колесо',
	'field-photo'				=> 'Фотография',
	'field-diametr_kolesa'			=> 'Диаметр колеса',
	'field-type'				=> 'Тип',
	'field-s_shipami'			=> 'С шипами',
	'field-recommend'			=> 'Рекомендуем',
	'field-lock_cancel'			=> 'Статус блокирует отмену заказа',
	'field-lock_payment'			=> 'Статус блокирует оплату заказа',
	'field-destination_address'		=> 'Адрес доставки',
	'field-sender_ip'			=> 'IP-адрес отправителя',
	'field-from_email_template'		=> 'Адрес от',
	'field-from_template'			=> 'Имя от',
	'field-subject_template'		=> 'Тема письма',
	'field-master_template'			=> 'Шаблон тела письма',
	'field-autoreply_from_email_template'	=> 'Адрес отправителя',
	'field-autoreply_from_template'		=> 'Имя отправителя',
	'field-autoreply_subject_template'	=> 'Тема',
	'field-autoreply_template'		=> 'Тело',
	'field-form_id'				=> 'Идентификатор формы',
	'field-address_description'		=> 'Описание',
	'field-address_list'			=> 'Адреса',
	'field-fname'				=> 'Имя',
	'field-father_name'			=> 'Отчество',
	'field-lname'				=> 'Фамилия',
	'field-e-mail'				=> 'E-mail',
	'field-time_targeting_is_active'	=> 'Time-таргетинг включен',
	'field-time_targeting_by_month_days'	=> 'По числам месяца',
	'field-time_targeting_by_month'		=> 'По месяцам',
	'field-time_targeting_by_week_days'	=> 'По дням недели',
	'field-time_targeting_by_hours'		=> 'По времени суток',
	'field-title'				=> 'Поле TITLE',
	'field-h1'				=> 'Поле H1',
	'field-meta_keywords'			=> 'Поле meta KEYWORDS',
	'field-meta_descriptions'		=> 'Поле meta DESCRIPTIONS',
	'field-content'				=> 'Контент',
	'field-menu_pic_ua'			=> 'Изображение неактивного раздела',
	'field-menu_pic_a'			=> 'Изображение активного раздела',
	'field-header_pic'			=> 'Изображение для заголовка',
	'field-robots_deny'			=> 'Запретить индексацию поисковиками',
	'field-social_categories_vkontakte'			=> 'Категория ВКонтакте',
	'field-show_submenu'			=> 'Показывать подменю',
	'field-is_expanded'			=> 'Меню всегда развернуто',
	'field-is_unindexed'			=> "Исключить из поиска",
	'field-login'				=> 'Логин',
	'field-password'			=> 'Пароль',
	'field-groups'				=> 'Группы пользователей',
	'field-readme'				=> 'Описание',
	'field-anons'				=> 'Анонс',
	'field-source'				=> 'Источник',
	'field-source_url'			=> 'URL источника',
	'field-publish_time'			=> 'Дата публикации',
	'field-begin_time'			=> 'Дата начала активности',
	'field-finish_time'			=> 'Дата завершения активности',
	'field-end_time'			=> 'Дата завершения скидки',
	'field-subjects'			=> 'Входит в сюжеты',
	'field-price_item'			=> 'Цена за единицу товара',
	'field-price_total'			=> 'Цена итоговая',
	'field-count'				=> 'Количество ответов',
	'field-discount_size'			=> 'Размер скидки',
	'field-catalog_relation'		=> 'Ссылка на товар',
	'field-items'				=> 'Наименования',
	'field-status'				=> 'Состояние',
	'field-order_time'			=> 'Дата заказа',
	'field-admin_comments'			=> 'Пометки администратора',
	'field-is_closed'			=> 'Голосование закрыто',
	'field-question'			=> 'Вопрос',
	'field-answers'				=> 'Ответы',
	'field-total_count'						=> 'Всего проголосовало',
	'field-cena'							=> 'Цена',
	'field-orders_refs'						=> 'Заказы',
	'field-delivery_address'				=> 'Адрес доставки',
	'field-delivery_addresses'				=> 'Адреса доставки',
	'field-message'							=> 'Сообщение',
	'field-activate_code'					=> 'Код активации',
	'field-is_activated'					=> 'Активирован',
	'field-domain_name'						=> 'Домен',
	'field-ip'								=> 'ip',
	'field-license_type'					=> 'Тип лицензии',
	'field-owner_lname'						=> 'Фамилия',
	'field-owner_fname'						=> 'Имя',
	'field-owner_mname'						=> 'Отчество',
	'field-owner_email'						=> 'E-mail',
	'field-keycode'							=> 'Лицензионный ключ',
	'field-gen_time'						=> 'Дата создания',
	'field-id'								=> 'ID',
	'field-views_count'						=> 'Количество показов',
	'field-clicks_count'					=> 'Количество переходов',
	'field-max_views'						=> 'Максимальное количество показов',
	'field-tags'							=> 'Теги',
	'field-is_active'						=> 'Активен',
	'field-view_pages'						=> 'Страницы, на которых показывать баннер',
	'field-not_view_pages'					=> 'Страницы, на которых не показывать баннер',
	'field-image'							=> 'Изображение',
	'field-open_in_new_window'				=> 'Открывать в новом окне',
	'field-width'							=> 'Ширина',
	'field-height'							=> 'Высота',
	'field-alt'								=> 'Альтернативный текст',
	'field-swf'								=> 'Флеш-ролик',
	'field-swf_quality'						=> 'Качество ролика',
	'field-html_content'					=> 'HTML-содержание',
	'field-show_till_date'					=> 'Дата окончания показа',
	'field-poll_rel'						=> 'Указатель на опрос',
	'field-is_show_rand_banner'				=> 'Показ случайного баннера',
	'field-show_start_date'					=> 'Дата начала показа',
	'field-disp_last_release'				=> 'Дата последнего выпуска',
	'field-disp_description'				=> 'Описание',
	'field-disp_reference'					=> 'Ссылка на рассылку',
	'field-header'							=> 'Заголовок',
	'field-body'							=> 'Тело сообщения',
	'field-attach_file'						=> 'Прикрепленный файл',
	'field-release_reference'				=> 'Ссылка на выпуск',
	'field-uid'								=> 'Пользователь',
	'field-subscriber_dispatches'			=> 'Подписан на рассылки',
	'field-subscribe_date'					=> 'Дата подписки',
	'field-related_items'					=> 'Подходящие товары',
	'field-question_txt'					=> 'Текст вопроса',
	'field-answers_rel'						=> 'Список ответов',
	'field-per_page'						=> 'Количество выводимых результатов',
	'field-goods'							=> 'Товары',
	'field-questions_rel'					=> 'Список вопросов',
	'field-is_registrated'					=> 'Зарегистрирован',
	'field-user_id'							=> 'Владелец',
	'field-nickname'						=> 'Ник',
	'field-email'							=> 'E-mail',
	'field-author_id'						=> 'Автор',
	'field-x'								=> 'X',
	'field-y'								=> 'Y',
	'field-create_time'						=> 'Дата создания',
	'field-answer'							=> 'Ответ на вопрос',
	'field-fs_file'							=> 'Скачиваемый файл',
	'field-downloads_counter'				=> 'Количество загрузок',
	'field-user_dock'						=> 'Пользовательская панель',
    'field-page_tags'						=> 'Показывать на страницах с тэгами',
	'field-user_tags'						=> 'Показывать пользователям с тэгами',
	'field-rate_voters'						=> 'Количество проголосовавших',
	'field-rate_sum'						=> 'Сумма баллов',
	'field-amount'							=> 'Количество на складе',
	'field-store_id'						=> 'Указатель на склад',
	'field-store_amounts'					=> 'Наличия на складах',
	'field-proc'							=> 'Процент скидки',
	'field-start_time'						=> 'Дата начала действия скидки',
	'field-code'							=> 'Код',
	'field-price'							=> 'Цена',
	'field-ignore_discounts'				=> 'Игнорировать скидки',
	'field-subscribed_pages'				=> 'Подписки на изменения',
	'field-is_online'						=> 'Пользователь on-line',
	'field-privacy'							=> 'Приватность',
	'field-sid'								=> 'sid',
	'field-prvlist_friends'					=> 'Мои друзья',
	'field-lmessage_time'					=> 'Дата добавления последнего сообщения',
	'field-lcomment_time'					=> 'Дата добавления последнего комментария',
	'field-privacy_forpostonly'				=> 'Приватность действует только на комментирование (не на просмотр)',
	'field-topics_count'					=> 'Количество топиков',
	'field-messages_count'					=> 'Количество сообщений',
	'field-last_post_time'					=> 'Дата последнего добавления',
	'field-last_request_time'				=> 'Время последнего обращения',
	'field-rated_pages'						=> 'Рейтингованные страницы',
	'field-sid_transaction'					=> 'Строковый идентификатор',
	'field-sid_eshoporder_status'			=> 'Соотнесенный статус заказа',
	'field-rel_transactionstatus'			=> 'Статус транзакции',
	'field-date_created'					=> 'Дата создания',
	'field-inited_whom'						=> 'Инициализатор транзакции',
	'field-rel_eshoporder'					=> 'Оплачиваемый заказ',
	'field-initprice'						=> 'Сумма заказа',
	'field-text_request'					=> 'Подробности запроса',
	'field-method_engine'					=> 'Transaction engine',
	'field-date_answered'					=> 'Дата получения результата',
	'field-text_answer'						=> 'Подробности получения результата',
	'field-date_validated'					=> 'Дата проверки результата',
	'field-text_validated'					=> 'Подробности проверки результата',
	'field-date_conseq'						=> 'Дата проверки',
	'field-text_conseq'						=> 'Подробности проверки',
	'field-city_targeting_city'				=> 'Город',
	'field-city_targeting_is_active'		=> 'Геотаргетинг включен',
	'field-news_relation'					=> 'Связано с лентой новостей',
	'field-ignore-banner-subpages'			=> 'Игнорировать подстраницы',
	'field-publish-status'					=> 'Статус публикации',
	'field-type-int'						=> 'Число',
	'field-type-string'						=> 'Строка',
	'field-type-text'						=> 'Простой текст',
	'field-type-relation'					=> 'Выпадающий список',
	'field-type-relation-multiple'			=> 'Выпадающий список с множественным выбором',
	'field-type-file'						=> 'Файл',
	'field-type-img_file'					=> 'Изображение',
	'field-type-swf_file'					=> 'Флеш-ролик',
	'field-type-date'						=> 'Дата',
	'field-type-boolean'					=> 'Кнопка-флажок',
	'field-type-wysiwyg'					=> 'HTML-текст',
	'field-type-password'					=> 'Пароль',
	'field-type-tags-multiple'				=> 'Теги',
	'field-type-symlink-multiple'			=> 'Ссылка на дерево',
	'field-type-price'						=> 'Цена',
	'field-type-float'						=> 'Число с точкой',
	'field-type-optioned'					=> 'Составное',
	'field-type-counter'					=> 'Счетчик',
	'field-type-video'						=> 'Видео',
	'field-expiration-date'					=> 'Дата окончания актуальности',
	'field-notification-date'				=> 'Дата предупреждения об окончании актуальности',
	'field-publish_comments'				=> 'Комментарий к публикации',
	'field-date-empty'						=> 'Никогда',
	'field-form_sending_time'				=> 'Время отправки',
	'field-auto_reply'						=> 'Автоответ',
	'field-body'							=> 'Текст сообщения',
	'field-userpic'							=> 'Загрузить свой',
	'field-picture'							=> 'Картинка',
	'field-is_hidden'						=> 'Скрытая',
	'field-forced_subscribers'				=> 'Принудительно подписанные пользователи:',
	'field-msg_date'						=> 'Дата сообщения',
	'field-short_body'						=> 'Краткий текст сообщения',
	'field-new_relation'					=> 'Ссылка на новость',
	'field-publish_status_id'				=> 'id статуса',
	'field-locktime'						=> 'Время блокировки',
	'field-lockuser'						=> 'Блокирующий пользователь',
	'field-last_message'					=> 'Последнее сообщение',
	'field-friendlist'						=> 'Список друзей',
	'field-only_for_friends'				=> 'Видимо только друзьям',
	'field-user_settings_data'				=> 'Настройки пользователя',
	'field-opinion'							=> 'Как вам сайт?',
	'field-expiration_date'					=> 'Дата снятия с публикации',
	'field-notification_date'				=> 'Дата уведомления',
	'field-publish_status'					=> 'Статус публикации',
	'field-faq_publish_time' => 'Дата публикации',
	'field-global-discount-size'			=> 'Сумма глобальной скидки',
	'field-eshop_order_currency'			=> 'Валюта в интернет магазине',
	'field-currency_exchange_rate'			=> 'Курс обмена',
	'field-eshop_order_currency_total'		=> 'Сумма в валюте заказа',
	'field-sending_time'					=> 'Дата отправки',
	'field-use_in_eshop'					=> 'Использовать в интернет-магазине',
	'field-eshop_currency_letter_code'		=> 'Код валюты',
	'field-eshop_currency_exchange_rate'	=> 'Курс обмена',
	'field-eshop-currency-symbol'			=> 'Сокращенное название валюты',
	'field-photo-s'							=> 'Фото',
	'field-strana_prozhivaniya'				=> 'Страна проживания',
	'field-gorod_prozhivaniya'				=> 'Город проживания',
	'field-adres_prozhivaniya'				=> 'Адрес проживания',
	'field-restriction-email'				=> 'E-mail',
	'field-restriction-http-url'			=> 'Web-адрес',
	'field-restriction-system-domain'		=> 'Домен системы',
	'field-restriction-discount'			=> 'Размер скидки',
	'field-restriction-object-type'			=> 'Тип данных',
	'field-loginza'							=> 'Провайдер регистрации(через Loginza)',
	'field-common-quantity'					=> 'Общее количество на складах',
	'field-referer'							=> 'Адрес, с которого пришел пользователь',
	'field-target'							=> 'Адрес, на который пришел пользователь',
	'field-register_date'					=> 'Дата регистрации',

	'fields-group-short_info'		=> 'Персональная информация',
	'fields-group-more_info'		=> 'Дополнительная информация',
	'fields-group-common'			=> 'Основные параметры',
	'fields-group-view_params'		=> 'Параметры показа',
	'fields-group-time_targeting'		=> 'Time-таргетинг',
	'fields-group-menu_view'		=> 'Отображение в меню',
	'fields-group-more_params'		=> 'Дополнительные параметры',
	'fields-group-idetntify_data'		=> 'Идентификационные данные',
	'fields-group-item_props'		=> 'Свойства публикации',
	'fields-group-subjects_block'		=> 'Сюжеты',
	'fields-group-order_item_props'		=> 'Свойства наименования',
	'fields-group-order_props'		=> 'Свойства заказа',
	'fields-group-comments'			=> 'Пометки',
	'fields-group-common_props'		=> 'Общие свойства',
	'fields-group-poll_props'		=> 'Свойства опроса',
	'fields-group-status_props'		=> 'Свойства статусы',
	'fields-group-delivery_address'		=> 'Адрес для доставки',
	'fields-group-topic_props'		=> 'Свойства топика',
    'fields-group-message_props'        =>    'Свойства сообщения',
	'fields-group-comment_props'		=> 'Свойства комментария',
	'fields-group-license_info'		=> 'Свойства лицензии',
	'fields-group-owner_info'		=> 'Информация о клиенте',
	'fields-group-currency_props'		=> 'Свойства валюты',
	'fields-group-view_pages'		=> 'Разделы отображения',
	'fields-group-banner_custom_props'	=> 'Индивидуальные параметры баннера',
	'fields-group-redirect_props'		=> 'Параметры перехода',
	'fields-group-props'			=> 'Свойства',
	'fields-group-grp_disp_props'		=> 'Свойства рассылки',
	'fields-group-grp_disp_release_props'	=> 'Свойства выпуска рассылки',
	'fields-group-grp_disp_msg_props'	=> 'Свойства сообщения рассылки',
	'fields-group-grp_sbs_props'		=> 'Информация о подписчике',
	'fields-group-grp_disp_msg_extended'	=> 'Дополнительные свойства',
	'fields-group-grp_sbs_extended'		=> 'Параметры подписки',
	'fields-group-matrix_props'		=> 'Свойства матрицы',
	'fields-group-photo_props'		=> 'Свойства фотографии',
	'fields-group-album_props'		=> 'Свойства фотоальбома',
	'fields-group-svojstva_gruppy_polzovatelej'		=> 'Свойства группы пользователей',
	'fields-group-fs_file_props'		=> 'Свойства файла',
	'fields-group-news_images'		=> 'Изображения новости',
	'fields-group-dopolnitelno'		=> 'Дополнительно',
	'fields-group-rate_props'		=> 'Свойства рейтинга',
	'fields-group-rate_voters'		=> 'Количество проголосовавших',
	'fields-group-store_props'		=> 'Свойства склада',
	'fields-group-cenovye_svojstva'		=> 'Ценовые свойства',
	'fields-group-other_proerties'		=> 'Характеристики хомячка',
	'fields-group-pictures'			=> 'Изображения',
	'fields-group-descr_grp'		=> 'Описание товара',
	'fields-group-parametry_aksessuara'	=> 'Параметры аксессуара',
	'fields-group-recommend'		=> 'Рекомендуем',
	'fields-group-common_group'		=> 'Общие параметры',
	'fields-group-privatnost'		=> 'Приватность',
	'fields-group-identity'			=> 'identity',
	'fields-group-transaction_status_props'	=> 'Свойства',
	'fields-group-transaction_props'	=> 'Свойства транзакции',
	'fields-group-trans_init'		=> 'Инициализация',
	'fields-group-trans_deliver'		=> 'Доставка',
	'fields-group-prelim'			=> 'Результат',
	'fields-group-final'			=> 'Подтверждение',
	'fields-group-consequences'		=> 'Послесловие',
	'fields-group-city_targeting'		=> 'Геотаргетинг',
	'fields-group-SendingData'		=> 'Данные для отправки',
	'fields-group-Templates'		=> 'Письмо',
	'fields-group-Binding'			=> 'Привязка',
	'fields-group-list'			=> 'Список',
	'fields-group-short_user_info'		=> 'Краткая информация',
	'fields-group-advanced'			=> 'Дополнительные',
	'fields-group-userpic'			=> 'Юзерпик',
	'fields-group-auto_reply'			=> 'Автоответ',
	'fields-group-svojstva_statusa_stranicy'			=> 'Свойства статуса страницы',
	'fields-group-locks'			=> 'Блокировка',
	'fields-group-privacy'			=> 'Настройки отображения',
	'fields-group-osnovnoe'			=> 'Основное',
	'fields-group-currency-props'		=> 'Свойства валюты',
	'fields-group-svojstva_publikacii' => 'Актуальность публикации',
	'fields-group-svojstva' 		=> 'Свойства',

	'perms-data-main' => 'Просмотр объектов',
    'perms-data-guides' => 'Управление справочниками',
	'perms-data-files' => 'Управление файлами',
	'perms-data-trash' => 'Мусорная корзина',
	'perms-data-types' => 'Управление шаблонами данных',

	'group-currency-props'		=> 'Свойства валюты',

	'min-discount-order-total'	=> 'Минимальная сумма заказа',
	'max-discount-order-total'	=> 'Максимальная сумма заказа',

	'global-discount-order-size'	=> 'Сумма глобальной скидки',
	'global-discount-end'		=> 'Дата окончания действия',
	'global-discount-start'		=> 'Дата начала действия',
	'global-discount-active-time'	=> 'Время действия скидки',

	'order-total-range'		=> 	'Диапазон суммы заказа',

	'eshop-order-currency'	=> 'Валюта в интернет магазине',
	'eshop-global-discount-proc'		=> 'Процент глобальной скидки',
	'eshop-currency'	=> 'Валюта в интернет магазине',
	'eshop-currency-letter-code'	=> 'Буквенный код',
	'eshop-currency-digit-code'		=> 'Цифровой код',
	'eshop-currency-exchange-rate'	=> 'Курс обмена',
	'eshop-order-currency-id'		=> 'Идентификатор валюты',
	"eshop-order-currency-exchange_rate"	=> "Курс обмена",
	"eshop-order-currency-total"		=> "Сумма в валюте заказа",

	'locktime'						=> 'Время начала блокировки',
	'lockuser'						=> 'Пользователь заблокировавший страницу',

	"date-empty-field"				=> "Никогда",

	'js-trash-empty' => 'Очистка корзины',
	'js-trash-empty-done' => 'Очистка корзины выполнена',
	'js-trash-empty-help' => 'Подождите, выполняется очистка...',
	'js-trash-toggle-log' => 'cкрыть/показать лог',
	'js-trash-ajaxerror' => 'Ошибка разбора данных',
	'js-trash-empty_stop' => 'Остановить',
	'js-trash-empty_ok' => 'Готово',
	'js-trash-empty_repeat' => 'Снова',
	'js-trash-deleted' => 'Удалено: ',

	'js-trash-confirm-title'			=> 'Очистка корзины',
	'js-trash-confirm-text'				=> 'Вы собираетесь очистить корзину. Это означает, что все страницы в корзине будут безвозвратно удалены.',
	'js-trash-confirm-cancel'			=> 'Отменить',
	'js-trash-confirm-ok'				=> 'Очистить',
	'js-trash-restore'					=> 'Восстановить',
	'js-data-add-field'					=> 'Добавить поле',
	'js-data-edit-field'				=> 'Сохранить',
	'js-view-guide-items'				=> 'Содержимое справочника',
	'js-type-edit-edit'					=> 'изменить',
	'js-type-edit-remove'				=> 'удалить',
	'js-type-edit-add_group'			=> 'Добавить группу',
	'js-type-edit-add_field'			=> 'Добавить поле',
	'js-type-edit-title'				=> 'Название',
	'js-type-edit-name'					=> 'Идентификатор',
	'js-type-edit-tip'					=> 'Подсказка',
	'js-type-edit-type'					=> 'Тип',
	'js-type-edit-restriction'			=> 'Формат значения',
	'js-type-edit-guide'				=> 'Справочник',
	'js-type-edit-visible'				=> 'Видимое',
	'js-type-edit-required'				=> 'Обязательное',
	'js-type-edit-indexable'			=> 'Индексируемое',
	'js-type-edit-filterable'			=> 'Фильтруемое',
	'js-type-edit-saving'				=> 'Сохранение',
	'js-type-edit-new_group'			=> 'Новая группа',
	'js-type-edit-new_field'			=> 'Новое поле',
	'js-type-edit-confirm_title'		=> 'Подтверждение удаления',
	'js-type-edit-confirm_text'			=> 'Если вы уверены, нажмите "Удалить" (действие необратимо).',

	'restriction-error-common'			=> 'Неверное значение',
	'restriction-error-discount-size'	=> 'Размер скидки должен находиться в диапозоне от 0 до 100%',
	'restriction-error-domain-id'		=> 'Домена с таким id нет в системе',
	'restriction-error-email'			=> 'Неверный e-mail',
	'restriction-error-object-type'		=> 'Должен быть передан существующий тип данных',

	'error-value-required'				=> 'Поле "%s" обязательно должно быть заполнено',
	'error-max_filesize'				=> 'Файл превышает максимально допустимый размер',
	'error-max_img_filesize'			=> 'Изображение превышает максимально допустимый размер',
	'error-files_quota_exceeded'		=> 'Вы превысили максимально допустимый объем дискового пространства'

);


	class ulangStream extends umiBaseStream {
		protected $scheme = "ulang", $prop_name = NULL;
		protected static $i18nCache = Array();

		public function stream_open($path, $mode, $options, $opened_path) {
			static $cache = array();
			$info = parse_url($path);
			
			$path = trim(getArrayKey($info, 'host') . getArrayKey($info, 'path'), "/");
			
			if(substr($path, -5, 5) == ':file') {
				$dtdContent = $this->getExternalDTD(substr($path, 0, strlen($path) - 5));
				return $this->setData($dtdContent);
			}
			
			if(strpos(getArrayKey($info, 'query'), 'js') !== false) {
				$mode = 'js';
			} else if(strpos($path, 'js') !== false) {
				$mode = 'js';
				$path = substr($path, 0, strlen($path) - 3);
			} else $mode = 'dtd';
			
			if($mode == 'js') {
				$buffer = outputBuffer::current();
				$buffer->contentType('text/javascript');
				$data = $this->generateJavaScriptLabels($path);
				return $this->setData($data);
			}
			
			if(isset($cache[$path])) {
				$data = $cache[$path];
			} else {
				$i18nMixed = self::loadI18NFiles($path);
				$data = $cache[$path] = $this->translateToDTD($i18nMixed);
			}
			return $this->setData($data);
		}

		protected function translateToDTD($phrases) {
			$dtd = "<!ENTITY quote '&#34;'>\n";
			$dtd .= "<!ENTITY nbsp '&#160;'>\n";
			$dtd .= "<!ENTITY middot '&#183;'>\n";
			$dtd .= "<!ENTITY reg '&#174;'>\n";
			$dtd .= "<!ENTITY copy '&#169;'>\n";
			$dtd .= "<!ENTITY raquo '&#187;'>\n";
			$dtd .= "<!ENTITY laquo '&#171;'>\n";
			
			$request_uri = getServer('REQUEST_URI');
			$request_uri = htmlspecialchars($request_uri);

			foreach($phrases as $ref => $phrase) {				
				$phrase = $this->protectEntityValue($phrase);
				$dtd .= "<!ENTITY {$ref} \"{$phrase}\">\n";
			}

			return $dtd;
		}
		
		protected function isRestrictedRef($ref) {
			$arr = Array('field-', 'object-type-', 'hierarchy-type-', 'fields-group-', 'field-type-');
			
			for($i = 0; $i < sizeof($arr); $i++) {
				if(substr($ref, 0, strlen($arr[$i])) == $arr[$i]) {
					return true;
				}
			}
			return false;
		}

		protected function protectEntityValue($val) {
			$from = array('&', '"', '%');
			$to = array('&amp;', '&quote;', '&#037;');

			$val = str_replace($from, $to, $val);

			return $val;
		}

		protected static function parseLangsPath($path) {
			$protocol = "ulang://";
			if(substr($path, 0, strlen($protocol)) == $protocol) {
				$path = substr($path, strlen($protocol));
			}
			$path = trim($path, "/");
			return explode("/", $path);
		}

		protected static function loadI18NFiles($path) {
global $i18n;
			static $current_module = "content", $c = 0;

			if(!$current_module) {
				$controller = cmsController::getInstance();
				$current_module = $controller->getCurrentModule();
			}

			$i18nCache = self::$i18nCache;

			$require_list = self::parseLangsPath($path);

			$lang_prefix = self::getLangPrefix();

			$i18nMixed = Array();

			if(!in_array($current_module, $require_list)) {
				$require_list[] = $current_module;
			}

			$sz = sizeof($require_list);
			for($i = 0; $i < $sz; $i++) {
				$require_name = $require_list[$i];
				
				if($require_name == false) continue;

				$filename_primary = "i18n." . $lang_prefix . ".php";
				$filename_secondary = "i18n.php";

				$folder = ($require_name == "common") ? "/classes/modules/" : "/classes/modules/" . $require_name . "/";
				$folder = CURRENT_WORKING_DIR . $folder;

				$path_primary = $folder . $filename_primary;
				$path_secondary = $folder . $filename_secondary;

				if(array_key_exists($require_name, $i18nCache)) {
					$i18n = $i18nCache[$require_name];
				} else {
					if(file_exists($path_primary)) {
						include $path_primary;
					} else if (file_exists($path_secondary)) {
						include $path_secondary;
					}
				}

				if(isset($i18n) && is_array($i18n)) {
					$i18nCache[$require_name] = $i18n;
					$i18nMixed = $i18n + $i18nMixed;
					unset($i18n);
				}
			}
			self::$i18nCache = $i18nCache;
			
			return $i18nMixed;
		}

		public static function getLabel($label, $path = false, $args = null) {
			static $cache = Array();
			static $langPrefix = false;
			if($langPrefix === false) {
				$langPrefix = self::getLangPrefix();
			}
			
			$lang_path = ($path == false) ? "common/data" : $path;

			if(isset($cache[$lang_path])) {
				$i18nMixed = $cache[$lang_path];
			} else {
				$i18nMixed = self::loadI18NFiles($lang_path);
				$cache[$lang_path] = &$i18nMixed;
			}
			if(isset($i18nMixed[$label])) {
				$res = $i18nMixed[$label];
			} elseif(!$path && strpos($label, 'module-') === 0) {
				$moduleName = str_replace('module-', '', $label);
				$res = self::getLabel($label, $moduleName, $args);
			} else {
				$res = "{$label}";
			}

			if(is_array($args) && sizeof($args) > 2) {
				$res = vsprintf($res, array_slice($args, 2));
			}

			return $res;
		}

		public static function getI18n($key, $pattern = "") {
			static $cache = Array();
			
			if(!$key) {
				return $key;
			}
			
			$lang_path = "common/data";
			$prefix = "i18n::";
			
			if(isset($cache[$lang_path])) {
				$i18nMixed = $cache[$lang_path];
			} else {
				$i18nMixed = self::loadI18NFiles($lang_path);
				$cache[$lang_path] = $i18nMixed;
			}

			$result = NULL;
			foreach($i18nMixed as $i => $v) {
				if($v == $key) {
					if($pattern) {
						if(substr($i, 0, strlen($pattern)) == $pattern) {
							$result = $prefix . $i;
							break;
						}
					} else {
						$result = $prefix . $i;
						break;
					}
				}
			}

			if(!is_null($result)) {
				$allowedPrefixes = Array(
					'object-type-',
					'hierarchy-type-',
					'field-',
					'fields-group-',
					'field-type-',
					'object-'
				);
				$allowed = false;
				$tmp_result = str_replace("i18n::", "", $pattern);
				foreach($allowedPrefixes as $pattern) {
					$pattern = $pattern;

					if(substr($tmp_result, 0, strlen($pattern)) == $tmp_result) {
						$allowed = true;
					}
				}
				if($allowed == false) {
					return NULL;
				}
			}
			return $result;
		}
		
		public static function getLangPrefix() { return "ru";
			static $ilang;
			if(!is_null($ilang)) {
				return $ilang;
			}
			
			$cmsController = cmsController::getInstance();
			$prefix = $cmsController->getCurrentLang()->getPrefix();
			
			if($cmsController->getCurrentMode() != "admin" && !defined('VIA_HTTP_SCHEME')) {
				return $ilang = checkInterfaceLang($prefix);
			}
			
			if(!is_null($ilang = getArrayKey($_POST, 'ilang'))) {
				$ilang = checkInterfaceLang($ilang);
				setcookie('ilang', $ilang, time() + 3600*24*31, '/');
				return $ilang;
			}

			if(!is_null($ilang = getArrayKey($_GET, 'ilang'))) {
				$ilang = checkInterfaceLang($ilang);
				setcookie('ilang', $ilang, time() + 3600*24*31, '/');
				return $ilang;
			}

			
			if(!is_null($ilang = getCookie('ilang'))) {
				$ilang = checkInterfaceLang($ilang);
				setcookie('ilang', $ilang, time() + 3600*24*31, '/');
				return $ilang;
			}
			
			return $ilang = checkInterfaceLang($prefix);
		}
		
		public function __construct() {
			parent::__construct();
		}
		
		public function __destruct() {}
		
		protected function generateJavaScriptLabels($path) {

			$i18n = self::loadI18NFiles($path);
			
			$regedit = regedit::getInstance();
			$modulesList = $regedit->getList('//modules');
			foreach($modulesList as $moduleName) {
				list($moduleName) = $moduleName;
				if (!isset($i18n['module-' . $moduleName])) $i18n['module-' . $moduleName] = self::getLabel('module-' . $moduleName, $moduleName);
			}

			$result = <<<INITJS
function getLabel(key, str) {if(setLabel.langLabels[key]) {var res = setLabel.langLabels[key];if(str) {res = res.replace("%s", str);}return res;} else {return "[" + key + "]";}}
function setLabel(key, label) {setLabel.langLabels[key] = label;}setLabel.langLabels = new Array();


INITJS;
			foreach($i18n as $i => $v) {
				if(substr($i, 0, 3) == "js-" || strpos($i, "module-") === 0) {
					$i = self::filterOutputString($i);
					$v = self::filterOutputString($v);
					$result .= "setLabel('{$i}', '{$v}');\n";
				}
			}
			umiBaseStream::$allowTimeMark = false;
			return $result;
		}
		
		protected function filterOutputString($string) {
			$from = array("\r\n", "\n", "'");
			$to = array("\\r\\n", "\\n", "\\'");
			$string = str_replace($from, $to, $string);
			return $string;
		}

		protected function getExternalDTD($path) {
			$cmsController = cmsController::getInstance();
			$prefix = $cmsController->getCurrentLang()->getPrefix();

			$info = getPathInfo($cmsController->getTemplatesDirectory() . $path);

			$left = getArrayKey($info, 'dirname') . '/' . getArrayKey($info, 'filename');
			$right = getArrayKey($info, 'extension');
			
			$primaryPath = $left . '.' . $prefix . '.' . $right;
			$secondaryPath = $left . '.' . $right;

			if(is_file($primaryPath)) {
				return file_get_contents($primaryPath);
			}
			
			if(is_file($secondaryPath)) {
				return file_get_contents($secondaryPath);
			}

			return '';
		}
	};


	class umiObjectProxy {
		protected $object;
		
		protected function __construct(umiObject $object) {
			$this->object = $object;
		}
		
		public function getId() {
			return $this->object->getId();
		}
		
		public function setName($name) {
			$this->object->setName($name);
		}
		
		public function getName() {
			return $this->object->getName();
		}
		
		public function setValue($propName, $value) {
			return $this->object->setValue($propName, $value);
		}
		
		public function getValue($propName) {
			return $this->object->getValue($propName);
		}
		
		public function isFilled() {
			return $this->object->isFilled();
		}
		
		public function getObject() {
			return $this->object;
		}
		
		public function commit() {
			return $this->object->commit();
		}
		
		public function delete() {
			$objects = umiObjectsCollection::getInstance();
			return $objects->delObject($this->getId());
		}
		
		public function __get($prop) {
			switch($prop) {
				case 'id':		return $this->getId();
				case 'name':	return $this->getName();
				default:		return $this->getValue($prop);
			}
		}
		
		public function __set($prop, $value) {
			switch($prop) {
				case 'name':	return $this->setName($value);
				default:		return $this->setValue($prop, $value);
			}
		}
		
		public function __destruct() {
			$this->object->commit();
		}
	};


	interface iUmiObjectsExpiration {
		public function run();
		
		public function set($objectId, $expiration = false);
		public function clear($objectId);
	};


	class umiObjectsExpiration extends singleton implements iSingleton, iUmiObjectsExpiration {
		protected $defaultExpires = 86400;

		protected function __construct() {

		}

		public static function getInstance($c = NULL) {
			return parent::getInstance(__CLASS__);
		}

		public function run() {
			$time = time();

			$sql = <<<SQL
DELETE FROM `cms3_objects`
	WHERE `id` IN (
		SELECT `obj_id`
			FROM `cms3_objects_expiration`
				WHERE (`entrytime` + `expire`) >= '{$time}'
	)
SQL;
			l_mysql_query($sql);
		}

		public function set($objectId, $expires = false) {
			if($expires == false) {
				$expires = $this->defaultExpires;
			}
			$objectId = (int) $objectId;
			$expires = (int) $expires;
			$time = time();

			$sql = <<<SQL
REPLACE INTO `cms3_objects_expiration`
	(`obj_id`, `entrytime`, `expire`)
		VALUES ('{$objectId}', '{$time}', '{$expires}')
SQL;
			l_mysql_query($sql);

		}

		public function clear($objectId) {
			$objectId = (int) $objectId;

			$sql = <<<SQL
DELETE FROM `cms3_objects_expiration`
	WHERE `obj_id` = '{$objectId}'
SQL;
			l_mysql_query($sql);
		}
	};


	class HTTPOutputBuffer extends outputBuffer {
		protected
			$cleanEipAttributes = false,
			$charset		= 'utf-8',
			$contentType	= 'text/html',
			$headers		= array(),
			$headersSended	= false,
			$status			= '200 Ok',
			$options		= array(
				'compression' => true,
				'quick-edit' => true,
				'generation-time' => true,
				'send-stat-id' => true
			);

		public function __construct() {
			showWorkTime("buffer construct start",2);
			parent::__construct();
			showWorkTime("buffer before session start",2);
			session_start();
			showWorkTime("buffer after session start",2);
			$_SESSION['starttime']=time();
			$this->checkHTTPAuth();
			showWorkTime("buffer construct end",2);
		}

		public function send() {
			$this->sendHeaders();
			echo $this->buffer;
			$this->clear();
		}

		public function status($status = false) {
			if($status) $this->status = $status;
			return $this->status;
		}

		public function charset($charset = false) {
			if($charset) $this->charset = $charset;
			return $this->charset;
		}

		public function contentType($contentType = false) {
			if($contentType) $this->contentType = $contentType;
			return $this->contentType;
		}

		public function getHTTPRequestBody() {
			$putdata = fopen("php://input", "r");
			$data = "";

			while (!feof($putdata)) {
					$data .= fread($putdata, 1024);
			}
			fclose($putdata);

			return $data;
		}

		public function sendHeaders() {
			if($this->headersSended) {
				return true;
			} else if (headers_sent()) {
				return false;
			}

			if($this->status != '404 Not Found' and CALC_LAST_MODIFIED) $this->sendLastModified();
			$this->sendStatusHeader();

			$this->sendDefaultHeaders();

			foreach($this->headers as $header => $value) {
				$this->sendHeader($header, $value);
			}
			$this->headersSended = true;
		}

		public function end() {
			if(!DEBUG) @ob_clean();
			if(getArrayKey($this->options, 'quick-edit')) {
				umiTemplater::prepareQuickEdit();
			}

			if(CALC_E_TAG) $this->sendETag();
			$this->push($this->getCallTime());
			$this->send();
			exit;
		}

		public function option($key, $value = null) {
			if(is_null($value)) {
				return isset($this->options[$key]) ? $this->options[$key] : null;
			} else $this->options[$key] = $value;
		}


		public static function checkUrlSecurity($url) {
			return stripos($url, "javascript:") === false && stripos($url, "data:") === false && !preg_match('/^\/{2,}/i', $url);
		}

		public function redirect($url, $status = '301 Moved Permanently') {
			$maxLevels = 0;
			while (ob_get_level() && $maxLevels++ < 5) {
				@ob_end_clean();
			}

			if (!self::checkUrlSecurity($url)) {
				$this->status = "400 Bad Request";
				$this->sendStatusHeader();
				flush();
				exit('');
			}

			$this->status = $status;
			$this->sendStatusHeader();
			header('Location: ' . $url, true);
			flush();
			exit('');
		}

		public function header($name, $value = false) {
			if($value === false) {
				unset($this->headers[$name]);
				return NULL;
			} else {
				return $this->headers[$name] = $value;
			}
		}

		protected function checkHTTPAuth() {
			$login = getServer('PHP_AUTH_USER');
			$password = getServer('PHP_AUTH_PW');
			
			if (!$login && !$password && (($httpAuthorization = getServer("HTTP_AUTHORIZATION")) || ($httpAuthorization = getServer("REDIRECT_HTTP_AUTHORIZATION")))) {
				$httpAuthorization = explode(':', base64_decode(substr($httpAuthorization, 6)));
				if (count($httpAuthorization) == 2) {
					list($login, $password) = $httpAuthorization;
				}
			}

			if($login && $password) {
				$permissions = permissionsCollection::getInstance();
				if($permissions->isAuth() == false) {
					if($user = $permissions->checkLogin($login, $password)) {
						$permissions->loginAsUser($user->id);
					} else {
						$this->clear();
						$this->status('401 Unauthorized');
						$this->header('WWW-Authenticate: Basic realm="UMI.CMS"');
						$this->push('HTTP Authenticate failed');
						$this->end();
					}
				}
			}
		}

		protected function sendStatusHeader() {
			header("HTTP/1.1 " . $this->status);
			// Some servers close connection when we duplicate status header
			if((int)mainConfiguration::getInstance()->get("kernel", "send-additional-status-header")) {
				header("Status: " . $this->status, true);
			}
		}

		public function length() {
			ob_start();
			echo $this->buffer;
			$size = ob_get_length();
			ob_end_clean();
			return $size;
		}

		protected function sendDefaultHeaders() {
			$this->sendHeader('Content-type', $this->contentType . '; charset=' . $this->charset);
			$this->sendHeader('Content-length', $this->length());
			$this->sendHeader('Date', (gmdate("D, d M Y H:i:s") . " GMT"));
			$this->sendHeader('X-Generated-By', 'UMI.CMS');

			$version = regedit::getInstance()->getVal("//modules/autoupdate/system_version");
			$this->sendHeader('X-CMS-Version', $version);

			if(stristr(getServer('HTTP_USER_AGENT'), 'msie')) {
				$this->sendHeader('Cache-Control', 'no-store, no-cache, must-revalidate');
				$this->sendHeader('Pragma', 'no-cache');
        		$this->sendHeader('Expires', gmdate('D, d M Y H:i:s') . ' GMT');
        		$this->sendHeader('X-XSS-Protection', '0');
			} else {
				$this->sendHeader('Cache-Control', 'max-age=3600, private, must-revalidate');
			}

			if($this->option('send-stat-id')) {
				if (!getCookie('stat_id')) {
					setcookie('stat_id', session_id(), strtotime('+10 years'), "/");
				}
			}
		}

		protected function sendHeader($header, $value) {
			header("{$header}: {$value}");
		}

		protected function sendETag() {
			$this->sendHeader('E-tag', sha1($this->content()));
		}

		protected function sendLastModified() {
			$hierarchy = umiHierarchy::getInstance();
			$updateTime = $hierarchy->getElementsLastUpdateTime();
			if($updateTime) {
				$this->sendHeader('Last-Modified', (gmdate('D, d M Y H:i:s', $updateTime) . ' GMT'));
				$this->sendHeader('Expires', (gmdate('D, d M Y H:i:s', time() + 24 * 3600) . ' GMT'));

				if(function_exists("apache_request_headers")) {
					$request = apache_request_headers();
					if(isset($request['If-Modified-Since']) && (strtotime($request['If-Modified-Since']) >= ($updateTime) )) {
						$this->status('304 Not Modified');
						$this->sendHeader('Connection',  'close');
					}
				}
			}
		}

		protected function getCallTime() {
			$generationTime = round(microtime(true) - $this->invokeTime, 6);
			$config = mainConfiguration::getInstance();
			$showGenerateTime = (string) $config->get('kernel', 'show-generate-time');

			if (!$this->option('generation-time') || $showGenerateTime === "0") {
				return;
			}

			$generatedBy = '';
			$contentGenerator = parent::contentGenerator();
			if (is_string($contentGenerator) && strlen($contentGenerator)) {
				$generatedBy = ' by ' . $contentGenerator;
			}

			switch($this->contentType) {
				case 'text/html':
				case 'text/xml':
					return "<!-- This page generated in {$generationTime} secs{$generatedBy} -->";

				case 'application/javascript':
				case 'text/javascript':
					return "/* This page generated in {$generationTime} secs{$generatedBy} */";

				default: "";
			}
		}
	}



	class CLIOutputBuffer extends outputBuffer {
		public function send() {
			echo $this->buffer;
			$this->clear();
		}
	};


	abstract class objectProxyHelper {
		/**
			* Получить префикс класса скидки по id его объекта-типа
			* @param Integer $objectId id объекта типа скидки
			* @return String префикс класса скидки
		*/		
		public static function getClassPrefixByType($objectId) {
			static $cache = array();
			if(isset($cache[$objectId])) {
				return $cache[$objectId];
			}
			$classPrefix = '';
			
			$object = selector::get('object')->id($objectId);
			if($object instanceof iUmiObject) {
				if($object->class_name) {
					$classPrefix = $object->class_name;
				}
			} else {
				throw new coreException("Can't get class name prefix from object #{$objectId}");
			}
			
			return $cache[$objectId] = $classPrefix;
		}


		/**
			* Подключить файл, содержащий класс скидки
			* @param String $classPrefix префикс класса скидки
		*/
		public static function includeClass($classPath, $classPrefix) {
			static $included = array();

			if(in_array($classPath . $classPrefix, $included)) {
				return;
			} else {
				$included[] = $classPath . $classPrefix;
			}
			
			$config = mainConfiguration::getInstance();
			$filePath = $config->includeParam('system.default-module') . $classPath . $classPrefix . '.php';
			
			if(is_file($filePath) == false) {
				throw new coreException("Required source file {$filePath} is not found");
			}
			
			require $filePath;
		}
	};


	class selector implements IteratorAggregate {
		protected
			$mode, $permissions = null, $limit, $offset,
			$types = array(), $hierarchy = array(),
			$whereFieldProps = array(), $whereSysProps = array(),
			$orderSysProps = array(), $orderFieldProps = array(),
			$groupSysProps = array(), $groupFieldProps = array(),
			$executor, $result = null, $length = null,
			$options = array();

		protected static
			$modes = array('objects', 'pages'),
			$sysPagesWhereFields = array('id', 'name', 'owner', 'domain', 'lang', 'is_deleted',
				'is_active', 'is_visible', 'updatetime', 'is_default', 'template_id', '*'),
			$sysObjectsWhereFields = array('id', 'name', 'owner', 'guid', '*'),
			$sysPagesGroupFields = array('name', 'owner', 'domain', 'lang', 'is_deleted',
				'is_active', 'is_visible', 'updatetime', 'is_default', 'template_id'),
			$sysObjectsGroupFields = array('name', 'owner', 'guid'),
			$sysOrderFields = array('name', 'ord', 'rand', 'updatetime', 'id');

		public static function get($requestedType) {
			return new selectorGetter($requestedType);
		}

		public function __construct($mode) {
			$this->setMode($mode);
		}

		public function types($typeClass = false) {
			$this->checkExecuted();
			if($typeClass === false)
				return $this->types;
			else
				return $this->types[] = new selectorType($typeClass, $this);
		}

		public function where($fieldName) {
			$this->checkExecuted();
			if($fieldName == 'hierarchy') {
				if($this->mode == 'objects')
					throw new selectorException("Hierarchy filter is not suitable for \"objects\" selector mode");
				return $this->hierarchy[] = new selectorWhereHierarchy;
			}

			if($fieldName == 'permissions') {
				if($this->mode == 'objects')
					throw new selectorException("Permissions filter is not suitable for \"objects\" selector mode");
				if(is_null($this->permissions)) $this->permissions = new selectorWherePermissions;
				return $this->permissions;
			}

			if(in_array($fieldName, ($this->mode == 'pages') ? self::$sysPagesWhereFields : self::$sysObjectsWhereFields)) {
				return $this->whereSysProps[$fieldName] = new selectorWhereSysProp($fieldName);
			} else {
				$fieldId = $this->searchField($fieldName);
				if($fieldId) {
					return $this->whereFieldProps[] = new selectorWhereFieldProp($fieldId);
				} else {
					throw new selectorException("Field \"{$fieldName}\" is not presented in selected object types");
				}
			}
		}

		public function order($fieldName) {
			$this->checkExecuted();
			if(in_array($fieldName, self::$sysOrderFields)) {
				return $this->orderSysProps[] = new selectorOrderSysProp($fieldName);
			} else {
				$fieldId = $this->searchField($fieldName);
				if($fieldId) {
					return $this->orderFieldProps[] = new selectorOrderFieldProp($fieldId);
				} else {
					throw new selectorException("Field \"{$fieldName}\" is not presented in selected object types");
				}
			}
		}

		public function group($fieldName) {
			$this->checkExecuted();
			if(in_array($fieldName, ($this->mode == 'pages') ? self::$sysPagesGroupFields : self::$sysObjectsGroupFields)) {
				return $this->groupSysProps[] = new selectorGroupSysProp($fieldName);
			} else {
				$fieldId = $this->searchField($fieldName);
				if($fieldId) {
					return $this->groupFieldProps[] = new selectorGroupFieldProp($fieldId);
				} else {
					throw new selectorException("Field \"{$fieldName}\" is not presented in selected object types");
				}
			}
		}

		public function limit($offset, $limit) {
			$this->checkExecuted();
			$this->limit = (int) $limit;
			$this->offset = (int) $offset;
		}

		public function result() {
			if(is_null($this->result)) {
				if($this->mode == 'pages') {
					if(sizeof($this->orderSysProps) == 0) $this->order('ord')->asc();
					if(is_null($this->permissions)) $this->where('permissions');
				}
				$return = $this->option('return')->value;
				if (is_array($return) && in_array('count', $return)) {
					$this->result = $this->executor()->length();
				}
				else $this->result = $this->executor()->result();
				$this->length = $this->executor()->length();
			}
			$this->unloadExecutor();
			return $this->result;
		}

		public function length() {
			if(is_null($this->length)) {
				if($this->mode == 'pages' && is_null($this->permissions)) {
					$this->where('permissions');
				}
				$length = $this->executor()->length();
				if (in_array('count', $this->option('return')->value)) {
					$this->result = $length;
				}
				else $this->result = $this->executor()->result();
				$this->length = $length;
			}
			$this->unloadExecutor();
			return $this->length;
		}

		public function option($name, $value = null) {
			$this->checkExecuted();
			if (!isset($this->options[$name])) {
				$selectorOption = new selectorOption($name);
				$this->options[$name] = $selectorOption;
			}
			if (!is_null($value)) $this->options[$name]->value($value);
			return $this->options[$name];
		}

		public function flush() {
			$this->result = null;
			$this->length = null;
		}

		public function __get($prop) {
			switch($prop) {
				case 'length':
				case 'total':
					return $this->length();
				case 'result':
					return $this->result();
				case 'first':
					return (sizeof($this->result())) ? $this->result[0] : null;
				case 'last':
					return (sizeof($this->result())) ? $this->result[sizeof($this->result) - 1] : null;
			}

			$allowedProps = array('mode', 'offset', 'limit', 'whereFieldProps', 'orderFieldProps', 'groupFieldProps',
				'whereSysProps', 'orderSysProps', 'groupSysProps', 'types', 'permissions', 'hierarchy', 'options');

			if(in_array($prop, $allowedProps)) {
				return $this->$prop;
			}
		}

		public function getIterator() {
			$this->result();
			return new ArrayIterator($this->result);
		}

		public function query() {
			if($this->mode == 'pages') {
				if(sizeof($this->orderSysProps) == 0) $this->order('ord')->asc();
				if(is_null($this->permissions)) $this->where('permissions');
			}

			return $this->executor()->query();
		}

		public function searchField($fieldName) {
			foreach($this->types as $type) {
				$fieldId = $type->getFieldId($fieldName);
				if($fieldId) return $fieldId;
			}
			if($this->mode == 'pages') {
				$types = umiObjectTypesCollection::getInstance();
				$type = $types->getTypeByGUID('root-pages-type');
				$fieldId = $type->getFieldId($fieldName);
				if($fieldId) return $fieldId;
			}
		}

		protected function checkExecuted() {
			if($this->executor && $this->executor->getSkipExecutedCheckState()) return;
			if(!is_null($this->result) || !is_null($this->length)) {
				throw new selectorException("Selector has been already executed. You should create new one or use selector::flush() method instead.");
			}
		}

		protected function executor() {
			if(!$this->executor) $this->executor = new selectorExecutor($this);
			return $this->executor;
		}

		protected function unloadExecutor() {
			if(!is_null($this->length) && !is_null($this->result)) {
				unset($this->executor);
			}
		}

		protected function setMode($mode) {
			if(in_array($mode, self::$modes)) {
				$this->mode = $mode;
				if($mode == 'pages') {
					$this->setDefaultPagesWhere();
				}
			} else {
				throw new selectorException(
					"This mode \"{$mode}\" is not supported, choose one of these: " . implode(', ', self::$modes)
				);
			}
		}

		protected function setDefaultPagesWhere () {
			$cmsController = cmsController::getInstance();
			$this->where('domain')->equals($cmsController->getCurrentDomain());
			$this->where('lang')->equals($cmsController->getCurrentLang());
			$this->where('is_deleted')->equals(0);

			if($cmsController->getCurrentMode() != 'admin') {
				$this->where('is_active')->equals(1);
			}
		}
	};


	abstract class selectorWhereProp {
		protected $value, $mode,
		$modes = array('equals', 'notequals', 'ilike', 'like', 'more', 'eqmore', 'less', 'eqless', 'between', 'isnull', 'isnotnull');
		
		public function __call($method, $args) {      
			$method = strtolower($method);
			if(in_array($method, $this->modes)) {
				$value = sizeof($args) ? $args[0] : null;
				
				if($value instanceof iUmiEntinty) {
					$value = $value->getId();
				}
				
				if(isset($this->fieldId)) {
					$field = selector::get('field')->id($this->fieldId);
					if($restrictionId = $field->getRestrictionId()) {
						$restriction = baseRestriction::get($restrictionId);
						if($restriction instanceof iNormalizeInRestriction) {
							$value = $restriction->normalizeIn($value);
						}
					}
					
					if(is_numeric($value) && substr($value, 0, 1) !== "0") {
						$value = (double) $value;
					}
					
					if($field->getDataType() == 'relation' && is_string($value)) {
						if($guideId = $field->getGuideId()) {
							$sel = new selector('objects');
							$sel->types('object-type')->id($guideId);
							$sel->where('*')->ilike($value);
							
							$length = sizeof($sel->result); //fast length
							if($length > 0 && $length < 100) {
								$value = $sel->result;
							}
						}
					}
					
					if($field->getDataType() == 'date' && is_string($value)) {
						$date = new umiDate;
						$date->setDateByString(trim($value, ' %'));
						$value = $date->getDateTimeStamp();
					}
				}
				
				$this->value = $value;
				$this->mode = $method;
			} else {
				throw new selectorException("This property doesn't support \"{$method}\" method");
			}
		}
		
		public function between($start, $end) {
			return $this->__call('between', array(array($start, $end)));
		}
		
		public function __get($prop) { return $this->$prop; }
	};

	class selectorWhereSysProp extends selectorWhereProp {
		protected $name;
		
		public function __construct($name) {
			$this->name = $name;
		}
	};

	class selectorWhereFieldProp extends selectorWhereProp {
		protected $fieldId;
		
		public function __construct($fieldId) {
			$this->fieldId = $fieldId;
		}
	};
	
	class selectorWhereHierarchy {
		protected $elementId, $level = 1, $selfLevel;
		
		public function page($elementId)  {
			$hierarchy = umiHierarchy::getInstance();
			if(is_numeric($elementId) == false) {
				$elementId = $hierarchy->getIdByPath($elementId);
			}

			if($elementId !== false) {
				$this->elementId = (int) $elementId;
			}
			return $this;
		}
		
		public function childs($level = 1) {
			if(is_null($this->selfLevel)) {
				$sql = "SELECT level FROM cms3_hierarchy_relations WHERE child_id = {$this->elementId}";
				$result = l_mysql_query($sql);
				list($this->selfLevel) = mysql_fetch_row($result);
			}
			$this->level = ($level == 0) ? 0 : (int) $level + (int) $this->selfLevel;
		}
		
		public function __get($prop) { return $this->$prop; }
	};
	
	class selectorWherePermissions {
		protected $level = 0x1, $owners = array(), $isSv;
		
		public function __construct() {
			$permissions = permissionsCollection::getInstance();
			$userId = $permissions->getUserId();
			
			$this->isSv = $permissions->isSv();
			if(!$this->isSv) {
				$this->owners = array($userId);
				$user = umiObjectsCollection::getInstance()->getObject($userId);
				if($user) {
					$this->owners = array_merge($this->owners, $user->groups);
				}
			}
		}
		
		public function level($level) {
			$this->level = (int) $level;
		}
		
		public function owners($owners) {
			if(is_array($owners)) {
				foreach($owners as $owner) $this->owners($owner);
			} else {
				$this->addOwner($owners);
			}
			return $this;
		}
		
		public function __get($prop) { return $this->$prop; }
		
		protected function addOwner($ownerId) {
			if(in_array($ownerId, $this->owners)) return;
			//if($this->isSv) return;
			$permissions = permissionsCollection::getInstance();
			
			
			$objects = umiObjectsCollection::getInstance();
			$object = $objects->getObject($ownerId);
			
			if($object instanceof iUmiObject) {
				if($permissions->isSv($ownerId)) {
					$this->isSv = true;
					return;
				}
				
				$this->owners[] = $ownerId;
				if($object->groups) {
					$this->owners = array_merge($this->owners, $object->groups);
				}
			}
		}
	};


	class selectorType {
		protected $typeClass, $objectType, $hierarchyType, $selector;
		protected static $typeClasses = array('object-type', 'hierarchy-type');
		
		public function __construct($typeClass, $selector) {
			$this->setTypeClass($typeClass);
			$this->selector = $selector;
		}
		
		public function name($module, $method) {
			if(!$method && $module == 'content') $method = 'page';
			
			switch($this->typeClass) {
				case 'object-type': {
					$objectTypes = umiObjectTypesCollection::getInstance();
					$objectTypeId = $objectTypes->getBaseType($module, $method);
					return $this->setObjectType($objectTypes->getType($objectTypeId));
				}
				
				case 'hierarchy-type': {
					$hierarchyTypes = umiHierarchyTypesCollection::getInstance();
					$hierarchyType = $hierarchyTypes->getTypeByName($module, $method);
					return $this->setHierarchyType($hierarchyType);
				}
			}
		}
		
		public function id($id) {
			if(is_array($id)) {
				$result = null;
				foreach($id as $iid) {
					$this->selector->types($this->typeClass)->id($iid);
				}
				return $result;
			}
			
			switch($this->typeClass) {
				case 'object-type': {
					$objectTypes = umiObjectTypesCollection::getInstance();
					return $this->setObjectType($objectTypes->getType($id));
				}
				
				case 'hierarchy-type': {
					$hierarchyTypes = umiHierarchyTypesCollection::getInstance();
					return $this->setHierarchyType($hierarchyTypes->getType($id));
				}
			}
		}
		
		public function guid($guid) {
			if($this->typeClass != 'object-type') {
				throw new selectorException("Select by guid is allowed only for object-type");
			}
			
			if(is_array($guid)) {
				$guids[] = array();
				//$result = null;
				foreach($guid as $v) {
					$guids[] = umiObjectTypesCollection::getInstance()->getTypeIdByGUID($v);
				}
				$guid = $guids;
			}
			else {
				$guid = umiObjectTypesCollection::getInstance()->getTypeIdByGUID($guid);
			}
	
			return $this->id($guid);
		}
		
		public function setTypeClass($typeClass) {
			if(in_array($typeClass, self::$typeClasses)) {
				$this->typeClass = $typeClass;
			} else {
				throw new selectorException(
					"Unkown type class \"{$typeClass}\". These types are only supported: " . implode(", ", self::$typeClasses)
				);
			}
		}
		
		public function getFieldId($fieldName) {
			if(is_null($this->objectType)) {
				if(is_null($this->hierarchyType)) {
					throw new selectorException("Object and hierarchy type prop can't be empty both");
				}
				$objectTypes = umiObjectTypesCollection::getInstance();
				$objectTypeId = $objectTypes->getTypeByHierarchyTypeId($this->hierarchyType->getId());
				if($objectType = $objectTypes->getType($objectTypeId)) {
					$this->setObjectType($objectType);
				} else {
					return false;
				}
			}
			return $this->objectType->getFieldId($fieldName);
		}
		
		public function __get($prop) {
			$allowedProps = array('objectType', 'hierarchyType');
			
			if(in_array($prop, $allowedProps)) {
				return $this->$prop;
			}
		}
		
		protected function setObjectType($objectType) {
			if($objectType instanceof iUmiObjectType) {
				$this->objectType = $objectType;
			} else {
				throw new selectorException("Wrong object type given");
			}
		}
		
		protected function setHierarchyType($hierarchyType) {
			if($hierarchyType instanceof iUmiHierarchyType) {
				$this->hierarchyType = $hierarchyType;
			} else {
				throw new selectorException("Wrong hierarchy type given");
			}
		}
	};


	abstract class selectorOrderField {
		protected $asc = true;
		
		public function asc() { $this->asc = true; }
		public function desc() { $this->asc = false; }
		public function rand() { $this->name = 'rand'; }

		public function __get($prop) { return $this->$prop; }
	};

	class selectorOrderFieldProp extends selectorOrderField {
		protected $fieldId;
		
		public function __construct($fieldId) {
			$this->fieldId = $fieldId;
		}
	};
	
	class selectorOrderSysProp extends selectorOrderField {
		protected $name;
		
		public function __construct($name) {
			$this->name = $name;
		}
	}


	class selectorExecutor {
		protected
			$selector,
			$queryColumns = array(),
			$queryTables = array(),
			$queryJoinTables = array(),
			$queryLimit = array(),
			$queryFields = array(),
			$queryOptions = array(),

			$length = null,
			$skipExecutedCheck = false;

		public function __construct(selector $selector) {
			$this->selector = $selector;
			$this->analyze();
		}

		public function query() {
			return $this->buildQuery('result');
		}

		public function result() {
	 	 	$sql = $this->buildQuery('result');

			if(defined('DEBUG_SQL_SELECTOR')) {
				$buffer = outputBuffer::current();
				$buffer->push($sql . "\n\n\n");
			}

			$connection = ConnectionPool::getInstance()->getConnection();

			$result = $connection->query($sql);
			$return = $this->selector->option('return')->value;

			if(!DISABLE_CALC_FOUND_ROWS) {
				$countResult = l_mysql_query("SELECT FOUND_ROWS()", true);
				list($count) = mysql_fetch_row($countResult);
				mysql_free_result($countResult);
				$this->length = (int) $count;
			}

			if($this->selector->mode == 'objects') {
				$list = array();
				$objects = umiObjectsCollection::getInstance();
				while($row = mysql_fetch_row($result)) {
					list($objectId) = $row;
					if (is_array($return) && sizeof($return)) {
						if (sizeof($return) == 1 && $return[0] == 'id') {
							$list[] = array('id' => $objectId);
						}
						else {
							$object = $objects->getObject($objectId, array_slice($row, 1));
							$list_items = array();
							foreach ($return as $field_name) {
								switch ($field_name) {
									case "id": $list_items[$field_name] = $objectId; break;
									case "name": $list_items[$field_name] = $object->getName(); break;
									case "guid": $list_items[$field_name] = $object->getGUID(); break;
									default :
										$field = $object->getValue($field_name);
										$list_items[$field_name] = $field ? $field : false;
								}
							}
							$list[] = $list_items;
						}
					}
					else {
						$object = $objects->getObject($objectId, array_slice($row, 1));
						if($object instanceof iUmiObject) {
							$list[] = $object;
						}
					}
				}
				return $list;
			} else {
				$ids = array();

				while($row = mysql_fetch_assoc($result)) {
					$id = (int) $row['id'];
					$pid = isset($row['pid']) ? (int) $row['pid'] : 0;
					$ids[$id] = $pid;
				}

				if($this->selector->option('exclude-nested')->value) {
					$listIds = $this->excludeNestedPages($ids);
					$this->length = sizeof($listIds);
					if($this->selector->limit || $this->selector->offset) {
						$listIds = array_slice($listIds, $this->selector->offset, $this->selector->limit);
					}
				} else {
					$listIds = array_keys($ids);
				}

				$list = array();
				if(count($listIds)) {
					$sql = "SELECT h.id, h.rel, h.type_id, h.lang_id, h.domain_id, h.tpl_id, h.obj_id, h.ord, h.alt_name, h.is_active, h.is_visible, h.is_deleted, h.updatetime, h.is_default, o.name FROM cms3_hierarchy h, cms3_objects o WHERE h.id IN (" . implode(',', $listIds) . ") AND o.id = h.obj_id";
					$result = $connection->queryResult($sql);
					$result->setFetchType(IQueryResult::FETCH_ROW);
                    $list = array_flip($listIds);
					$hierarchy = umiHierarchy::getInstance();

					foreach($result as $row) {
						$elementId = array_shift($row);
						if (sizeof($return)) {
							if (sizeof($return) == 1 && $return[0] == 'id') {
								$list[$elementId] = array('id' => $elementId);
							}
							else {
								$element = $hierarchy->getElement($elementId);
								$list_items = array();
								foreach ($return as $field_name) {
									switch ($field_name) {
										case "id": $list_items[$field_name] = $elementId; break;
										case "name": $list_items[$field_name] = $element->getName(); break;
										case "alt_name": $list_items[$field_name] = $element->getAltName(); break;
										default :
											$field = $element->getValue($field_name);
											$list_items[$field_name] = $field ? $field : false;
									}
								}
								$list[$elementId] = $list_items;
							}
						}
						else {
							$element = $hierarchy->getElement($elementId, false, false, $row);
							if($element instanceof iUmiHierarchyElement) {
								$list[$elementId] = $element;
							}
						}
					}
					$list = array_values($list);
				}

				return $list;
			}
		}

		public function length() {
			if(!is_null($this->length)) {
				return $this->length;
			}

			$this->skipExecutedCheck = true;
			if(count($this->selector->groupSysProps) || count($this->selector->groupFieldProps)) {
				$sql = $this->buildQuery('result');
			} else {
				$sql = $this->buildQuery('count');
			}
			$this->skipExecutedCheck = false;

			$result = l_mysql_query($sql);
			if(count($this->selector->groupSysProps) || count($this->selector->groupFieldProps)) {
				$count = mysql_num_rows($result);
			} else {
				list($count) = mysql_fetch_row($result);
			}
			return $this->length = (int) $count;
		}

		public static function getContentTableName(selector $selector, $fieldId) {
			if(!is_null($fieldId) && self::getFieldColumn($fieldId) == 'cnt') {
				return 'cms3_object_content_cnt';
			}

			$objectTypes = array();
			$hierarchyTypes = array();

			$types = $selector->types;
			foreach($types as $type) {
				if(is_null($type->objectType) == false) $objectTypes[] = $type->objectType->getId();

				if(is_null($type->hierarchyType) == false) {
					$hierarchyType = $type->hierarchyType;
					if($hierarchyType->getModule() == 'comments') continue;
					$hierarchyTypes[] = $hierarchyType->getId();
				}
			}

			if(sizeof($objectTypes)) {
				return umiBranch::getBranchedTableByTypeId(array_pop($objectTypes));
			}

			if(sizeof($hierarchyTypes)) {
				$hierarchyTypeId = array_pop($hierarchyTypes);
				if(umiBranch::checkIfBranchedByHierarchyTypeId($hierarchyTypeId)) {
					return 'cms3_object_content_' . $hierarchyTypeId;
				}
			}

			return 'cms3_object_content';
		}

		public function getSkipExecutedCheckState() {
			return $this->skipExecutedCheck;
		}

		protected function analyze() {
			$selector = $this->selector;
			switch($selector->mode) {
				case 'objects':
					$this->requireTable('o', 'cms3_objects');
					$this->requireTable('t', 'cms3_object_types');
					break;
				case 'pages':
					$this->requireTable('h', 'cms3_hierarchy');
					break;
			}
			$this->analyzeFields();
			$this->analyzeLimit();
		}

		protected function requireTable($alias, $tableName) {
			$this->queryTables[$alias] = $tableName;
		}

		protected function requireSysProp($propName) {
			$propTable = array();
			$propTable['name'] = array('o.name', 'table' => array('o', 'cms3_objects'));
			$propTable['guid'] = array('o.guid', 'table' => array('o', 'cms3_objects'));
			$propTable['owner'] = array('o.owner_id', 'table' => array('o', 'cms3_objects'));
			$propTable['domain'] = array('h.domain_id');
			$propTable['lang'] = array('h.lang_id');
			$propTable['is_deleted'] = array('h.is_deleted');
			$propTable['is_default'] = array('h.is_default');
			$propTable['is_visible'] = array('h.is_visible');
			$propTable['is_active'] = array('h.is_active');
			$propTable['domain'] = array('h.domain_id');
			$propTable['updatetime'] = array('h.updatetime');
			$propTable['rand'] = array('RAND()');
			$propTable['template_id'] = array('h.tpl_id');

			if($this->selector->mode == 'pages') {
				$propTable['ord'] = array('h.ord', 'table' => array('h', 'cms3_hierarchy'));
			}


			if($propName == 'id') {
				$propTable['id'] = array('o.id', 'table' => array('o', 'cms3_objects'));
			};

			if(isset($propTable[$propName])) {
				$info = $propTable[$propName];
				if(isset($info['table'])) {
					$this->requireTable($info['table'][0], $info['table'][1]);
				}
				return $info[0];
			} else {
				throw new selectorException("Not supported property \"{$propName}\"");
			}
		}

		protected function analyzeFields() {
			$selector = $this->selector;

			$selectorFields = $selector->whereFieldProps;
			$fields = array();
			foreach($selectorFields as $field) {
				$fields[] = $field->fieldId;
			}
			$fields = array_unique($fields);
			foreach($fields as $fieldId) {
				$tableName = self::getContentTableName($selector, $fieldId);

				$this->requireTable('oc_' . $fieldId, $tableName);
				$this->queryFields[] = $fieldId;
			}

			//TODO: Attach tables, required by sys props
			//$selectorSysProps = array_merge($selector->whereSysProps, $selector->orderSysProps);
		}

		protected function analyzeLimit() {
			$selector = $this->selector;

			if($selector->option('exclude-nested')->value) {
				return;
			}

			if($selector->limit || $selector->offset) {
				$this->queryLimit = array((int) $selector->offset, (int) $selector->limit);
			}
		}

		protected function buildQuery($mode) {
			if($mode == 'result') {
				if($this->selector->mode == 'objects') {
					$this->queryColumns = array('o.id as id', 'o.name as name', 'o.type_id as type_id', 'o.is_locked as is_locked', 'o.owner_id as owner_id', 'o.guid as guid', 't.guid as type_guid');
				} else {
					$this->queryColumns = array('h.id as id', 'h.rel as pid');
				}
			} else {
				$this->queryColumns = ($this->selector->mode == 'objects') ? array('COUNT(o.id)') : array('COUNT(h.id)');
			}


			if($this->selector->option('root')->value) {
				return $this->buildRootQuery($mode);
			}

			$columnsSql = $this->buildColumns();
			$limitSql = $this->buildLimit();
			$orderSql = $this->buildOrder();
			$groupSql = $this->buildGroup();
			$whereSql = $this->buildWhere();
			$ljoinSql = $this->buildLeftJoins();
			$tablesSql = $this->buildTables();
			$optionsSql = $this->buildOptions($mode);

			return <<<SQL
SELECT {$optionsSql} {$columnsSql}
	FROM {$tablesSql}
	{$ljoinSql}
	{$whereSql}
	{$orderSql}
	{$groupSql}
	{$limitSql}
SQL;
		}

		protected function buildOptions($mode) {
			$queryOptions = $this->queryOptions;
			$queryOptions = array_unique($queryOptions);

			if(MAX_SELECTION_TABLE_JOINS > 0 && MAX_SELECTION_TABLE_JOINS < sizeof($this->queryJoinTables)) {
				$queryOptions[] = 'STRAIGHT_JOIN';
			}

			if($mode == 'result') {
				if(!DISABLE_CALC_FOUND_ROWS) {
					$queryOptions[] = 'SQL_CALC_FOUND_ROWS';
				}
			}

			return implode(' ', $queryOptions);
		}

		protected function buildLeftJoins() {
			$joins = array();
			$data_joins = array_merge($this->selector->orderFieldProps, $this->selector->whereFieldProps);
			$fieldsId = array();
			foreach($data_joins as $data_join) {
				$fieldId = $data_join->fieldId;
				if (!in_array($fieldId, $fieldsId)) {
					$this->requireTable('o', 'cms3_objects');
					$tableName = self::getContentTableName($this->selector, $fieldId);
					$join = "LEFT JOIN {$tableName} oc_{$fieldId}_lj ON oc_{$fieldId}_lj.obj_id=o.id AND oc_{$fieldId}_lj.field_id = '{$fieldId}'";
					$joins[] = $join;
					$fieldsId[] = $fieldId;
					$this->queryJoinTables[] = $tableName;
				}
			}

			return empty($joins) ? "" : implode(" ", $joins);
		}

		protected function buildColumns() { return implode(', ', $this->queryColumns); }

		protected function buildTables() {
			$tables = array();
			$joinObjectsTable = false;
			foreach($this->queryTables as $alias => $name) {
				if ($name == 'cms3_objects' && $joinObjectsTable === false) {
					$joinObjectsTable = $alias;
					continue;
				}
				if ($name == 'cms3_object_content' && $alias != 'o_asteriks') continue;
				$tables[] = $name . ' ' . $alias;
			}
			if($joinObjectsTable !== false) {
				$tables[] = $this->queryTables[$joinObjectsTable] . ' ' . $joinObjectsTable;
			}
			return implode(', ', $tables);
		}

		protected function buildLimit() {
			if(sizeof($this->queryLimit)) {
				return " LIMIT {$this->queryLimit[0]}, {$this->queryLimit[1]}";
			} else {
				return "";
			}
		}

		protected function buildWhere() {
			$sql = "";

			$conds = array();
			//Types
			$objectTypes = array(); $hierarchyTypes = array();

			foreach($this->selector->types as $type) {
				if(is_null($type->objectType) == false) $objectTypes[] = $type->objectType->getId();
				if(is_null($type->hierarchyType) == false) $hierarchyTypes[] = $type->hierarchyType->getId();
			}

			if(sizeof($objectTypes)) {
				$this->requireTable('o', 'cms3_objects');
				$this->requireTable('t', 'cms3_object_types');

				$typesCollection = umiObjectTypesCollection::getInstance();
				$subTypes = array();
				foreach($objectTypes as $objectTypeId) {
					$subTypes = array_merge($subTypes, $typesCollection->getChildClasses($objectTypeId));
				}

				$objectTypes = array_unique(array_merge($objectTypes, $subTypes));

				$conds[] = 'o.type_id IN (' . implode(', ', $objectTypes) . ')';
				$conds[] = 't.id = o.type_id';
			}

			if(sizeof($hierarchyTypes)) {
				$hierarchyTypes = array_unique($hierarchyTypes);
				$conds[] = 'h.type_id IN (' . implode(', ', $hierarchyTypes) . ')';
			}

			if(sizeof($this->queryFields)) {
				$this->requireTable('o', 'cms3_objects');
			}

			//Field props
			$fieldsColl     = umiFieldsCollection::getInstance();
			$or_mode        = $this->selector->option('or-mode');
			$where_conds    = array();
			$where_or_conds = array();
			$where_conditions = '';
			foreach($this->queryFields as $fieldId) {
				if (isset($or_mode->value['fields']) && in_array($fieldsColl->getField($fieldId)->getName(), $or_mode->value['fields'])) {
					$where_or_conds[] = $this->buildWhereValue($fieldId);
				}
				else $where_conds[] = $this->buildWhereValue($fieldId);
			}
			if(sizeof($where_conds) || sizeof($where_or_conds)) {
				if (isset($or_mode->value['all'])) {
					$where_conds = array_merge($where_conds, $where_or_conds);
					$where_conditions = implode(' OR ', $where_conds);
				}
				else {
					if (sizeof($where_conds)) {
						$where_conditions .= implode(' AND ', $where_conds);
						if (sizeof($where_or_conds)) $where_conditions .= ' AND ';
					}
					if (sizeof($where_or_conds)) {
						$where_conditions .= (sizeof($where_or_conds) > 1) ? "(" . implode(' OR ', $where_or_conds) . ")" : $where_or_conds[0];
					}
				}
				$conds[] = '('. $where_conditions . ')';
			}

			//Sys props
			$sysProps = $this->selector->whereSysProps;
			foreach($sysProps as $sysProp) {
				if($cond = $this->buildSysProp($sysProp)) {
					$conds[] = $cond;
				}
			}

			if($this->selector->mode == 'pages') {
				if($permConds = $this->buildPermissions()) {
					$conds[] = $permConds;
				}

				if($hierarchyConds = $this->buildHierarchy()) {
					$conds[] = $hierarchyConds;
				}

				if(isset($this->queryTables['o'])) {
					$conds[] = "h.obj_id = o.id";
				}
			}

			$sql .= implode(' AND ', $conds);
			if($sql) $sql = "WHERE " . $sql;
			return $sql;
		}

		protected function buildWhereValue($fieldId) {
			$wheres = $this->selector->whereFieldProps;
			$current = array();
			foreach($wheres as $where) {
				if($where->fieldId == $fieldId) $current[] = $where;
			}

			$column = self::getFieldColumn($fieldId);

			$sql = ""; $conds = array();
			foreach($current as $where) {
				if($column === false) {
					if(sizeof($where->value) == 1) {
						$keys = array_keys($where->value);
						$column = array_pop($keys) . '_val';
					} else continue;
				}
				$condition = $this->parseValue($where->mode, $where->value, "oc_{$fieldId}_lj.{$column}");
				$conds[] = ($where->mode == 'notequals') ? "(oc_{$fieldId}_lj.{$column}{$condition})" : "oc_{$fieldId}_lj.{$column}{$condition}";
			}
			$field = umiFieldsCollection::getInstance()->getField($fieldId);
			$or_mode = $this->selector->option('or-mode');
			if (isset($or_mode->value['all']) || (isset($or_mode->value['field']) && in_array($field->getName(), $or_mode->value['field']))) {
				$quantificator = ' OR ';
				$this->queryOptions[] = 'DISTINCT';
			} else {
				$quantificator = ' AND ';
			}
			$sql = implode($quantificator, array_unique($conds));
			return $sql ? (sizeof($conds) > 1 ? "(" . $sql . ")" : $sql) : "";
		}

		protected function parseValue($mode, $value, $column = false) {
			switch($mode) {
				case 'equals':
					if(is_array($value) || is_object($value)) {
						$value = $this->escapeValue($value);
						if(sizeof($value)) {
							return ' IN(' . implode(', ', $value) . ')';
						} else {
							return ' = 0 = 1';	//Impossible value to reset query result to zero
						}
					}
					else
						return ' = ' . $this->escapeValue($value);
					break;

				case 'notequals':
					if(is_array($value) || is_object($value)) {
						$value = $this->escapeValue($value);
						if(sizeof($value)) {
							return ' NOT IN(' . implode(', ', $value) . ')' . ($column ? " OR {$column} IS NULL" : "");
						} else {
							return ' = 0 = 1';	//Impossible value to reset query result to zero
						}
					}
					else
						return ' != ' . $this->escapeValue($value) . ($column ? " OR {$column} IS NULL" : "");
					break;


				case 'like':
					if(is_array($value)) throw new selectorException("Method \"{$mode}\" can't accept array");
					else return ' LIKE ' . $this->escapeValue($value);

				case 'ilike':
					if(is_array($value)) throw new selectorException("Method \"{$mode}\" can't accept array");
					else return ' LIKE ' . $this->escapeValue($value);

				case 'more':
					if(is_array($value)) throw new selectorException("Method \"{$mode}\" can't accept array");
					else return ' > ' . $this->escapeValue($value);

				case 'eqmore':
					if(is_array($value)) throw new selectorException("Method \"{$mode}\" can't accept array");
					else return ' >= ' . $this->escapeValue($value);

				case 'less':
					if(is_array($value)) throw new selectorException("Method \"{$mode}\" can't accept array");
					else return ' < ' . $this->escapeValue($value);

				case 'eqless':
					if(is_array($value)) throw new selectorException("Method \"{$mode}\" can't accept array");
					else return ' <= ' . $this->escapeValue($value);

				case 'between':
					return ' BETWEEN ' . $this->escapeValue($value[0]) . ' AND ' . $this->escapeValue($value[1]);

				case 'isnotnull':
					$value != $value;
				case 'isnull':
					return ($value) ? ' IS NULL' : ' IS NOT NULL';

				default:
					throw new selectorException("Unsupported field mode \"{$mode}\"");
			}
		}

		protected function buildSysProp($prop) {
			if($prop->name == 'domain' || $prop->name == 'lang') {
				if($prop->value === false) return false;
			}

			if($prop->name == 'domain'){
				$arr_hierarchy = $this->selector->hierarchy;
				if(sizeof($arr_hierarchy) && $arr_hierarchy[0]->elementId) {
					return false;
				}
			}

			if($prop->name == '*') {
				$this->requireTable('o_asteriks', 'cms3_object_content');
				$this->requireTable('o', 'cms3_objects');

				$alias = self::getContentTableName($this->selector, null);
				$tables = array('o_asteriks');
				if($alias != 'cms3_object_content') {
					$this->requireTable('o_asteriks_branched', $alias);
					$tables[] = 'o_asteriks_branched';
				}
				$this->queryOptions[] = 'DISTINCT';


				$conds = array();
				foreach($tables as $tableName) {


					$values = $prop->value;
					if(!is_array($values)) $values = array($values);
					$sconds = array();
					foreach($values as $value) {
						$evalue = $this->escapeValue('%' . $value . '%');

						$sconds[] = $tableName . '.varchar_val LIKE ' . $evalue;
						$sconds[] = $tableName . '.text_val LIKE ' . $evalue;
						$sconds[] = 'o.name LIKE ' . $evalue;

						if(is_numeric($value)) {
							$sconds[] = $tableName . '.float_val = ' . $evalue;
							$sconds[] = $tableName . '.int_val = ' . $evalue;
						}
					}

					$conds[] = '(' . $tableName . '.obj_id = o.id AND (' . implode(' OR ', $sconds) . '))';
				}

				$sql = '(' . implode(' OR ', $conds) . ')';
				return $sql;

			} else {
				$name = $this->requireSysProp($prop->name);
				$sql = "{$name}" . $this->parseValue($prop->mode, $prop->value, $name);
				return ($prop->mode == 'notequals') ? '('.$sql.')' : $sql;
			}
		}

		protected function buildOrder() {
			$sql = "";
			$conds = array();
			foreach($this->selector->orderFieldProps as $order) {
				$fieldId = $order->fieldId;
				$column = self::getFieldColumn($fieldId);
				$conds[] = "oc_{$fieldId}_lj.{$column} " . ($order->asc ? 'ASC' : 'DESC');
			}

			foreach($this->selector->orderSysProps as $order) {
				$name = $this->requireSysProp($order->name);
				$conds[] = $name . ' ' . ($order->asc ? 'ASC' : 'DESC');
			}

			$sql = implode(', ', $conds);
			return $sql ? "ORDER BY " . $sql : "";
		}

		protected function buildGroup() {
			$sql = "";
			$conds = array();
			foreach($this->selector->groupFieldProps as $group) {
				$fieldId = $group->fieldId;
				$column = self::getFieldColumn($fieldId);
				$conds[] = "oc_{$fieldId}_lj.{$column}";
			}

			foreach($this->selector->groupSysProps as $group) {
				$name = $this->requireSysProp($group->name);
				$conds[] = $name;
			}

			$sql = implode(', ', $conds);
			return $sql ? "GROUP BY " . $sql : "";
		}

		protected function buildPermissions() {
			$permissions = $this->selector->permissions;
			$owners = $permissions->owners;
			if($permissions && sizeof($owners)) {
				$this->requireTable('p', 'cms3_permissions');
				$this->queryOptions[] = 'DISTINCT';
				$guestId = umiObjectsCollection::getInstance()->getObjectIdByGUID('system-guest');
				if (!in_array($guestId, $owners)) $owners[] = $guestId;
				$owners = implode(', ', $owners);
				return "(p.rel_id = h.id AND p.level & {$permissions->level} AND p.owner_id IN({$owners}))";
			} else return "";
		}

		protected function buildHierarchy() {
			$hierarchy = $this->selector->hierarchy;
			if(sizeof($hierarchy) == 0) return "";

			$this->requireTable('hr', 'cms3_hierarchy_relations');

			$sql = "h.id = hr.child_id AND ";
			$harr = array();
			foreach($hierarchy as $condition) {
				if($condition->elementId > 0)
					$hsql = "(hr.level <= {$condition->level} AND hr.rel_id";
				else
					$hsql = "(hr.level < {$condition->level} AND hr.rel_id";
				$hsql .= ($condition->elementId > 0) ? " = '{$condition->elementId}'" : " IS NULL";
				$hsql .= ")";
				$harr[] = $hsql;
			}
			if (sizeof($harr) > 1) $sql .= "(";
			$sql .= implode(' OR ', $harr);
			if (sizeof($harr) > 1) $sql .= ")";
			return $sql;
		}

		protected static function getFieldColumn($fieldId) {
			static $cache = array();
			if(isset($cache[$fieldId])) return $cache[$fieldId];

			$field = umiFieldsCollection::getInstance()->getField($fieldId);
			switch($field->getDataType()) {
				case 'string':
				case 'password':
				case 'tags':
					return $cache[$fieldId] = 'varchar_val';

				case 'int':
				case 'boolean':
				case 'date':
					return $cache[$fieldId] = 'int_val';

				case 'counter':
					return $cache[$fieldId] = 'cnt';

				case 'price':
				case 'float':
					return $cache[$fieldId] = 'float_val';

				case 'text':
				case 'wysiwyg':
				case 'file':
				case 'img_file':
				case 'swf_file':
				case 'video_file':
					return $cache[$fieldId] = 'text_val';

				case 'relation':
					return $cache[$fieldId] = 'rel_val';

				case 'symlink':
					return $cache[$fieldId] = 'tree_val';

				case 'optioned': return false;

				default:
					throw new selectorException("Unsupported field type \"{$field->getDataType()}\"");
			}
		}

		protected function escapeValue($value) {
			if(is_array($value)) {
				foreach($value as $i => $val) $value[$i] = $this->escapeValue($val);
				return $value;
			} if ($value instanceof selector) {
				return $this->escapeValue($value->result());
			} if ($value instanceof iUmiObject || $value instanceof iUmiHierarchyElement) {
				return $value->id;
			} else {
				return "'" . l_mysql_real_escape_string($value) . "'";
			}
		}

		protected function buildRootQuery($mode) {
			$columnsSql = $this->buildColumns();
			$limitSql = $this->buildLimit();
			$orderSql = $this->buildOrder();
			$whereSql = $this->buildWhere();
			$tablesSql = $this->buildTables();
			$optionsSql = $this->buildOptions($mode);

			$types = array();
			foreach($this->selector->types as $type) {
				if($type->hierarchyType) $types[] = $type->hierarchyType->getId();
			}
			$typesSql = implode(', ', $types);

			$columnsSql = ($mode == 'result') ? 'DISTINCT h.id' : 'COUNT(DISTINCT h.id)';

			$sql = <<<SQL
SELECT $columnsSql
	FROM cms3_hierarchy hp, {$tablesSql}
	{$whereSql}
	AND (h.rel = 0 OR (h.rel = hp.id AND hp.type_id NOT IN ({$typesSql})))
		{$orderSql}
		{$limitSql}
SQL;
			return $sql;
		}

		protected function excludeNestedPages($ids) {
			$arr = array();
			foreach ($ids as $id => $pid) {
				if (!isset($ids[$pid])) {
					$arr[] = $id;
				}
			}

			return $arr;
		}
	};


	class selectorGetter {
		protected static $types = array('object', 'page', 'object-type', 'hierarchy-type', 'field', 'field-type', 'domain', 'lang');
		protected $requestedType;

		public function __construct($requestedType) {
			if(in_array($requestedType, self::$types) == false) {
				throw new selectorException("Wrong content type \"{$requestedType}\"");
			}
			$this->requestedType = $requestedType;
		}
		
		public function id($id) {
			if(is_array($id)) {
				$result = array();
				foreach($id as $i => $v) {
					$item = $this->id($v);
					if(is_object($item)) {
						$result[$i] = $item;
					}
					unset($item);
				}
				return $result;
			}
			if(!$id) return null;
		
			$collection = $this->collection();

			try {
				switch($this->requestedType) {
					case 'object':
						return $collection->getObject($id);
					case 'page':
						return $collection->getElement($id);
					case 'hierarchy-type':
					case 'object-type':
						return $collection->getType($id);
					case 'field':
						return $collection->getField($id);
					case 'field-type':
						return $collection->getFieldType($id);
					case 'domain':
						return $collection->getDomain($id);
					case 'lang':
						return $collection->getLang($id);
				}
			} catch (coreException $e) {
				return null;
			}
		}
		
		public function name($module, $method = '') {
			$collection = $this->collection();
		
			switch($this->requestedType) {
				case 'object-type': {
					$objectTypeId = $collection->getBaseType($module, $method);
					return $this->id($objectTypeId);
				}
				
				case 'hierarchy-type': {
					$hierarchyType = $collection->getTypeByName($module, $method);
					return ($hierarchyType instanceof iUmiHierarchyType) ? $hierarchyType : null;
				}
				
				default: throw new selectorException("Unsupported \"name\" method for \"{$this->requestedType}\"");
			}
		}
		
		public function prefix($prefix) {
			if($this->requestedType != 'lang') {
				throw new selectorException("Unsupported \"prefix\" method for \"{$this->requestedType}\"");
			}
			
			$collection = $this->collection();
			return $this->id($collection->getLangId($prefix));
		}
		
		public function host($host) {
			if($this->requestedType != 'domain') {
				throw new selectorException("Unsupported \"host\" method for \"{$this->requestedType}\"");
			}
			
			$collection = $this->collection();
			return $this->id($collection->getDomainId($host));
		}
		
		protected function collection() {
			switch($this->requestedType) {
				case 'object':
					return umiObjectsCollection::getInstance();
				case 'page':
					return umiHierarchy::getInstance();
				case 'object-type':
					return umiObjectTypesCollection::getInstance();
				case 'hierarchy-type':
					return umiHierarchyTypesCollection::getInstance();
				case 'field':
					return umiFieldsCollection::getInstance();
				case 'field-type':
					return umiFieldTypesCollection::getInstance();
				case 'domain':
					return domainsCollection::getInstance();
				case 'lang':
					return langsCollection::getInstance();
			}
		}
	};



	class selectorOption {
		protected $name, $value = array();

		public function __construct($name) {
			$allowedOptions = array('or-mode', 'root', 'exclude-nested', 'return');
			if (in_array($name, $allowedOptions)) $this->name = $name;
			else throw new selectorException("Unkown option \"{$name}\"");
		}

		public function __call($method, $args) {
			$allowedMethods = array('all', 'field', 'fields');
			$method = strtolower($method);
			if (in_array($method, $allowedMethods)) {
				$value = false;
				if ($method == 'all') $value = true;
				elseif (sizeof($args)) $value = $args;
				if ($value !== false) $this->value[$method] = $value;
			}
			elseif ($method == 'value') {
				if ($argsize = sizeof($args)) {
					if ($this->name == 'or-mode') $this->value['all'] = true;
					else {
						if ($argsize == 1 && (is_array($args[0]) || $args[0] === true || $args[0] === false)) {
							$this->value = $args[0];
						}
						else $this->value = $args;
					}
				}
				else $this->value = null;
			}
			else throw new selectorException("This property doesn't support \"{$method}\" method");
		}

		public function __get($prop) { return $this->$prop; }
	};



	class selectorHelper {
		
		static function detectFilters(selector $sel) {
			if($sel->mode == 'pages') {
				$domains = (array) getRequest('domain_id');
				foreach($domains as $domainId) {
					$sel->where('domain')->equals($domainId);
				}
				
				$langs = (array) getRequest('lang_id');
				foreach($langs as $langId) {
					$sel->where('lang')->equals($langId);
				}
			}
			
			
			if($sel->mode == 'pages' && sizeof($sel->types) && is_array(getRequest('rel'))) {
				$sel->types('hierarchy-type')->name('comments', 'comment');
			}
			
			if( isset($_REQUEST['hierarchy_types'] ) ) {
				$htypes = (array) $_REQUEST['hierarchy_types'];
				
				foreach($htypes as $v) {
					$v = explode('-',$v);
					
					if(sizeof($v)==2) 
						$sel->types('hierarchy-type')->name($v[0],$v[1]);
				}
				
			}
			
			self::detectHierarchyFilters($sel);
			self::detectWhereFilters($sel);
			self::detectOrderFilters($sel);
			
			//$sel->option('exclude-nested', true);
			
			self::checkSyncParams($sel);
		}
		
		static function checkSyncParams(selector $sel) {
			if(getRequest('export')) {
				quickCsvExporter::autoExport($sel, (bool) getRequest('force-hierarchy'));
			}
			
			if(getRequest('import')) {
				quickCsvImporter::autoImport($sel, (bool) getRequest('force-hierarchy'));
			}
		}
		
		
		static function detectHierarchyFilters(selector $sel) {
			//if(sizeof(getRequest('fields_filter'))) return;
			//if(sizeof(getRequest('order_filter'))) return;
		
			$rels = (array) getRequest('rel');
			
			if(sizeof($rels) == 0 && $sel->mode == 'pages') {				
				//$rels[] = '0';
				$sel->option('exclude-nested', true);
			}
			
			foreach($rels as $id) {
				try {
					if($id || $id === '0') $sel->where('hierarchy')->page($id)->childs(1);
					if($id === '0') $sel->option('exclude-nested', true);
				} catch (selectorException $e) {}
			}
		}
		
		static function detectWhereFilters(selector $sel) {
			static $funcs = array('eq' => 'equals', 'ne' => 'notequals', 'like' => 'like', 'gt' => 'more', 'lt' => 'less' );
			
			
			$searchAllText = (array) getRequest('search-all-text');
			//fix for guide items without fields
			if(sizeof($sel->types) == 1 && ($sel->types[0]->objectType instanceof iUmiObjectType) && sizeof($sel->types[0]->objectType->getAllFields()) == 0) {
				foreach($searchAllText as $searchString) {
					$sel->where('name')->like('%' . $searchString . '%');
				}
				return;
			} else {
				foreach($searchAllText as $searchString) {
					try {
						if($searchString !== "") $sel->where('*')->like('%' . $searchString . '%');
					} catch (selectorException $e) {}
				}
			}

			$filters = (array) getRequest('fields_filter');
			foreach($filters as $fieldName => $info) {
				if(is_array($info)) {
					//Old-style between filter
					if(isset($info[0]) && isset($info[1])) {
						try {
							$sel->where($fieldName)->between($info[0], $info[1]);
						} catch (selectorException $e) {}
					}
					
					//Try new-style filter
					foreach($info as $i => $v) {
						if(isset($funcs[$i])) {
							try {
								if($funcs[$i] == 'like') {
									$v .= '%';
								}
								
								if($v !== "") $sel->where($fieldName)->$funcs[$i]($v);
							} catch(selectorException $e) { self::tryException($e); }
						}
					}
				} else {
					//Old-style strict equals filter
					try {
						if($info !== "") $sel->where($fieldName)->equals($info);
					} catch(selectorException $e) {}
				}
			}
		}
		
		static function detectOrderFilters(selector $sel) {
			$orders = (array) getRequest('order_filter');
			foreach($orders as $fieldName => $direction) {
				$func = (strtolower($direction) == 'desc') ? 'desc' : 'asc';
				
				try {
					$sel->order($fieldName)->$func();
				} catch (selectorException $e) { self::tryException($e); }
			}
		}
		
		static private function tryException(Exception $e) {
			//if(DEBUG) throw $e;
		}
	};



abstract class def_module {
	public static
		$templates_cache = array(), $noRedirectOnPanic = false, $defaultTemplateName = 'default';

	public $max_pages = 10, $isSelectionFiltered = false;
	public $pid, $FORMS_CACHE = array(), $FORMS = array(), $per_page = 20;

	public $dataType, $actionType, $currentEditedElementId = false;
	public $__classes = array(), $libsCalled = array();
	public $common_tabs = null, $config_tabs = null;

	protected function __implement($class_name) {
		$this->__classes[] = $class_name;

		$cm = get_class_methods($class_name);

		if(is_null($cm)) return;

		$fn = "onInit";
		if(in_array($fn, $cm)) $this->$fn();

		// invoke onImplement public method :
		$fn = "onImplement";
		if (in_array($fn, $cm) && class_exists('ReflectionClass')
		&& class_exists('ReflectionMethod') && class_exists('ReflectionException')) {
			try {
				$oRfClass = new ReflectionClass($class_name);
				$oRfMethod = $oRfClass->getMethod($fn);
				if ($oRfMethod instanceof ReflectionMethod) {
					if ($oRfMethod->isPublic()) {
						eval('$res = ' . $class_name . '::' . $fn . '();');
					}
				}
			} catch (ReflectionException $e) {}
		}

	}

	public function __admin() {
		if(cmsController::getInstance()->getCurrentMode() == "admin" && !class_exists("__" . get_class($this))) {
			$this->__loadLib("__admin.php");
			$this->__implement("__" . get_class($this));
		}
	}

	public function __call($method, $args) {
		foreach($this->__classes as $className) {
			$classMethods = get_class_methods($className);
			if(is_null($classMethods)) continue;

			if(in_array($method, $classMethods)) {
				$params = "";
				if(is_array($args)) {
					$sz = sizeof($args);
					for($i = 0; $i < $sz; $i++) {
						$params .= '$args[' . $i . ']';
						if($i != $sz-1) $params .= ", ";
					}
				}
				$result = false;
				eval('$result = ' . $className . '::' . $method . '(' . $params . ');');
				return $result;
			}
		}

		$cmsController = cmsController::getInstance();
		$cmsController->langs[get_class($this)][$method] = "Ошибка";

		if($cmsController->getModule("content")) {
			if($cmsController->getCurrentMode() == "admin") {
				return "Вызов несуществующего метода.";
			} else {
				if($cmsController->getCurrentModule() == get_class($this) && $cmsController->getCurrentMethod() == $method) {
					return $cmsController->getModule("content")->gen404();
				} else {
					return "";
				}
			}
		}
	}

	public function __construct() {
		$this->lang = cmsController::getInstance()->getCurrentLang()->getPrefix();
		$this->init();
	}


	public function getCommonTabs() {
		$cmsController = cmsController::getInstance();
		$currentModule = $cmsController->getCurrentModule();
		$selfModule = get_class($this);

		if (($currentModule != $selfModule) && ($currentModule != false && $selfModule != 'users')) return false;
		if (!$this->common_tabs instanceof adminModuleTabs) {
			$this->common_tabs = new adminModuleTabs("common");
		}
		return $this->common_tabs;
	}

	public function getConfigTabs() {
		if (cmsController::getInstance()->getCurrentModule() != get_class($this)) return false;

		if (!$this->config_tabs instanceof adminModuleTabs) {
			$this->config_tabs = new adminModuleTabs("config");
		}
		return $this->config_tabs;
	}


	public function cms_callMethod($method_name, $args) {
		if(!$method_name) return;

		$aArguments = array();
		if(USE_REFLECTION_EXT && class_exists('ReflectionMethod')) {
			try {
				$oReflection   = new ReflectionMethod($this, $method_name);
				$iNeedArgCount = max($oReflection->getNumberOfRequiredParameters(), count($args));
				if($iNeedArgCount) $aArguments = array_fill(0, $iNeedArgCount, 0);
			} catch(Exception $e) {}
		}

		for($i=0; $i<count($args); $i++) $aArguments[$i] = $args[$i];

		if(count($aArguments) && !(empty($args[0]) && sizeof($args) == 1)) {
			return call_user_func_array(array($this, $method_name), $aArguments);
		} else {
			return $this->$method_name();
		}
	}

	//инициализация модуля
	public function init() {

		// подключаем кастомы из ресурсов шаблона
		// TODO: refactoring
		if ($resourcesDir = cmsController::getInstance()->getResourcesDirectory()) {
			$includesFile = realpath($resourcesDir . '/classes/modules') . '/' . get_class($this) . '/class.php';
			if (file_exists($includesFile)) {
				require_once $includesFile;
				$className = get_class($this) . '_custom';
				if (!in_array($className, $this->__classes)) {
					$this->__implement($className);
					new $className($this);
				}
			}
		}

		$includesFile = CURRENT_WORKING_DIR . '/classes/modules/' . get_class($this) . '/includes.php';
		if (file_exists($includesFile) && !defined('SKIP_MODULES_INCLUDES')) {
			require_once $includesFile;
		}
	}

	public static function install($INFO) {
		$xpath = '//modules/' . $INFO['name'];
		$regedit = regedit::getInstance();

		$regedit->setVar($xpath, $INFO['name']);

		if(is_array($INFO)) {
				foreach($INFO as $var => $module_param) {
						$val = $module_param;
						$regedit->setVar($xpath . "/" . $var, $val);
				}
		}
	}

	public function uninstall() {
		$regedit = regedit::getInstance();
		$className = get_class($this);

		$k = $regedit->getKey('//modules/' . $className);
		$regedit->delVar('//modules/' . $className);
	}

	/**
	* @desc Redirect to $url and terminate current execution
	* @param $url String Url of new location
	* @return void
	*/
	public function redirect($url, $ignoreErrorParam = true) {
		if(getRequest('redirect_disallow')) return;
		if(!$url) $url = $this->pre_lang . "/";
		if($ignoreErrorParam && (isset($this) && $this instanceof def_module)) $url = $this->removeErrorParam($url);

		umiHierarchy::getInstance()->__destruct();
		outputBuffer::current()->redirect($url);
	}


	public function requireSlashEnding() {
		if(getRequest('is_app_user') !== null) {
			return;
		}

		if(getRequest('xmlMode') == "force" || sizeof($_POST) > 0) {
			return;
		}

		if (getRequest('jsonMode') == "force" || sizeof($_POST) > 0) {
			return;
		}

		$uri = getServer('REQUEST_URI');

		$uriInfo = parse_url($uri);
		if(substr($uriInfo['path'], -1, 1) != "/") {
			$uri = $uriInfo['path'] . "/";
			if(isset($uriInfo['query']) && $uriInfo['query']) {
				$uri .= "?" . $uriInfo['query'];
			}
			self::redirect($uri);
		}
	}

	/**
	* @desc Подключает дополнительные файлы. Введена, чтобы подключать дополнительные методы в админке.
	* @param $lib String - Filename of libfile
	* @param $path String - Path to directory, where lib file is located
	* @param remember Boolean If true, do not flush cache after next use of this method.
	* @return void
	*/
	public function __loadLib($lib, $path = "", $remember = false) {
		$lib_path = ($path) ? $path . $lib : "classes/modules/" . get_class($this) . "/" . $lib;
		$path = ($path) ? $lib_path : CURRENT_WORKING_DIR . '/' . $lib_path;

		if (isset($this->FORMS_CACHE[$lib_path])) {
			$FORMS = $this->FORMS_CACHE[$lib_path];
		}
		else {
			if (file_exists($path)) require_once $path;
		}

		if($remember) {
			$this->FORMS = $FORMS;
			$this->FORMS_CACHE[$lib_path] = $FORMS;
		}
		return true;
	}

	public function setHeader($header) {
		$cmsControllerInstance = cmsController::getInstance();
		$cmsControllerInstance->currentHeader = $header;
	}

	protected function setTitle($title = "", $mode = 0) {
		$cmsControllerInstance = cmsController::getInstance();
		if($title) {
			if($mode)
				$cmsControllerInstance->currentTitle = regedit::getInstance()->getVal('//domains/' . $_REQUEST['domain'] . '/title_pref_' . $_REQUEST['lang']) . $title;
			else
				$cmsControllerInstance->currentTitle = $title;
		}
		else
			$cmsControllerInstance->currentTitle = cmsController::getInstance()->currentHeader;

	}

	protected function setH1($h1) {
		$this->setHeader($h1);
	}

	public function flush($output = "", $ctype = false) {
		if($ctype !== false) {
			header("Content-type: " . $ctype);
		}

		echo $output;
		exit();
	}

	/**
	 * @depreacted
	 * Больше не успользуется
	 */
	public static function loadTemplatesMeta($filepath = "") {
		$arguments = func_get_args();
		$templates = call_user_func_array(array('def_module', "loadTemplates"), $arguments);

		for($i=1; $i < count($arguments); $i++) {
			$templates[$i-1] = $templates[$i-1] ? array("#template" => $templates[$i-1], "#meta" => array("name" => $arguments[$i], "file" => $filepath)) : $templates[$i-1];
		}

		return $templates;
	}

	/**
	 * @static
	 * Загружает шаблоны, используя шаблонизатор в зависимости от режима работы макросов, возвращает запрошенные блоки
	 *
	 * @param string $filePath - путь к источнику шаблонов
	 * @return array
	 */
	public static function loadTemplates($filePath = "") {
		$args = func_get_args();

		$templater = self::isXSLTResultMode() ? 'umiTemplaterXSLT' : 'umiTemplaterTPL';

		if (!self::isXSLTResultMode() && !is_file($filePath)) {
			$cmsController = cmsController::getInstance();
			// получаем полный путь к tpl-шаблону
			$defaultLang = langsCollection::getInstance()->getDefaultLang();
			$currentLang = $cmsController->getCurrentLang();
			$resourcesDir = $cmsController->getResourcesDirectory();

			$langPrefix = '';
			if ($defaultLang && $currentLang && ($defaultLang->getId() != $currentLang->getId())) {
				$langPrefix = $currentLang->getPrefix();
			}

			if (substr($filePath, -4) === '.tpl') {
				$filePath = substr($filePath, 0, -4);
			}

			$filePath = ($resourcesDir ? $resourcesDir : CURRENT_WORKING_DIR) . "/tpls/" . $filePath;
			if (strlen($langPrefix) && is_file($filePath . "." . $langPrefix . ".tpl")) {
				$filePath .= "." . $langPrefix . ".tpl";
			} else {
				$filePath .= ".tpl";
			}

			$args[0] = $filePath;
		}


		$result = call_user_func_array(array(
			$templater, 'getTemplates'
		), $args);

		return $result;
	}

	/**
	 * @static
	 * Загружает шаблоны для формирования писем
	 * Сначала пытаемся загрузить XSLT-шаблон, если шаблон не найден, пытаемся загрузить TPL-шаблон
	 *
	 * @param string $filepath
	 * @return array - массив шаблонов
	 */
	public static function loadTemplatesForMail($filePath = "") {
		if (substr($filePath, -4) === '.tpl') {
			$filePath = substr($filePath, 0, -4);
		}

		// fix for mail / mails paths for xslt
		$xslFilePath = $filePath;
		if (strpos($xslFilePath, "mail") !== false) {
			$xslFilePath = str_replace(array("mail/", "mails/"), array('', ''), $xslFilePath);
		}

		if ($resourcesDir = cmsController::getInstance()->getResourcesDirectory()) {
			$xslSourcePath = $resourcesDir . "/xslt/mail/" . $xslFilePath . ".xsl";
			$tplSourcePath = $resourcesDir . "/tpls/" . $filePath . ".tpl";
		} else {
			$xslSourcePath = CURRENT_WORKING_DIR . "/xsltTpls/mail/" . $xslFilePath . ".xsl";
			$tplSourcePath = CURRENT_WORKING_DIR . "/tpls/" . $filePath . ".tpl";
		}

		$templaterClass = null;
		if (is_file($xslSourcePath)) {
			$templaterClass = 'umiTemplaterXSLT';
			$sourcePath = $xslSourcePath;
		} elseif (is_file($tplSourcePath)) {
			$templaterClass = 'umiTemplaterTPL';
			$sourcePath = $tplSourcePath;
		} else {
			throw new publicException("Невозможно подключить шаблон \"{$filePath}\" для отправки письма", 2);
		}

		$args = func_get_args();
		$args[0] = $sourcePath;

		$result = call_user_func_array(array(
			$templaterClass, 'getTemplates'
		), $args);

		return $result;
	}

	/**
	 * @static
	 * Обрабатывает TPL - макросы в контенте, используя TPL-шаблонизатор
	 *
	 * @param string $content
	 * @param mixed $scopeElementId - id страницы в качестве области видимости блока
	 * @param mixes $scopeObjectId - id объекта в качестве области видимости блока
	 * @return string
	 */
	public static function parseTPLMacroses($content, $scopeElementId = false, $scopeObjectId = false) {
		if (strpos($content, '%') === false) return $content;

		$tplTemplater = umiTemplater::create('TPL');
		$tplTemplater->setScope($scopeElementId, $scopeObjectId);
		return $tplTemplater->parse(array(), $content);
	}

	/**
	 * @static
	 * Выполняет разбор шаблона, используя необходимый шаблонизатор в зависимости от режима работы макросов
	 *
	 * @param mixed $template - шаблон для разбора
	 * @param array $arr - массив переменнх
	 * @param bool|int $parseElementPropsId - установить id страницы в качестве области видимости блока
	 * @param bool|int $parseObjectPropsId  - установить id объекта в качестве области видимости блока
	 * @param null|bool $xsltResultMode - принудительно устанавливает режим работы макросов перед разбором
	 * и восстанавливает предыдущий режим работы в конце работы
	 * @return mixed - результат разбора шаблона
	 */
	public static function parseTemplate($template, $arr, $parseElementPropsId = false, $parseObjectPropsId = false, $xsltResultMode = null) {
		$controller = cmsController::getInstance();

		if (!is_array($arr)) $arr = array();

		$oldResultMode = null;
		if (is_bool($xsltResultMode)) {
			$oldResultMode = self::isXSLTResultMode($xsltResultMode);
		}
		if (self::isXSLTResultMode()) {
			//$templater = umiTemplater::create('XSLT');
			$result = array();
			foreach($arr as $key => $val) {
				if (is_null($val) || $val === false || $val === "") continue;
				if (is_array($val)) {
					$val = self::parseTemplate($template, $val);
				}

				$subKey = xmlTranslator::getSubKey($key);
				if($subKey == "subnodes") {
					$realKey = xmlTranslator::getRealKey($key);
					$result[$realKey] = array(
						'nodes:item' => $val
					);
					continue;
				}

				$result[$key] = $val;
			}
			return $result;
		} else {
			$templater = umiTemplater::create('TPL');
			$variables = array();
			foreach($arr as $m => $v) {
				$m = self::getRealKey($m);

				if(is_array($v)) {
					$res = "";
					$v = array_values($v);
					$sz = sizeof($v);
					for($i = 0; $i < $sz; $i++) {
						$str = $v[$i];

						$listClassFirst = ($i == 0) ? "first" : "";
						$listClassLast = ($i == $sz-1) ? "last" : "";
						$listClassOdd = (($i+1) % 2 == 0) ? "odd" : "";
						$listClassEven = $listClassOdd ? "" : "even";
						$listPosition = ($i + 1);
						$listComma = $listClassLast ? '' : ', ';

						$from = Array(
							'%list-class-first%', '%list-class-last%', '%list-class-odd%', '%list-class-even%', '%list-position%',
							'%list-comma%'
						);
						$to = Array(
							$listClassFirst, $listClassLast, $listClassOdd, $listClassEven, $listPosition, $listComma
						);
						$res .= str_replace($from, $to, $str);
					}
					$v = $res;
				}

				if(!is_object($v)) {
					$variables[$m] = $v;
				}
			}
			$arr = $variables;
		}
		$templater->setScope($parseElementPropsId, $parseObjectPropsId);

		$result = $templater->parse($arr, $template);

		if (!is_null($oldResultMode)) {
			 self::isXSLTResultMode($oldResultMode);
		}

		return $result;
	}

	/**
	 * @static
	 * Выполняет разбор шаблона для отправки письма
	 * Если в template пришел URI шаблона, для обработки используется umiTemplaterXSTL
	 *
	 * @param string $template - шаблон для разбора
	 * @param array $arr - массив переменнх
	 * @param bool|int $parseElementPropsId - установить id страницы в качестве области видимости блока
	 * @param bool|int $parseObjectPropsId  - установить id объекта в качестве области видимости блока
	 * @return mixed - результат разбора шаблона
	 */
	public static function parseTemplateForMail($template, $arr, $parseElementPropsId = false, $parseObjectPropsId = false) {
		if (strpos($template, 'file://') === 0) {
			// Используем xslt-шаблонизатор
			$templateURL = @parse_url($template);
			if (!is_array($templateURL)) {
				throw new publicException('Невозможно обработать шаблон "' . $template . '"');
			}
			$templateSource = $templateURL['path'];
			$templateFragment = (isset($templateURL['fragment']) && strlen($templateURL['fragment'])) ? $templateURL['fragment'] : 'result';

			$templater = umiTemplater::create('XSLT', $templateSource);
			return $templater->parse(array(
				$templateFragment => $arr
			));
		} else {
			// Используем tpl-шаблонизатор
			return def_module::parseTemplate($template, $arr, $parseElementPropsId, $parseObjectPropsId, false);
		}
	}
	/**
	 * @deprecated
	 * Используйте def_module::parseTemplateForMail
	 */
	public static function parseContent($template, $arr, $parseElementPropsId = false, $parseObjectPropsId = false) {
		return self::parseTemplateForMail($template, $arr, $parseElementPropsId, $parseObjectPropsId);
	}

	static public function getRealKey($key, $reverse = false) {
		$shortKeys = array('@', '#', '+', '%', '*');

		if(in_array(substr($key, 0, 1), $shortKeys)) {
			return substr($key, 1);
		}

		if($pos = strpos($key, ":")) {
			++$pos;
		} else {
			$pos = 0;
		}

		return $reverse ? substr($key, 0, $pos - 1) : substr($key, $pos);
	}

	public function formatMessage($message, $b_split_long_mode = 0) {
		static $bb_from;
		static $bb_to;

		$oldResultTMode = $this->isXSLTResultMode(false);

		try {
			list($quote_begin, $quote_end) = $this->loadTemplates('quote/default', 'quote_begin', 'quote_end');
		} catch (publicException $e) {
			$quote_begin = "<div class='quote'>";
			$quote_end = "</div>";
		}

		if (self::isXSLTResultMode()) {
			$quote_begin = "<div class='quote'>";
			$quote_end = "</div>";
		}

		if (!(is_array($bb_from) && is_array($bb_to) && count($bb_from) === count($bb_to))) {
			try {
				list($bb_from, $bb_to) = $this->loadTemplates('bb/default', 'bb_from', 'bb_to');
				if (!(is_array($bb_from) && is_array($bb_to) && count($bb_from) === count($bb_to) && count($bb_to))) {
					$bb_from = Array("[b]", "[i]", "[/b]", "[/i]",
						"[quote]", "[/quote]", "[u]", "[/u]", "\r\n"
					);

					$bb_to   = Array("<strong>", "<em>", "</strong>", "</em>",
						$quote_begin, $quote_end, "<u>", "</u>", "<br />"
					);
				}
			} catch (publicException $e) {
				$bb_from = Array("[b]", "[i]", "[/b]", "[/i]",
					"[quote]", "[/quote]", "[u]", "[/u]", "\r\n"
				);

				$bb_to   = Array("<strong>", "<em>", "</strong>", "</em>",
					$quote_begin, $quote_end, "<u>", "</u>", "<br />"
				);
			}
		}

		$openQuoteCount = substr_count(wa_strtolower($message), "[quote]");
		$closeQuoteCount = substr_count(wa_strtolower($message), "[/quote]");

		if($openQuoteCount > $closeQuoteCount) {
			$message .= str_repeat("[/quote]", $openQuoteCount - $closeQuoteCount);
		}
		if($openQuoteCount < $closeQuoteCount) {
			$message = str_repeat("[quote]", $closeQuoteCount - $openQuoteCount) . $message;
		}

		$message = preg_replace("`((http)+(s)?:(//)|(www\.))((\w|\.|\-|_)+)(/)?([/|#|?|&|=|\w|\.|\-|_]+)?`i", "[url]http\\3://\\5\\6\\8\\9[/url]", $message);

		$message = str_ireplace($bb_from, $bb_to, $message);
		$message = str_ireplace("</h4>", "</h4><p>", $message);
		$message = str_ireplace("</div>", "</p></div>", $message);

		$message = str_replace(".[/url]", "[/url].", $message);
		$message = str_replace(",[/url]", "[/url],", $message);

		$message = str_replace(Array("[url][url]", "[/url][/url]"), Array("[url]", "[/url]"), $message);

		// split long words
		if ($b_split_long_mode === 0) { // default
			$arr_matches = array();
			$b_succ = preg_match_all("/[^\s^<^>]{70,}/u", $message, $arr_matches);
			if ($b_succ && isset($arr_matches[0]) && is_array($arr_matches[0])) {
				foreach ($arr_matches[0] as $str) {
					$s = "";
					if (strpos($str, "[url]") === false) {
						for ($i = 0; $i<wa_strlen($str); $i++) $s .= wa_substr($str, $i, 1).(($i % 30) === 0 ? " " : "");
						$message = str_replace($str, $s, $message);
					}
				}
			}
		} elseif ($b_split_long_mode === 1) {
			// TODU abcdef...asdf
		}


		if (preg_match_all("/\[url\]([^А-я^\r^\n^\t]*)\[\/url\]/U", $message, $matches, PREG_SET_ORDER)) {
			for ($i=0; $i<count($matches); $i++) {
				$s_url = $matches[$i][1];
				$i_length = strlen($s_url);
				if ($i_length>40) {
					$i_cutpart = ceil(($i_length-40)/2);
					$i_center = ceil($i_length/2);

					$s_url = substr_replace($s_url, "...", $i_center-$i_cutpart, $i_cutpart*2);
				}
				$message = str_replace($matches[$i][0], "<a href='/go-out.php?url=".$matches[$i][1]."' target='_blank' title='Ссылка откроется в новом окне'>".$s_url."</a>", $message);
			}
		}

		$message = str_replace("&", "&amp;", $message);


		$message = str_ireplace("[QUOTE][QUOTE]", "", $message);



		if(preg_match_all("/\[smile:([^\]]+)\]/im", $message, $out)) {
			foreach($out[1] as $smile_path) {
				$s = $smile_path;
				$smile_path = "images/forum/smiles/" . $smile_path . ".gif";
				if(file_exists($smile_path)) {
					$message = str_replace("[smile:" . $s . "]", "<img src='/{$smile_path}' />", $message);
				}
			}
		}


		$message = preg_replace("/<p>(<br \/>)+/", "<p>", $message);
		$message = nl2br($message);
		$message = str_replace("<<br />br /><br />", "", $message);
		$message = str_replace("<p<br />>", "<p>", $message);

		$message = str_replace("&amp;quot;", "\"", $message);
		$message = str_replace("&amp;quote;", "\"", $message);
		$message = html_entity_decode($message);
		$message = str_replace("%", "&#37;", $message);

		$message = $this->parseTPLMacroses($message);

		$this->isXSLTResultMode($oldResultTMode);
		return $message;
	}

	public function autoDetectAttributes() {
		if($element_id = cmsController::getInstance()->getCurrentElementId()) {
			$element = umiHierarchy::getInstance()->getElement($element_id);

			if(!$element) return false;

			if($h1 = $element->getValue("h1")) {
				$this->setHeader($h1);
			} else {
				$this->setHeader($element->getName());
			}

			if($title = $element->getValue("title")) {
				$this->setTitle($title);
			}

		}
	}


	public function autoDetectOrders(umiSelection $sel, $object_type_id) {
		if(array_key_exists("order_filter", $_REQUEST)) {
			$sel->setOrderFilter();

			$type = umiObjectTypesCollection::getInstance()->getType($object_type_id);

			$order_filter = getRequest('order_filter');
			foreach($order_filter as $field_name => $direction) {
				if($direction === "asc") $direction = true;
				if($direction === "desc") $direction = false;

				if($field_name == "name") {
					$sel->setOrderByName((bool) $direction);
					continue;
				}

				if($field_name == "ord") {
					$sel->setOrderByOrd((bool) $direction);
					continue;
				}

				if($type) {
					if($field_id = $type->getFieldId($field_name)) {
						$sel->setOrderByProperty($field_id, (bool) $direction);
					} else {
						continue;
					}
				}
			}
		} else {
			return false;
		}
	}

	public function autoDetectFilters(umiSelection $sel, $object_type_id) {
		if(is_null(getRequest('search-all-text')) == false) {
			$searchStrings = getRequest('search-all-text');
			if(is_array($searchStrings)) {
				foreach($searchStrings as $searchString) {
					if($searchString) {
						$sel->searchText($searchString);
					}
				}
			}
		}

		if(array_key_exists("fields_filter", $_REQUEST)) {
			$cmsController = cmsController::getInstance();
			$data_module = $cmsController->getModule("data");
			if(!$data_module) {
				throw new publicException("Need data module installed to use dynamic filters");
			}
			$sel->setPropertyFilter();

			$type = umiObjectTypesCollection::getInstance()->getType($object_type_id);


			$order_filter = getRequest('fields_filter');
			if(!is_array($order_filter)) {
				return false;
			}

			foreach($order_filter as $field_name => $value) {
				if($field_name == "name") {
					$data_module->applyFilterName($sel, $value);
					continue;
				}

				if($field_id = $type->getFieldId($field_name)) {
					$this->isSelectionFiltered = true;
					$field = umiFieldsCollection::getInstance()->getField($field_id);

					$field_type_id = $field->getFieldTypeId();
					$field_type = umiFieldTypesCollection::getInstance()->getFieldType($field_type_id);

					$data_type = $field_type->getDataType();

					switch($data_type) {
						case "text": {
							$data_module->applyFilterText($sel, $field, $value);
							break;
						}

						case "wysiwyg": {
							$data_module->applyFilterText($sel, $field, $value);
							break;
						}


						case "string": {
							$data_module->applyFilterText($sel, $field, $value);
							break;
						}

						case "tags": {
							$tmp = array_extract_values($value);
							if(empty($tmp)) {
								break;
							}
						}
						case "boolean": {
							$data_module->applyFilterBoolean($sel, $field, $value);
							break;
						}

						case "int": {
							$data_module->applyFilterInt($sel, $field, $value);
							break;
						}

						case "symlink":
						case "relation": {
							$data_module->applyFilterRelation($sel, $field, $value);
							break;
						}

						case "float": {
							$data_module->applyFilterFloat($sel, $field, $value);
							break;
						}

						case "price": {
							$emarket = $cmsController->getModule('emarket');
							if($emarket instanceof def_module) {
								$defaultCurrency = $emarket->getDefaultCurrency();
								$currentCurrency = $emarket->getCurrentCurrency();
								$prices = $emarket->formatCurrencyPrice($value, $defaultCurrency, $currentCurrency);
								foreach($value as $index => $void) {
									$value[$index] = getArrayKey($prices, $index);
								}
							}

							$data_module->applyFilterPrice($sel, $field, $value);
							break;
						}

						case "file":
						case "img_file":
						case "swf_file":
						case "boolean": {
							$data_module->applyFilterInt($sel, $field, $value);
							break;
						}

						case "date": {
							$data_module->applyFilterDate($sel, $field, $value);
							break;
						}

						default: {
							break;
						}
					}
				} else {
					continue;
				}
			}
		} else {
			return false;
		}
	}


	public function analyzeRequiredPath($pathOrId, $returnCurrentIfVoid = true) {

		if(is_numeric($pathOrId)) {
			return (umiHierarchy::getInstance()->isExists((int) $pathOrId)) ? (int) $pathOrId : false;
		} else {
			$pathOrId = trim($pathOrId);

			if($pathOrId) {
				if(strpos($pathOrId, " ") === false) {
					return umiHierarchy::getInstance()->getIdByPath($pathOrId);
				} else {
					$paths_arr = explode(" ", $pathOrId);

					$ids = Array();

					foreach($paths_arr as $subpath) {
						$id = $this->analyzeRequiredPath($subpath, false);

						if($id === false) {
							continue;
						} else {
							$ids[] = $id;
						}
					}

					if(sizeof($ids) > 0) {
						return $ids;
					} else {
						return false;
					}
				}
			} else {
				if($returnCurrentIfVoid) {
					return cmsController::getInstance()->getCurrentElementId();
				} else {
					return false;
				}
			}
		}
	}


	public function checkPostIsEmpty($bRedirect = true) {
		$bResult = !is_array($_POST) || (is_array($_POST) && !count($_POST));
		if ($bResult && $bRedirect) {
			$url = preg_replace("/(\r)|(\n)/", "", $_REQUEST['pre_lang'])."/admin/";
			header("Location: ".$url);
			exit();
		} else {
			return $bResult;
		}
	}


	public static function setEventPoint(umiEventPoint $eventPoint) {
		umiEventsController::getInstance()->callEvent($eventPoint);
	}

	/**
	 * @deprecated
	 * @return bool
	 */
	public function breakMe() {
		return false;
	}


	/**
		Methods for user errors notifications thru pages
	**/

	//Call this function to register error page url, which will be called after errors.
	public function errorRegisterFailPage($errorUrl) {
		cmsController::getInstance()->errorUrl = $errorUrl;
	}

	//Add new error message and call errorPanic(), is second argument is true
	public function errorNewMessage($errorMessage, $causePanic = true, $errorCode = false, $errorStrCode = false) {
		$controller = cmsController::getInstance();
		$requestId = 'errors_' . $controller->getRequestId();
		if(!isset($_SESSION[$requestId])) {
			$_SESSION[$requestId] = Array();
		}

		$errorMessage = $controller->getCurrentTemplater()->putLangs($errorMessage);

		$_SESSION[$requestId][] = Array("message" => $errorMessage,
						"code" => $errorCode,
						"strcode" => $errorStrCode);

		if($causePanic) {
			$this->errorPanic();
		}
	}


	//Forces redirect to error page, if at least one error message registrated
	public function errorPanic() {
		if(is_null(getRequest('_err')) == false) {
			return false;
		}

		if(self::$noRedirectOnPanic) {
			$requestId = 'errors_' . cmsController::getInstance()->getRequestId();
			if(!isset($_SESSION[$requestId])) {
				$_SESSION[$requestId] = Array();
			}
			$errorMessage = "";
			foreach($_SESSION[$requestId] as $i => $errorInfo) {
				unset($_SESSION[$requestId][$i]);
				$errorMessage .= $errorInfo['message'];
			}
			throw new errorPanicException($errorMessage);
		}

		if($errorUrl = cmsController::getInstance()->errorUrl) {
			// validate url
			$errorUrl = preg_replace("/_err=\d+/is", '', $errorUrl);
			while (strpos($errorUrl, '&&') !== false || strpos($errorUrl, '??') !== false || strpos($errorUrl, '?&') !== false) {
				$errorUrl = str_replace('&&', '&', $errorUrl);
				$errorUrl = str_replace('??', '?', $errorUrl);
				$errorUrl = str_replace('?&', '?', $errorUrl);
			}
			if (strlen($errorUrl) && (substr($errorUrl, -1) === '?' || substr($errorUrl, -1) === '&')) $errorUrl = substr($errorUrl, 0, strlen($errorUrl)-1);
			// detect param concat
			$sUrlConcat = (strpos($errorUrl, '?') === false ? '?' : '&');
			//
			$errorUrl .= $sUrlConcat . "_err=" . cmsController::getInstance()->getRequestId();
			$this->redirect($errorUrl, false);
		} else {
			throw new privateException("Can't find error redirect string");
		}
	}

	public function importDataTypes() {
		$sDTXmlPath = dirname(__FILE__)."/".get_class($this)."/types.xml";
		$oDTImporter = new umiModuleDataImporter();
		$bSucc = $oDTImporter->loadXmlFile($sDTXmlPath);
		if ($bSucc) {
			$oDTImporter->import();
			return "data types imported ok";
		} else {
			return "can not import data from file '".$sDTXmlPath."'";
		}
	}
	public function exportDataTypes() {
		$sDTXmlPath = dirname(__FILE__)."/".get_class($this)."/types.xml";
		$oDTExporter = new umiModuleDataExporter(get_class($this));
		$sDTXmlData = $oDTExporter->getXml();
		$vSucc = file_put_contents($sDTXmlPath, $sDTXmlData);
		if ($vSucc === false) {
			return "can not write to file '".$sDTXmlPath."'";
		} else {
			@chmod($sDTXmlPath, 0777);
			return $vSucc." bytes exported to the file '".$sDTXmlPath."' successfully";
		}
	}


	public function guessDomain() {
		$res = false;

		for($i = 0; ($param = getRequest("param" . $i)) || $i <= 3; $i++) {
			if(is_numeric($param)) {
				$element = umiHierarchy::getInstance()->getElement($param);
				if($element instanceof umiHierarchyElement) {
					$domain_id = $element->getDomainId();
					if($domain_id) $res = $domain_id;
				} else {
					continue;
				}
			} else {
				continue;
			}
		}

		$domain = domainsCollection::getInstance()->getDomain($res);
		if($domain instanceof iDomain) {
			return $domain->getHost();
		} else {
			return false;
		}
	}

	public static function pushEditable($module, $method, $id) {
		umiTemplater::pushEditable($module, $method, $id);
	}
	/**
	* @desc Checks for method existance
	* @param String $_sMethodName Name of the method
	* @return Boolean
	*/
	public function isMethodExists($_sMethodName) {//$this->__classes

		if(class_exists('ReflectionClass')) {

			$oReflection = new ReflectionClass($this);
			if($oReflection->hasMethod($_sMethodName)) {
				return true;
			}

			foreach($this->__classes as $classname) {
				$oReflection = new ReflectionClass($classname);
				if($oReflection->hasMethod($_sMethodName)) {
					return true;
				}
			}

			if ($_sMethodName == 'tagsDomainCloud') {

			}
			return false;
		} else {
			$aMethods = get_class_methods($this);
			if(in_array($_sMethodName, $aMethods)) {
				return true;
			}

			foreach($this->__classes as $classname) {
				$aMethods = get_class_methods($classname);
				if(in_array($_sMethodName, $aMethods)) {
					return true;
				}
			}


			return false;
		}
	}

	public function flushAsXML($methodName) {
		static $c = 0;
		if($c++ == 0) {
			$buffer = outputBuffer::current();
			$buffer->contentType('text/xml');
			$buffer->charset('utf-8');
			$buffer->clear();
			$buffer->push(file_get_contents("udata://" . get_class($this) . "/" . $methodName));
			$buffer->end();
		}
	}

	public function ifNotXmlMode() {
		if(getRequest('xmlMode') != 'force') {
			$this->setData(array('message' => 'This method returns result only by direct xml call'));
			return true;
		}
	}

	public function removeErrorParam($url) { return preg_replace("/_err=\d+/", "", $url); }

	public function getObjectEditLink($objectId, $type = false) { return false; }


	public static function validateTemplate(&$templateName) {
		if(!$templateName && $templateName == 'default' && self::$defaultTemplateName != 'default') {
			$templateName = self::$defaultTemplateName;
		}
	}

	public function templatesMode($mode) {
		$isXslt = self::isXSLTResultMode();
		if($mode == 'xslt' && !$isXslt) {
			throw new xsltOnlyException;
		}

		if($mode == 'tpl' && $isXslt) {
			throw new tplOnlyException;
		}
	}


	/**
	 * Устанавливает/возвращает режим работы макросов
	 * @param bool|null $newValue - если передан, то переопределяет режим работы
	 * @static
	 * @return bool - возвращает режим работы, если передан новый режим, возвращает прошлый режим работы макросов
	 */
	public static function isXSLTResultMode($newValue = null) {
		static $result = null;

		if (is_null($result)) {
			$result = cmsController::getInstance()->getCurrentTemplater() instanceof umiTemplaterXSLT;
		}

		if (!is_null($newValue)) {
			$oldValue = $result;
			$result = (bool) $newValue;
			return $oldValue;
		}

		return $result;
	}


	public function validateEntityByTypes($entity, $types, $checkParentType = false) {
		if($entity instanceof iUmiHierarchyElement) {
			$module = $entity->getModule();
			$method = $entity->getMethod();
		} else if($entity instanceof iUmiObject) {
			/**
			* @var umiObjectType
			*/
			$objectType = selector::get('object-type')->id($entity->getTypeId());
			if($checkParentType) {
				$objectType = selector::get('object-type')->id($objectType->getParentId());
			}
			if($hierarchyTypeId = $objectType->getHierarchyTypeId()) {
				$hierarchyType = selector::get('hierarchy-type')->id($hierarchyTypeId);
				$module = $hierarchyType->getModule();
				$method = $hierarchyType->getMethod();
			} else {
				$module = null;
				$method = null;
			}
		} else {
			throw new publicException("Page or object must be given");
		}

		if(is_null($module) && is_null($method) && is_null($types)) {
			return true;
		}

		if($module == 'content' && $method == '') {
			$method = 'page';
		}

		if(getArrayKey($types, 'module')) {
			$types = array($types);
		}

		foreach($types as $type) {
			$typeModule = getArrayKey($type, 'module');
			$typeMethod = getArrayKey($type, 'method');

			if($typeModule == 'content' && $typeMethod == '') {
				$typeMethod = 'page';
			}

			if($typeModule == $module) {
				if(is_null($typeMethod)) return;
				if($typeMethod == $method) return;
			}
		}
		throw new publicException(getLabel('error-common-type-mismatch'));
	}

	public function is_demo() {
		return defined('CURRENT_VERSION_LINE') && CURRENT_VERSION_LINE == 'demo';
	}

};



	
	class umiBranch {
		public static function checkIfBranchedByHierarchyTypeId($hierarchyTypeId) {
			return false;
		}
		public static function getBranchedTableByTypeId($objectTypeId) {
			return "cms3_object_content";
		}
		
		public static function saveBranchedTablesRelations() {
			return true;
		}
	};
	
	class umiEventPoint {
		public function setParam() {}
		public function getParam() {}
		public function &getRef() {}
		public function setMode() {}
		public function getMode() {}
		public function addRef() {}
		public function call() {}
		public function getEventId() { return false; }
	};
	
	class umiEventListener {
		public function setPriority() {}
		public function getPriority() {}
		public function setIsCritical() {}
		public function getIsCritical() {}
		public function getEventId() {}
		public function getCallbackModule() {}
		public function getCallbackMethod() {}
	}
	
	class umiEventsController {
		private static $oInstance  = null;
		public static function getInstance($c = NULL) {
			if(self::$oInstance == null) {
				self::$oInstance = new umiEventsController();
			}
			return self::$oInstance;
		}
		public function callEvent() {}
		static public function registerEventListener() {}
	}
	
	
?>